
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;
using System.Collections;
using System;
using System.Diagnostics;
using System.Runtime.Serialization;
using System.IO;
using UnityEngine.Networking;

public class TacticalMapScript : MonoBehaviour
{

    public RawImage engageBox;
    public Text engageTeam1Info;
    public Text engageTeam2Info;
    public Text engageText;
    public Text engageVsText;
    public RawImage engagePlayer1;
    public RawImage engagePlayer2;
    public RawImage engagePlayer3;
    public RawImage engagePlayer4;

    public Text waitIndicatorText;
    public Text guardIndicatorText;
    public Text restIndicatorText;
    public Text tauntIndicatorText;
    public Text stanceIndicatorText;
    public Text itemIndicatorText;
    public Text jumpIndicatorText;
    public Text normalIndicatorText;
    public Text specialIndicatorText;
    public Text vitalityIndicatorText;
    public Text burstIndicatorText;
    public Text moveIndicatorText;
    public Text traitIndicatorText;
    public Text confirmIndicatorText;
    public Text inventoryIndicatorText;

    public ArrayList list;
    public Location loc;

    public Boolean matchStarted;

    public float UNIVERSALSCALE;
    public float UNIVERSALOBJECTSCALE;
    public float SPRITESCALERATIO;
    public float COLORCHANGESPEED;

    public RawImage fullInputPrompt;
    public RawImage inputPrompt;
    public RawImage animationTile;

    public Camera mainCamera;

    public Canvas gameCanvas;

    public int coordinatorIndex;

    //INTRO
    public RawImage introCutsceneCanvas;
    public RawImage introCutsceneFloor;

    public Boolean intro;

    public RawImage introP1Sprite;
    public RawImage introP2Sprite;

    public RawImage introP1Sprite2;
    public RawImage introP2Sprite2;
    public RawImage introP1Sprite3;
    public RawImage introP2Sprite3;
    public RawImage introP1Sprite4;
    public RawImage introP2Sprite4;

    public RawImage introP1Portrait;

    public RawImage introP2Portrait;

    public RawImage introP1Emo;

    public RawImage introP2Emo;

    public Text introT1P1Info;
    public Text introT1P2Info;
    public Text introT1P3Info;
    public Text introT1P4Info;

    public Text introT2P1Info;
    public Text introT2P2Info;
    public Text introT2P3Info;
    public Text introT2P4Info;

    public Text introPlayerText;
    public string introP1Dialogue;
    public string introP2Dialogue;



    //OUTRO

    public RawImage outroCutsceneCanvas;

    public RawImage endgameSelectBox;
    public Text endgameWinner;
    public Text endgameInfo;

    public string outroWinnerDialogue;


    public RawImage outroP1Sprite;
    public RawImage outroP2Sprite;

    public RawImage outroP1Sprite2;
    public RawImage outroP2Sprite2;
    public RawImage outroP1Sprite3;
    public RawImage outroP2Sprite3;
    public RawImage outroP1Sprite4;
    public RawImage outroP2Sprite4;

    public RawImage outroP1Portrait;
    public RawImage outroP2Portrait;

    public RawImage outroP1Emo;
    public RawImage outroP2Emo;

    public Text outroWinnerText;

    public AudioClip endBattleMusic;

    public RawImage team1MVP;
    public RawImage team2MVP;

    //UI STUFF

    public RawImage targetInfoFrame;

    //TEST
    private StreamWriter turnOutput;

    //private Vector3 neutralPositionA;
    //private Vector3 neutralPositionB;

    //public GameObject activePlayerInfoPositionA;
    //public GameObject activePlayerInfoPositionB;
    //public GameObject teamInfoPositionA;
    //public GameObject teamInfoPositionB;

    public Text player1Text;
    public Text player2Text;

    //COLORS
    public Color fire;
    public Color ice;
    public Color electricity;
    public Color wind;
    public Color water;
    public Color earth;
    public Color metal;
    public Color darkness;
    public Color light;
    public Color broken;

    public Color healthBarStandardColorMax;
    public Color healthBarAltColorMax;

    public Color healthBarStandardColor;
    public Color healthBarAltColor;

    public Color healthBarStandardColorLow;
    public Color healthBarAltColorLow;

    public Color healthBarStandardPoison;
    public Color healthBarAltPoison;

    public Color fatigueLowColor;
    public Color fatigueColor;
    public Color fatigueHighColor;

    public Color vitalityBarStandardColor;
    public Color vitalityBarAltColor;

    public Color stunBarStandardColor;
    public Color stunBarAltColor;

    public Color highlightAvailableColor;
    public Color highlightUnavailableColor;
    public Color nonHighlightAvailableColor;
    public Color nonHighlightUnavailableColor;

    public Color team1Color;
    public Color team1TargetColor;

    public Color team2Color;
    public Color team2TargetColor;

    public Color skillLocationColor;
    public Color darkGrey;
    public Color darkerGrey;
    public Color purple;
    public Color lightPurple;
    public Color orange;
    public Color pink;
    public Color mintGreen;
    public Color darkBlue;
    public Color darkRed;
    public Color snowBlue;
    public Color lightGreen;


    public Texture2D textureMalicious;
    public Texture2D textureBeneficial;
    public Texture2D textureNeutral;
    public Texture2D textureTaunt;
    public Texture2D textureShield;
    public Texture2D textureRest;
    public Texture2D textureDizzy;

    public Texture2D neutralTexture;

    public int endGameIndex;

    private Vector3[][] originalMapPositions;

    public Boolean mapHasChanged;

    public RawImage sideFrame;

    public RawImage teamInfoFrame;
    //public Vector3 teamInfoFramePosition1;
    //public Vector3 teamInfoFramePosition2;


    public Vector3 mapTilePosition;

    Boolean loadedFromDialogue;

    public Font dialogueFont;

    public int hpXScale;
    public int hpYScale;
    public int hpZScale;

    private float squareScale;

    private float totalMatchTime;

    public RawImage skillInputDisplay;
    public RawImage linkIcon;
    public RawImage cancelIcon;
    public RawImage counterIcon;
    public RawImage actIcon;
    public RawImage skillTypeIcon;
    public Text skillText;
    public Text skillInfoText;

    private RawImage[] skillInputs;
    private RawImage[] linkIcons;
    private RawImage[] cancelIcons;
    private RawImage[] counterIcons;
    private RawImage[] actIcons;
    private RawImage[] skillTypeIcons;
    private Text[] skillTexts;
    private Text[] skillInfoTexts;

    private RawImage[] team1TargetSprites;
    private RawImage[] team1HealthBars;
    private RawImage[] team1HealthBarBackgrounds;
    private RawImage[] team1RushBars;
    private RawImage[] team1RushBarBackgrounds;
    private RawImage[] team1GuardBars;
    private RawImage[] team1GuardBarBackgrounds;
    private RawImage[] team1VitalityBars;
    private RawImage[] team1VitalityBarBackgrounds;
    private RawImage[] team1StunBars;
    private Text[] team1Names;

    private RawImage[] team2TargetSprites;
    private RawImage[] team2HealthBars;
    private RawImage[] team2HealthBarBackgrounds;
    private RawImage[] team2RushBars;
    private RawImage[] team2RushBarBackgrounds;
    private RawImage[] team2GuardBars;
    private RawImage[] team2GuardBarBackgrounds;
    private RawImage[] team2VitalityBars;
    private RawImage[] team2VitalityBarBackgrounds;
    private RawImage[] team2StunBars;
    private Text[] team2Names;

    private float[] team1Timers;
    private float[] team2Timers;

    public Font currentFont;

    public RawImage initialTile;

    public Team winningTeam;
    public Team losingTeam;

    public Boolean automated;

    Boolean playerInfoToggled;

    Boolean trainingMode;
    Boolean chessMode;
    Boolean finalRound;

    static float TEXTMOVEMENTRATE;
    float inactivityTime;
    float endPlayerTimer;

    public float textTimer;
    public Boolean matchOver;

    //public ParticleSystem particles;

    private float skillOutputDelay;

    private ArrayList meters;

    public Player[] playerTargets;

    public Boolean dialogueScreenActive;

    public Boolean outtro;

    public Text playerPopUpText;

    public RawImage northArrow;
    public RawImage eastArrow;
    public RawImage southArrow;
    public RawImage westArrow;

    public ArrayList dialogue;

    public float currentMatchTime;
    public float stepTime;
    public float stepTimeModulus;


    ArrayList p1EmoReel;
    ArrayList p2EmoReel;

    int p1EmoSpriteIndex;
    int p2EmoSpriteIndex;

    Boolean p1EmoLooping;
    Boolean p2EmoLooping;

    float p1EmoFrame;
    float p2EmoFrame;

    Vector3 p1OriginalPosition;
    Vector3 p2OriginalPosition;
    Vector3 mapUnitOriginalScale;

    public AudioClip finalRoundMusic;

    public int p1DialogueIndex;


    public int p2DialogueIndex;

    public Boolean p1Dialoguing;
    public Boolean p2Dialoguing;

    public int textCount;

    ArrayList targettedPlayers;
    Player skillExecutor;

    ArrayList playerOutputs;

    Boolean inputPressed;
    int numSounds;

    int currentSkillIndex;

    public RawImage actionIndicator;
    public RawImage movementIndicator;
    public RawImage jumpIndicator;

    Boolean skillInfoDisplaying;

    ArrayList outputIndex;

    //float notificationOutputTimer;
    ArrayList soundQueue;

    float delayBetweenInputs;
    static float MAXDELAYBETWEENINPUTS = 0.3f;

    public GameObject notificationTextObject;
    public Text notificationText;
    float notificationTextTimer;

    public ArrayList notificationTexts;

    Player holderPlayer;

    static float OUTPUTTIMER = 2.0f;

    public RawImage stageFloor;
    public RawImage stageWings;
    public RawImage stageEffects;
    public float stageEffectLoop;
    public float stageEffectSpeed;
    public ArrayList stageEffectImages;

    public RawImage playerHighlightIcon;
    public RawImage targetIcon;
    float highlightTimer;
    /**
    float outputPositionX;
    float outputPositionY;
    float outputPositionZ;
    */

    Player player1;
    Player player2;
    Player player3;
    Player player4;

    Vector3 outputPosition;
    //Vector3 outputPosition2;
    //Vector3 outputPosition3;
    //Vector3 outputPosition4;
    //Vector3 outputPosition5;
    //Vector3 outputPosition6;
    //Vector3 outputPosition7;
    //Vector3 outputPosition8;
    //Vector3 outputPosition9;
    Vector3 playerOutputPosition;


    public RawImage currentSkillInput;
    private int currentPlayerIndex;

    public RawImage nextPlayer1;
    public RawImage nextPlayer2;
    public RawImage nextPlayer3;
    public RawImage nextPlayer4;
    ArrayList nextPlayers;

    public RawImage playerSprite;
    ArrayList playerReel;
    int playerSpriteIndex;
    Boolean playerLooping;
    float PLAYERFRAMERATE, playerFrame;
    int playerAnimationsRemaining;

    public RawImage animation;
    ArrayList animationReel;
    int animationSpriteIndex;
    Boolean animationLooping;
    float REELFRAMERATE, reelFrame;
    float EMOFRAMERATE;

    public RawImage playerPowerUpSprite;
    ArrayList playerPowerUpEffects;
    int powerUpFrame;
    float POWERUPSPEED, powerUpReelFrame;

    private RawImage[][] tileMap;

    //USER 
    KeyCode UserUp,
    UserDown,
    UserBack,
    UserForward,
    UserAction,
    UserNorth,
    UserSouth,
    UserEast,
    UserWest,
    UserCancel,
    UserPause,
    UserInfo,
    UserConfirm,

    UserActionSet,
    UserJumpSet,
    UserNormalSet,
    UserSpecialSet,
    UserVitalitySet,
    UserBurstSet,
    UserItemSet,
    UserInventorySet,
    UserPaceCancelButton,
    UserGuardButton,
    UserTauntButton,
    UserRestButton,
    UserCrouchButton,
    UserWaitButton,
    UserA,
    UserB,
    UserC,
    UserD,
    UserY,
    UserZ,
    User_Alpha1,
    User_Alpha2,
    User_Alpha3,
    User_Alpha4,
    User_Alpha5,
    User_Alpha6,
    User_Alpha7,
    User_Alpha8,
    User_Alpha9,
    User_Alpha0,
    User_Keypad1,
    User_Keypad2,
    User_Keypad3,
    User_Keypad4,
    User_Keypad5,
    User_Keypad6,
    User_Keypad7,
    User_Keypad8,
    User_Keypad9,
    User_Keypad0,
    User_ScrollUp1,
    User_ScrollUp2,
    User_ScrollDown1,
    User_ScrollDown2;



    //DOUBLE KEYS
    ArrayList UserAB,
    UserAC,
    UserAD,
    UserBC,
    UserBD,
    UserCD,
    UserYZ,
    UserABC,
    UserABD,
    UserBCD,
    UserABCD,
    UserDownForward,
    UserDownBack,
    UserUpForward,
    UserUpBack;

    KeyCode P1Up,
    P1Down,
    P1Back,
    P1Forward,
    P1North,
    P1South,
    P1East,
    P1West,
    P1Action,
    P1Cancel,
    P1Pause,
    P1Info,
    P1Confirm,
    P1ActionSet,
    P1JumpSet,
    P1NormalSet,
    P1SpecialSet,
    P1VitalitySet,
    P1BurstSet,
    P1ItemSet,
    P1InventorySet,
        P1PaceCancelButton,
    P1GuardButton,
    P1TauntButton,
    P1RestButton,
    P1CrouchButton,
    P1WaitButton,
    P1A,
    P1B,
    P1C,
    P1D,
    P1Y,
    P1Z,

    P1_Alpha1,
    P1_Alpha2,
    P1_Alpha3,
    P1_Alpha4,
    P1_Alpha5,
    P1_Alpha6,
    P1_Alpha7,
    P1_Alpha8,
    P1_Alpha9,
    P1_Alpha0,
    P1_Keypad1,
    P1_Keypad2,
    P1_Keypad3,
    P1_Keypad4,
    P1_Keypad5,
    P1_Keypad6,
    P1_Keypad7,
    P1_Keypad8,
    P1_Keypad9,
    P1_Keypad0,
    P1_ScrollUp1,
    P1_ScrollUp2,
    P1_ScrollDown1,
    P1_ScrollDown2;

    //DOUBLE KEYS
    ArrayList P1AB,
    P1AC,
    P1AD,
    P1BC,
    P1BD,
    P1CD,
    P1YZ,
    P1ABC,
    P1ABD,
    P1BCD,
    P1ABCD,
    P1DownForward,
    P1DownBack,
    P1UpForward,
    P1UpBack;

    KeyCode P2Up,
    P2Down,
    P2Back,
    P2Forward,
    P2North,
    P2South,
    P2East,
    P2West,
    P2Action,
    P2Cancel,
    P2Pause,
    P2Info,
    P2Confirm,
    P2ActionSet,
    P2JumpSet,
    P2NormalSet,
    P2SpecialSet,
    P2VitalitySet,
    P2BurstSet,
    P2ItemSet,
    P2InventorySet,
        P2PaceCancelButton,
    P2GuardButton,
    P2TauntButton,
    P2RestButton,
    P2CrouchButton,
    P2WaitButton,
    P2A,
    P2B,
    P2C,
    P2D,
    P2Y,
    P2Z,
    P2_Alpha1,
    P2_Alpha2,
    P2_Alpha3,
    P2_Alpha4,
    P2_Alpha5,
    P2_Alpha6,
    P2_Alpha7,
    P2_Alpha8,
    P2_Alpha9,
    P2_Alpha0,
    P2_Keypad1,
    P2_Keypad2,
    P2_Keypad3,
    P2_Keypad4,
    P2_Keypad5,
    P2_Keypad6,
    P2_Keypad7,
    P2_Keypad8,
    P2_Keypad9,
    P2_Keypad0,
    P2_ScrollUp1,
    P2_ScrollUp2,
    P2_ScrollDown1,
    P2_ScrollDown2;

    //DOUBLE KEYS
    ArrayList P2AB,
    P2AC,
    P2AD,
    P2BC,
    P2BD,
    P2CD,
    P2YZ,
    P2ABC,
    P2ABD,
    P2BCD,
    P2ABCD,
    P2DownForward,
    P2DownBack,
    P2UpForward,
    P2UpBack;



    int chargeTime;

    public RawImage targetSprite1;
    ArrayList targetReel1;
    int targetSpriteIndex1;
    Boolean targetLooping1;
    float targetSpriteFramerate1;
    float TARGETFRAMERATE, targetFrame1;
    int target1AnimationsRemaining;

    public RawImage targetSprite2;
    ArrayList targetReel2;
    int targetSpriteIndex2;
    Boolean targetLooping2;
    float targetSpriteFramerate2;
    float targetFrame2;
    int target2AnimationsRemaining;

    //public TacticalBattleScreenScript otherPlayer;

    public RawImage targetSprite3;
    ArrayList targetReel3;
    int targetSpriteIndex3;
    Boolean targetLooping3;
    float targetSpriteFramerate3;
    float targetFrame3;
    int target3AnimationsRemaining;

    public RawImage targetSprite4;
    ArrayList targetReel4;
    int targetSpriteIndex4;
    Boolean targetLooping4;
    float targetSpriteFramerate4;
    float targetFrame4;
    int target4AnimationsRemaining;

    static float INPUTMAXVALUE = 0.15f;
    static float MENUINPUTMAXVALUE = 0.285f;

    static float FLASHTIMER = 0.05f;
    float INPUTRESETTIMER;
    float matchOverTimer;
    float engageTimer;

    Boolean firstMoveActivated;
    float passiveTime;
    float timeMax;
    float endTime;
    float upEndTime;
    public Text timeText;

    float finishTime;
    float finishTimeMax;
    Boolean inputSuccess;

    ArrayList correctInputs;
    ArrayList playerInputs;

    Map battleMap;
    DataReader reader;
    float countdown;
    float inputDelay;
    float menuInputDelay;
    float skillInputDelay;
    float animationDelay;
    Sprite[] sprites;
    //public Text battleLog;
    public Text sideFrameText;
    ArrayList inputImages;

    Location[] randomLocations;

    string fullLog;

    public RawImage playerCanvas;

    //public Player activeplayer;
    public RawImage playerPortrait;
    public Text playerName;
    public Text playerStyle;
    public Text playerStyleRatio;

    public RawImage activeTimeMeter;
    public RawImage finishTimeMeter;
    //public GameObject stepTimeMeter;

    public RawImage playerHealthBarBackground;
    public RawImage playerHealthBarSkill;
    public RawImage playerHealthBar;
    public Text playerHealthDisplay;
    float playerHealthBarTimer;

    public RawImage playerRushBarBackground;
    public RawImage playerRushBar;
    public RawImage playerRushBarSkill;
    public Text playerRushDisplay;

    public RawImage playerGuardBarBackground;
    public RawImage playerGuardBar;
    public RawImage playerGuardBarSkill;
    public Text playerGuardDisplay;

    public RawImage playerVitalityBarBackground;
    public RawImage playerVitalityBar;
    public RawImage playerVitalityBarSkill;
    public Text playerVitalityDisplay;
    float playerVitalityBarTimer;

    public RawImage playerStunBarBackground;
    public RawImage playerStunBar;
    float playerStunBarTimer;

    public RawImage playerXPBarBackground;
    public RawImage playerXPBar;

    public Text playerStatus;


    public Player activePlayer;

    //TEAM INFO
    public RawImage sampleHealthBar;

    public RawImage sampleTimeBar;

    public RawImage t1P1targetSprite;
    public Text t1P1Text;
    public RawImage t1P1HealthBarBackground;
    public RawImage t1P1HealthBar;
    public RawImage t1P1RushBarBackground;
    public RawImage t1P1RushBar;
    public RawImage t1P1GuardBarBackground;
    public RawImage t1P1GuardBar;
    public RawImage t1P1VitalityBarBackground;
    public RawImage t1P1VitalityBar;
    public RawImage t1P1StunBar;
    float t1P1HealthBarTimer;

    //
    public RawImage t2P1targetSprite;
    public Text t2P1Text;
    public RawImage t2P1HealthBarBackground;
    public RawImage t2P1HealthBar;
    public RawImage t2P1RushBarBackground;
    public RawImage t2P1RushBar;
    public RawImage t2P1GuardBarBackground;
    public RawImage t2P1GuardBar;
    public RawImage t2P1VitalityBarBackground;
    public RawImage t2P1VitalityBar;
    public RawImage t2P1StunBar;
    float t2P1HealthBarTimer;

    //TARGET

    private RawImage[] targetInfoFrames;
    private Text[] targetNames;
    private Text[] targetBasicInfos;
    private Text[] targetClassRatios;

    private RawImage[] targetPortraits;

    private RawImage[] targetHealthBarsBackground;
    private RawImage[] targetHealthBars;
    private RawImage[] targetHealthBarsEffected;
    float[] targetHealthBarsTimer;

    private RawImage[] targetRushBarsBackground;
    private RawImage[] targetRushBars;
    private RawImage[] targetRushBarsEffected;

    private RawImage[] targetGuardBarsBackground;
    private RawImage[] targetGuardBars;
    private RawImage[] targetGuardBarsEffected;

    private RawImage[] targetVitalityBarsBackground;
    private RawImage[] targetVitalityBars;
    private RawImage[] targetVitalityBarsEffected;
    float[] targetVitalityBarsTimer;

    private RawImage[] targetStunBarsBackground;
    private RawImage[] targetStunBars;
    private RawImage[] targetStunBarsEffected;
    float[] targetStunBarsTimer;

    public Text targetName;
    public Text targetBasicInfo;
    public Text targetClassRatio;

    public RawImage targetPortrait;

    public RawImage targetHealthBarBackground;
    public RawImage targetHealthBar;
    public RawImage targetHealthBarEffected;
    float targetHealthBarTimer;

    public RawImage targetRushBarBackground;
    public RawImage targetRushBar;
    public RawImage targetRushBarEffected;

    public RawImage targetGuardBarBackground;
    public RawImage targetGuardBar;
    public RawImage targetGuardBarEffected;

    public RawImage targetVitalityBarBackground;
    public RawImage targetVitalityBar;
    public RawImage targetVitalityBarEffected;
    float targetVitalityBarTimer;

    public RawImage targetStunBarBackground;
    public RawImage targetStunBar;
    public RawImage targetStunBarEffected;
    float targetStunBarTimer;



    //TARGET

    public RawImage pauseMenu;
    public RawImage pauseMenuArt;
    public Text continueText;
    public Text stageSelectText;
    public Text playerSelectText;
    public Text quitText;

    public RawImage confirmMenu;
    public RawImage confirmMenuArt;
    public Text yesText;
    public Text noText;

    int playerIndex;

    bool readingUserCommands;
    bool readingMovementAndAction;
    bool readingSkillInputs;

    ArrayList skillSet;
    Skill skill;

    public AudioSource cursorSFX;
    public AudioSource selectSFX;
    public AudioSource cancelSFX;
    public AudioSource failSFX;
    public AudioSource walkSFX;
    public AudioSource textSFX;
    public AudioSource actionSFX;
    public AudioSource hitSFX;
    public AudioSource confirmSFX;
    public AudioSource bgm;
    public AudioSource ambience;
    public AudioSource timerSFX;
    public AudioSource dizzySFX;
    public AudioSource announcerSFX;
    public AudioSource stepSFX;

    public ArrayList holderObjects;

    AudioClip mainPlayerMusic;
    private AudioClip battleMusic;

    bool willExit;
    bool[] pauseOptions;

    public RawImage[][] miniMap;
    public RawImage[][] interMap;
    public RawImage[][] projMap;
    public RawImage[] playerSprites;
    public RawImage[] playerShadows;

    public ArrayList miniMapGrid;

    Location skillLocation;

    ArrayList mapAnimationImage;
    ArrayList mapAnimationIndex;
    ArrayList mapAnimationPosition;
    ArrayList mapAnimationSize;
    ArrayList mapAnimations;
    ArrayList mapIndexes;
    ArrayList mapIndexLimits;
    ArrayList mapAnimationSpeed;

    //

    private ArrayList HitChannel;
    private ArrayList HitTextChannel;
    private ArrayList EnvironmentChannel;
    private ArrayList ElementChannel;
    private ArrayList StateChannel;
    private ArrayList StatChannel;
    private ArrayList LimitChannel;
    private ArrayList HealthChannel;
    private ArrayList ContactChannel;
    private ArrayList TurnChannel;
    private ArrayList CollisionChannel;
    private ArrayList WhiffChannel;
    private ArrayList BonusChannel;
    private ArrayList StatusChannel;
    private ArrayList KOChannel;


    //
    public RawImage playerSprite1;

    //TILE
    //0
    public RawImage tMapOriginal;

    //IMG
    //0
    public RawImage imgOriginal;

    //IMGS
    //0
    public RawImage imgsOriginal;

    public int MaxSize;

    public AudioClip battleIntroMusic;
    public AudioClip blankSound;
    public AudioClip benMagicSound;
    public AudioClip malMagicSound;
    public AudioClip guardSound;
    public AudioClip punchSound;
    public AudioClip grappleSound;
    public AudioClip clawSound;
    public AudioClip projectileSound;
    public AudioClip forceSound;
    public AudioClip weaponSound;
    public AudioClip stepSound;
    public AudioClip burstSound;
    public AudioClip vitalitySound;
    public AudioClip criticalSound;
    public AudioClip parrySound;
    public AudioClip whiffSound;
    public AudioClip beepSound;
    public AudioClip poisonSound;
    public AudioClip skillSound;
    public AudioClip reloadSound;
    public AudioClip runSound;
    public AudioClip eatSound;
    public AudioClip startSound;
    public AudioClip crashSound;
    public AudioClip fireSound;
    public AudioClip iceSound;
    public AudioClip electricitySound;
    public AudioClip metalSound;
    public AudioClip windSound;
    public AudioClip waterSound;
    public AudioClip earthSound;
    public AudioClip darknessSound;
    public AudioClip lightSound;
    public AudioClip crushSound;
    public AudioClip dingSound;
    public AudioClip healSound;
    public AudioClip adleSound;
    public AudioClip gaspSound;
    public AudioClip tauntSound;
    public AudioClip cheerSound;


    public Texture2D superInput;
    public Texture2D noInput;

    public Texture2D buttonA;
    public Texture2D buttonB;
    public Texture2D buttonC;
    public Texture2D buttonD;
    public Texture2D buttonY;
    public Texture2D buttonZ;
    public Texture2D buttonDown;
    public Texture2D buttonUp;
    public Texture2D buttonForward;
    public Texture2D buttonBack;

    public Texture2D buttonAB;
    public Texture2D buttonAC;
    public Texture2D buttonAD;
    public Texture2D buttonBC;
    public Texture2D buttonBD;
    public Texture2D buttonCD;
    public Texture2D buttonYZ;
    public Texture2D buttonDownForward;
    public Texture2D buttonDownBack;
    public Texture2D buttonUpForward;
    public Texture2D buttonUpBack;
    public Texture2D buttonABC;

    public Texture2D fireAura1;
    public Texture2D fireAura2;
    public Texture2D fireAura3;
    public Texture2D fireAura4;

    public Texture2D northArrowTexture;
    public Texture2D eastArrowTexture;
    public Texture2D southArrowTexture;
    public Texture2D westArrowTexture;

    public Boolean posX;
    public Boolean posY;


    // Use this for initialization
    void Start ()
    {
        engageBox.enabled = false;
        engageTeam1Info.enabled = false;
        engageTeam2Info.enabled = false;
        engageText.enabled = false;
        engageVsText.enabled = false;
        engagePlayer1.enabled = false;
        engagePlayer2.enabled = false;
        engagePlayer3.enabled = false;
        engagePlayer4.enabled = false;

        targetInfoFrames = new RawImage[20];

        notificationTexts = new ArrayList ();
        notificationTextTimer = -1.0f;

        targetNames = new Text[targetInfoFrames.Length];
        targetBasicInfos = new Text[targetInfoFrames.Length];
        targetClassRatios = new Text[targetInfoFrames.Length];

        targetPortraits = new RawImage[targetInfoFrames.Length];

        targetHealthBars = new RawImage[targetInfoFrames.Length];
        targetHealthBarsBackground = new RawImage[targetInfoFrames.Length];
        targetHealthBarsEffected = new RawImage[targetInfoFrames.Length];
        targetHealthBarsTimer = new float[targetInfoFrames.Length];

        targetRushBarsBackground = new RawImage[targetInfoFrames.Length];
        targetRushBars = new RawImage[targetInfoFrames.Length];
        targetRushBarsEffected = new RawImage[targetInfoFrames.Length];

        targetGuardBarsBackground = new RawImage[targetInfoFrames.Length];
        targetGuardBars = new RawImage[targetInfoFrames.Length];
        targetGuardBarsEffected = new RawImage[targetInfoFrames.Length];

        targetVitalityBarsBackground = new RawImage[targetInfoFrames.Length];
        targetVitalityBars = new RawImage[targetInfoFrames.Length];
        targetVitalityBarsEffected = new RawImage[targetInfoFrames.Length];
        targetVitalityBarsTimer = new float[targetInfoFrames.Length];

        targetStunBarsBackground = new RawImage[targetInfoFrames.Length];
        targetStunBars = new RawImage[targetInfoFrames.Length];
        targetStunBarsEffected = new RawImage[targetInfoFrames.Length];
        targetStunBarsTimer = new float[targetInfoFrames.Length];

        skillInputs = new RawImage[5];
        linkIcons = new RawImage[skillInputs.Length];
        cancelIcons = new RawImage[skillInputs.Length];
        counterIcons = new RawImage[skillInputs.Length];
        actIcons = new RawImage[skillInputs.Length];
        skillTypeIcons = new RawImage[skillInputs.Length];
        skillTexts = new Text[skillInputs.Length];
        skillInfoTexts = new Text[skillInputs.Length];

        for (int i = 0; i < targetInfoFrames.Length; i++)
        {

            targetInfoFrames[i] = cloneRawImage ("Target Info Frame " + (i + 1), targetInfoFrame, gameCanvas.transform);

            targetPortraits[i] = cloneRawImage ("Portrait " + (i + 1), targetPortrait, targetInfoFrames[i].transform);

            targetHealthBarsTimer[i] = 0f;
            targetHealthBarsBackground[i] = cloneRawImage ("Health Bar Background " + (i + 1), targetHealthBarBackground, targetInfoFrames[i].transform);
            targetHealthBars[i] = cloneRawImage ("Health Bar " + (i + 1), targetHealthBar, targetInfoFrames[i].transform);
            targetHealthBarsEffected[i] = cloneRawImage ("Health Bar Effected " + (i + 1), targetHealthBarEffected, targetInfoFrames[i].transform);

            targetRushBarsBackground[i] = cloneRawImage ("Rush Bar Background " + (i + 1), targetRushBarBackground, targetInfoFrames[i].transform);
            targetRushBars[i] = cloneRawImage ("Rush Bar " + (i + 1), targetRushBar, targetInfoFrames[i].transform);
            targetRushBarsEffected[i] = cloneRawImage ("Rush Bar Effected" + (i + 1), targetRushBarEffected, targetInfoFrames[i].transform);

            targetGuardBarsBackground[i] = cloneRawImage ("Guard Bar Background " + (i + 1), targetGuardBarBackground, targetInfoFrames[i].transform);
            targetGuardBars[i] = cloneRawImage ("Guard Bar " + (i + 1), targetGuardBar, targetInfoFrames[i].transform);
            targetGuardBarsEffected[i] = cloneRawImage ("Guard Bar Effected" + (i + 1), targetGuardBarEffected, targetInfoFrames[i].transform);

            targetVitalityBarsTimer[i] = 0f;
            targetVitalityBarsBackground[i] = cloneRawImage ("Vitality Bar Background" + (i + 1), targetVitalityBarBackground, targetInfoFrames[i].transform);
            targetVitalityBars[i] = cloneRawImage ("Vitality Bar " + (i + 1), targetVitalityBar, targetInfoFrames[i].transform);
            targetVitalityBarsEffected[i] = cloneRawImage ("Vitality Bar Effected" + (i + 1), targetVitalityBarEffected, targetInfoFrames[i].transform);

            targetStunBarsTimer[i] = 0f;
            targetStunBarsBackground[i] = cloneRawImage ("Stun Bar Background " + (i + 1), targetStunBarBackground, targetInfoFrames[i].transform);
            targetStunBars[i] = cloneRawImage ("Stun Bar " + (i + 1), targetStunBar, targetInfoFrames[i].transform);
            targetStunBarsEffected[i] = cloneRawImage ("Stun Bar Effected " + (i + 1), targetStunBarEffected, targetInfoFrames[i].transform);

            targetNames[i] = cloneText ("Name " + (i + 1), targetName, targetInfoFrames[i].transform);

            targetNames[i].enabled = false;

            targetBasicInfos[i] = cloneText ("Basic Info " + (i + 1), targetBasicInfo, targetInfoFrames[i].transform);

            targetBasicInfos[i].enabled = false;

            targetClassRatios[i] = cloneText ("Class Ratio " + (i + 1), targetClassRatio, targetInfoFrames[i].transform);

            targetClassRatios[i].enabled = false;

            targetHealthBars[i].color = healthBarAltColorMax;
            targetRushBars[i].color = broken;
            targetGuardBars[i].color = snowBlue;
            targetVitalityBars[i].color = vitalityBarStandardColor;
            targetStunBars[i].color = lightPurple;

            setCanvas (targetInfoFrames[i], false);

        }
        skillInputDisplay.enabled = false;
        linkIcon.enabled = false;
        cancelIcon.enabled = false;
        counterIcon.enabled = false;
        actIcon.enabled = false;
        skillTypeIcon.enabled = false;
        skillText.enabled = false;
        skillInfoText.enabled = false;

        setCanvas (targetInfoFrame, false);
        for (int i = 0; i < targetInfoFrames.Length; i++)
        {
            setCanvas (targetInfoFrames[i], false);
        }

        DataReader reader = new DataReader ();
        matchStarted = true;

        battleMap = reader.loadMapForBattle ();

        //loadMap ();
        //updateMap ();

        Team t1 = new Team (@"Team 1", @"1", 4);
        Team t2 = new Team (@"Team 2", @"2", 4);


        reader.loadTeam (battleMap);

        for (int i = 0; i < battleMap.Team1.Roster.Count; i++)
        {
            battleMap.Team1[i].changeLocation ((Location)battleMap.StartingPoints1[i]);
        }

        for (int i = 0; i < battleMap.Team2.Roster.Count; i++)
        {
            battleMap.Team2[i].changeLocation ((Location)battleMap.StartingPoints2[i]);
        }

        ///TEST NEW STUFF START
        team1TargetSprites = new RawImage[13];
        team1HealthBars = new RawImage[13];
        team1HealthBarBackgrounds = new RawImage[13];
        team1RushBars = new RawImage[13];
        team1RushBarBackgrounds = new RawImage[13];
        team1GuardBars = new RawImage[13];
        team1GuardBarBackgrounds = new RawImage[13];
        team1VitalityBars = new RawImage[13];
        team1VitalityBarBackgrounds = new RawImage[13];
        team1StunBars = new RawImage[13];
        team1Names = new Text[13];
        team1Timers = new float[13];

        team2TargetSprites = new RawImage[13];
        team2HealthBars = new RawImage[13];
        team2HealthBarBackgrounds = new RawImage[13];
        team2RushBars = new RawImage[13];
        team2RushBarBackgrounds = new RawImage[13];
        team2GuardBars = new RawImage[13];
        team2GuardBarBackgrounds = new RawImage[13];
        team2VitalityBars = new RawImage[13];
        team2VitalityBarBackgrounds = new RawImage[13];
        team2StunBars = new RawImage[13];
        team2Names = new Text[13];
        team2Timers = new float[13];

        team1TargetSprites[0] = t1P1targetSprite;
        team1HealthBars[0] = t1P1HealthBar;
        team1HealthBarBackgrounds[0] = t1P1HealthBarBackground;
        team1RushBars[0] = t1P1RushBar;
        team1RushBarBackgrounds[0] = t1P1RushBarBackground;
        team1GuardBars[0] = t1P1GuardBar;
        team1GuardBarBackgrounds[0] = t1P1GuardBarBackground;
        team1VitalityBars[0] = t1P1VitalityBar;
        team1VitalityBarBackgrounds[0] = t1P1VitalityBarBackground;
        team1StunBars[0] = t1P1StunBar;
        team1Names[0] = t1P1Text;

        team2TargetSprites[0] = t2P1targetSprite;
        team2HealthBars[0] = t2P1HealthBar;
        team2HealthBarBackgrounds[0] = t2P1HealthBarBackground;
        team2RushBars[0] = t2P1RushBar;
        team2RushBarBackgrounds[0] = t2P1RushBarBackground;
        team2GuardBars[0] = t2P1GuardBar;
        team2GuardBarBackgrounds[0] = t2P1GuardBarBackground;
        team2VitalityBars[0] = t2P1VitalityBar;
        team2VitalityBarBackgrounds[0] = t2P1VitalityBarBackground;
        team2StunBars[0] = t2P1StunBar;
        team2Names[0] = t2P1Text;

        int incr = 35;

        for (int i = 0; i < team1HealthBars.Length; i++)
        {
            //TEAM 1 TARGET SPRITE
            team1TargetSprites[i] = cloneRawImage ("Team 1 TG SPRITE " + (i + 1), t1P1targetSprite,
                                   gameCanvas.transform);
            team1TargetSprites[i].transform.position = new Vector3(t1P1targetSprite.transform.position.x,
                                                                 t1P1targetSprite.transform.position.y - (incr * i), 0);
            team1TargetSprites[i].enabled = false;

            //TEAM 1 HEALTH
            team1HealthBars[i] = cloneRawImage ("Team 1 HP " + (i + 1), t1P1HealthBar,
                                               gameCanvas.transform);
            team1HealthBars[i].transform.position = new Vector3(t1P1HealthBar.transform.position.x,
                                                                 t1P1HealthBar.transform.position.y - (incr * i), 0);
            team1HealthBars[i].enabled = false;

            team1HealthBarBackgrounds[i] = cloneRawImage ("Team 1 HP BG " + (i + 1), t1P1HealthBarBackground,
                                               gameCanvas.transform);
            team1HealthBarBackgrounds[i].transform.position = new Vector3(t1P1HealthBarBackground.transform.position.x,
                                                                          t1P1HealthBarBackground.transform.position.y - (incr * i), 0);
            team1HealthBarBackgrounds[i].color = Color.black;

            team1HealthBarBackgrounds[i].enabled = false;


            //TEAM 1 RUSH
            team1RushBars[i] = cloneRawImage ("Team 1 RM " + (i + 1), t1P1RushBar,
                                               gameCanvas.transform);
            team1RushBars[i].transform.position = new Vector3(t1P1RushBar.transform.position.x,
                                                                 t1P1RushBar.transform.position.y - (incr * i), 0);

            team1RushBars[i].color = darkRed;

            team1RushBars[i].enabled = false;

            team1RushBarBackgrounds[i] = cloneRawImage ("Team 1 RM BG " + (i + 1), t1P1RushBarBackground,
                                               gameCanvas.transform);
            team1RushBarBackgrounds[i].transform.position = new Vector3(t1P1RushBarBackground.transform.position.x,
                                                                          t1P1RushBarBackground.transform.position.y - (incr * i), 0);
            team1RushBarBackgrounds[i].color = Color.black;

            team1RushBarBackgrounds[i].enabled = false;

            //TEAM 1 GUARD
            team1GuardBars[i] = cloneRawImage ("Team 1 RM " + (i + 1), t1P1GuardBar,
                                               gameCanvas.transform);
            team1GuardBars[i].transform.position = new Vector3(t1P1GuardBar.transform.position.x,
                                                                 t1P1GuardBar.transform.position.y - (incr * i), 0);
            team1GuardBars[i].color = water;

            team1GuardBars[i].enabled = false;

            team1GuardBarBackgrounds[i] = cloneRawImage ("Team 1 RM BG " + (i + 1), t1P1GuardBarBackground,
                                               gameCanvas.transform);
            team1GuardBarBackgrounds[i].transform.position = new Vector3(t1P1GuardBarBackground.transform.position.x,
                                                                          t1P1GuardBarBackground.transform.position.y - (incr * i), 0);
            team1GuardBarBackgrounds[i].color = Color.black;

            team1GuardBarBackgrounds[i].enabled = false;

            //TEAM 1 VITALITY
            team1VitalityBars[i] = cloneRawImage ("Team 1 VM " + (i + 1), t1P1VitalityBar,
                                               gameCanvas.transform);
            team1VitalityBars[i].transform.position = new Vector3(t1P1VitalityBar.transform.position.x,
                                                                 t1P1VitalityBar.transform.position.y - (incr * i), 0);
            team1VitalityBars[i].color = vitalityBarStandardColor;

            team1VitalityBars[i].enabled = false;

            team1VitalityBarBackgrounds[i] = cloneRawImage ("Team 1 VM BG " + (i + 1), t1P1VitalityBarBackground,
                                               gameCanvas.transform);
            team1VitalityBarBackgrounds[i].transform.position = new Vector3(t1P1VitalityBarBackground.transform.position.x,
                                                                          t1P1VitalityBarBackground.transform.position.y - (incr * i), 0);
            team1VitalityBarBackgrounds[i].color = Color.black;

            team1VitalityBarBackgrounds[i].enabled = false;

            //TEAM 1 STUN
            team1StunBars[i] = cloneRawImage ("Team 1 ST " + (i + 1), t1P1StunBar,
                                               gameCanvas.transform);
            team1StunBars[i].transform.position = new Vector3(t1P1StunBar.transform.position.x,
                                                                 t1P1StunBar.transform.position.y - (incr * i), 0);
            team1StunBars[i].color = pink;

            team1StunBars[i].enabled = false;

            //TEAM 1 NAMES & TIMERS
            team1Names[i] = cloneText ("Team 1 Text " + (i + 1), t1P1Text,
                                               gameCanvas.transform);
            team1Names[i].transform.position = new Vector3(t1P1Text.transform.position.x,
                                                           t1P1Text.transform.position.y - (incr * i), 0);
            team1Names[i].enabled = false;

            team1Timers[i] = -1.0f;

            //TEAM 2 TARGET SPRITE
            team2TargetSprites[i] = cloneRawImage ("Team 2 TG SPRITE " + (i + 1), t2P1targetSprite,
                                   gameCanvas.transform);
            team2TargetSprites[i].transform.position = new Vector3(t2P1targetSprite.transform.position.x,
                                                                 t2P1targetSprite.transform.position.y - (incr * i), 0);
            team2TargetSprites[i].enabled = false;

            //TEAM 2 HEALTH
            team2HealthBars[i] = cloneRawImage ("Team 2 HP " + (i + 1), t2P1HealthBar,
                                   gameCanvas.transform);
            team2HealthBars[i].transform.position = new Vector3(t2P1HealthBar.transform.position.x,
                                                                 t2P1HealthBar.transform.position.y - (incr * i), 0);
            team2HealthBars[i].enabled = false;

            team2HealthBarBackgrounds[i] = cloneRawImage ("Team 2 HP BG" + (i + 1), t2P1HealthBarBackground,
                                               gameCanvas.transform);
            team2HealthBarBackgrounds[i].transform.position = new Vector3(t2P1HealthBarBackground.transform.position.x,
                                                                          t2P1HealthBarBackground.transform.position.y - (incr * i), 0);
            team2HealthBarBackgrounds[i].color = Color.black;

            team2HealthBarBackgrounds[i].enabled = false;

            //TEAM 2 RUSH
            team2RushBars[i] = cloneRawImage ("Team 2 RM " + (i + 1), t2P1RushBar,
                                               gameCanvas.transform);
            team2RushBars[i].transform.position = new Vector3(t2P1RushBar.transform.position.x,
                                                                 t2P1RushBar.transform.position.y - (incr * i), 0);
            team2RushBars[i].color = darkRed;

            team2RushBars[i].enabled = false;

            team2RushBarBackgrounds[i] = cloneRawImage ("Team 2 RM BG " + (i + 1), t2P1RushBarBackground,
                                               gameCanvas.transform);
            team2RushBarBackgrounds[i].transform.position = new Vector3(t2P1RushBarBackground.transform.position.x,
                                                                          t2P1RushBarBackground.transform.position.y - (incr * i), 0);
            team2RushBarBackgrounds[i].color = Color.black;

            team2RushBarBackgrounds[i].enabled = false;

            //TEAM 2 GUARD
            team2GuardBars[i] = cloneRawImage ("Team 2 RM " + (i + 1), t2P1GuardBar,
                                               gameCanvas.transform);
            team2GuardBars[i].transform.position = new Vector3(t2P1GuardBar.transform.position.x,
                                                                 t2P1GuardBar.transform.position.y - (incr * i), 0);
            team2GuardBars[i].color = water;

            team2GuardBars[i].enabled = false;

            team2GuardBarBackgrounds[i] = cloneRawImage ("Team 2 RM BG " + (i + 1), t2P1GuardBarBackground,
                                               gameCanvas.transform);
            team2GuardBarBackgrounds[i].transform.position = new Vector3(t2P1GuardBarBackground.transform.position.x,
                                                                          t2P1GuardBarBackground.transform.position.y - (incr * i), 0);
            team2GuardBarBackgrounds[i].color = Color.black;

            team2GuardBarBackgrounds[i].enabled = false;

            //TEAM 2 VITALITY
            team2VitalityBars[i] = cloneRawImage ("Team 2 VM " + (i + 1), t2P1VitalityBar,
                                               gameCanvas.transform);
            team2VitalityBars[i].transform.position = new Vector3(t2P1VitalityBar.transform.position.x,
                                                                 t2P1VitalityBar.transform.position.y - (incr * i), 0);
            team2VitalityBars[i].color = vitalityBarStandardColor;

            team2VitalityBars[i].enabled = false;

            team2VitalityBarBackgrounds[i] = cloneRawImage ("Team 2 VM BG " + (i + 1), t2P1VitalityBarBackground,
                                               gameCanvas.transform);
            team2VitalityBarBackgrounds[i].transform.position = new Vector3(t2P1VitalityBarBackground.transform.position.x,
                                                                          t2P1VitalityBarBackground.transform.position.y - (incr * i), 0);
            team2VitalityBarBackgrounds[i].color = Color.black;

            team2VitalityBarBackgrounds[i].enabled = false;

            //TEAM 2 STUN
            team2StunBars[i] = cloneRawImage ("Team 2 ST " + (i + 1), t2P1StunBar,
                                               gameCanvas.transform);
            team2StunBars[i].transform.position = new Vector3(t2P1StunBar.transform.position.x,
                                                                 t2P1StunBar.transform.position.y - (incr * i), 0);
            team2StunBars[i].color = pink;

            team2StunBars[i].enabled = false;

            //TEAM 2 NAMES & TIMERS
            team2Names[i] = cloneText ("Team 2 Text " + (i + 1), t2P1Text,
                                               gameCanvas.transform);
            team2Names[i].transform.position = new Vector3(t2P1Text.transform.position.x,
                                                           t2P1Text.transform.position.y - (incr * i), 0);
            team2Names[i].enabled = false;

            team2Timers[i] = -1.0f;

        }

        t1P1targetSprite.transform.position = new Vector3(-400, -400, -400);// enabled = false;
        t1P1HealthBar.transform.position = new Vector3(-400, -400, -400);
        t1P1HealthBarBackground.transform.position = new Vector3(-400, -400, -400);
        t1P1RushBar.transform.position = new Vector3(-400, -400, -400);
        t1P1RushBarBackground.transform.position = new Vector3(-400, -400, -400);
        t1P1GuardBar.transform.position = new Vector3(-400, -400, -400);
        t1P1GuardBarBackground.transform.position = new Vector3(-400, -400, -400);
        t1P1VitalityBar.transform.position = new Vector3(-400, -400, -400);
        t1P1VitalityBarBackground.transform.position = new Vector3(-400, -400, -400);
        t1P1StunBar.transform.position = new Vector3(-400, -400, -400);
        t1P1Text.transform.position = new Vector3(-400, -400, -400);

        t2P1targetSprite.transform.position = new Vector3(-400, -400, -400);
        t2P1HealthBar.transform.position = new Vector3(-400, -400, -400);
        t2P1HealthBarBackground.transform.position = new Vector3(-400, -400, -400);
        t2P1RushBar.transform.position = new Vector3(-400, -400, -400);
        t2P1RushBarBackground.transform.position = new Vector3(-400, -400, -400);
        t2P1GuardBar.transform.position = new Vector3(-400, -400, -400);
        t2P1GuardBarBackground.transform.position = new Vector3(-400, -400, -400);
        t2P1VitalityBar.transform.position = new Vector3(-400, -400, -400);
        t2P1VitalityBarBackground.transform.position = new Vector3(-400, -400, -400);
        t2P1StunBar.transform.position = new Vector3(-400, -400, -400);
        t2P1Text.transform.position = new Vector3(-400, -400, -400);

        ///TEST NEW STUFF END

        ///TEST ADDLOOP
        for (int i = 0; i < battleMap.Team1.Roster.Count; i++)
        {
            battleMap.addPlayer ((Player)battleMap.Team1[i]);
            battleMap.Team1[i].setCurrentMap (battleMap);
        }

        for (int i = 0; i < battleMap.Team2.Roster.Count; i++)
        {
            battleMap.addPlayer ((Player)battleMap.Team2[i]);
            battleMap.Team2[i].setCurrentMap (battleMap);
        }

        for (int i = 0; i < battleMap.Roster.Count; i++)
        {
            setPlayerGraphicsAndAudio ((Player)battleMap.Roster[i], i);
        }

        soundQueue = new ArrayList ();

        list = new ArrayList ();
        loc = null;
        skill = null;
        //print (playerHealthBarBackground.rectTransform.sizeDelta.x + ", " + playerHealthBarBackground.rectTransform.sizeDelta.y);

        //mainCamera.transform.SetParent (gameCanvas.transform);
        //gameCanvas.transform.SetParent (mainCamera.transform);
        //0
        squareScale = tMapOriginal.rectTransform.sizeDelta.x;

        playerHealthBar.color = healthBarAltColorMax;
        playerRushBar.color = broken;
        playerGuardBar.color = snowBlue;
        playerVitalityBar.color = vitalityBarStandardColor;
        playerStunBar.color = lightPurple;

        imgOriginal = imgOriginal.GetComponent<RawImage>();

        //THEN IMGS
        //0
        imgsOriginal = imgsOriginal.GetComponent<RawImage>();

        //THEN IMGH
        //0
        tMapOriginal = tMapOriginal.GetComponent<RawImage>();

        northArrow = northArrow.GetComponent<RawImage>();
        eastArrow = eastArrow.GetComponent<RawImage>();
        southArrow = southArrow.GetComponent<RawImage>();
        westArrow = westArrow.GetComponent<RawImage>();

        northArrow.texture = northArrowTexture;
        eastArrow.texture = eastArrowTexture;
        southArrow.texture = southArrowTexture;
        westArrow.texture = westArrowTexture;


        float increment = skillInputDisplay.rectTransform.sizeDelta.y + (skillInputDisplay.rectTransform.sizeDelta.y / 3);

        for (int i = 0; i < skillInputs.Length; i++)
        {

            skillInputs[i] = cloneRawImage ("Skill Input " + (i + 1), skillInputDisplay, gameCanvas.transform);

            if (skillInputs[i] == null)
            {
                throw new NullReferenceException ("BUGGED INPUT MECHANICS");
            }

            skillInputs[i].transform.position = new Vector3(skillInputDisplay.transform.position.x,
                skillInputDisplay.transform.position.y - (increment * i), 0);

            linkIcons[i] = cloneRawImage ("Link Icon " + (i + 1), linkIcon, gameCanvas.transform);
            linkIcons[i].transform.position = new Vector3(linkIcon.transform.position.x,
                linkIcon.transform.position.y - (increment * i), 0);

            cancelIcons[i] = cloneRawImage ("Cancel Icon " + (i + 1), cancelIcon, gameCanvas.transform);
            cancelIcons[i].transform.position = new Vector3(cancelIcon.transform.position.x,
                cancelIcon.transform.position.y - (increment * i), 0);

            counterIcons[i] = cloneRawImage ("Counter Icon " + (i + 1), counterIcon, gameCanvas.transform);
            counterIcons[i].transform.position = new Vector3(counterIcon.transform.position.x,
                counterIcon.transform.position.y - (increment * i), 0);

            actIcons[i] = cloneRawImage ("Act Icon " + (i + 1), actIcon, gameCanvas.transform);
            actIcons[i].transform.position = new Vector3(actIcon.transform.position.x,
                actIcon.transform.position.y - (increment * i), 0);

            skillTypeIcons[i] = cloneRawImage ("Skill Type Icon " + (i + 1), skillTypeIcon, gameCanvas.transform);
            skillTypeIcons[i].transform.position = new Vector3(skillTypeIcon.transform.position.x,
                skillTypeIcon.transform.position.y - (increment * i), 0);

            skillTexts[i] = cloneText ("Skill Text " + (i + 1), skillText, gameCanvas.transform);
            skillTexts[i].transform.position = new Vector3(skillText.transform.position.x + 30,
                skillText.transform.position.y - (increment * i), 0);

            skillInfoTexts[i] = cloneText ("Skill Info Text " + (i + 1), skillInfoText, gameCanvas.transform);
            skillInfoTexts[i].transform.position = new Vector3(skillInfoText.transform.position.x + 30,
                skillInfoText.transform.position.y - (increment * i), 0);
        }

        currentSkillInput.enabled = false;

        initialTile = initialTile.GetComponent<RawImage>();

        tMapOriginal.color = Color.clear;
        playerOutputs = new ArrayList ();
        clearNotifications ();

        loadMap ();

        StreamWriter writer = new StreamWriter (@"Assets/Resources/Data/PlayerOutput.txt");

        for (int i = 0; i < t1.Roster.Count; i++)
        {
            writer.WriteLine (((Player)t1.Roster[i]).ToString () + '\n' + '\n');
        }

        for (int i = 0; i < t2.Roster.Count; i++)
        {
            writer.WriteLine (((Player)t2.Roster[i]).ToString () + '\n' + '\n');
        }
        writer.Close ();

        playerSprites = new RawImage[20];
        playerShadows = new RawImage[20];

        for (int i = 0; i < playerSprites.Length; i++)
        {

            playerSprites[i] = new GameObject ().AddComponent<RawImage>();
            playerShadows[i] = new GameObject ().AddComponent<RawImage>();

            playerSprites[i].gameObject.name = "Player Sprite " + (i + 1);
            playerShadows[i].gameObject.name = "Player Shadow " + (i + 1);

            playerSprites[i].transform.SetParent (gameCanvas.transform);
            playerShadows[i].transform.SetParent (gameCanvas.transform);
            playerSprites[i].GetComponent<RectTransform>().sizeDelta = new Vector2(playerSprite1.rectTransform.sizeDelta.x, playerSprite1.rectTransform.sizeDelta.y);
            playerSprites[i].transform.SetSiblingIndex (playerSprite1.transform.GetSiblingIndex ());

            playerSprites[i].rectTransform.anchoredPosition = playerSprite.rectTransform.anchoredPosition;
            playerSprites[i].rectTransform.anchorMax = playerSprite.rectTransform.anchorMax;
            playerSprites[i].rectTransform.anchorMin = playerSprite.rectTransform.anchorMin;
            playerSprites[i].rectTransform.pivot = playerSprite.rectTransform.pivot;

            playerShadows[i].rectTransform.anchoredPosition = playerSprite.rectTransform.anchoredPosition;
            playerShadows[i].rectTransform.anchorMax = playerSprite.rectTransform.anchorMax;
            playerShadows[i].rectTransform.anchorMin = playerSprite.rectTransform.anchorMin;
            playerShadows[i].rectTransform.pivot = playerSprite.rectTransform.pivot;

            playerSprites[i].color = Color.clear;

            playerShadows[i].enabled = false;
            playerSprites[i].enabled = false;
        }

        //tMapOriginal.enabled = false;

        mapHasChanged = true;

        totalMatchTime = 0.0f;

        sampleHealthBar = sampleHealthBar.GetComponent<RawImage>();

        endPlayerTimer = 4.0f;

        endgameWinner = endgameWinner.GetComponent<Text>();
        endgameInfo = endgameInfo.GetComponent<Text>();

        playerPopUpText = playerPopUpText.GetComponent<Text>();
        sideFrame = sideFrame.GetComponent<RawImage>();

        meters = new ArrayList ();

        for (int i = 0; i < skillInputs.Length; i++)
        {
            skillInputs[i].enabled = false;
            linkIcons[i].enabled = false;
            cancelIcons[i].enabled = false;
            counterIcons[i].enabled = false;
            actIcons[i].enabled = false;
            skillTypeIcons[i].enabled = false;
            skillTexts[i].enabled = false;
            skillInfoTexts[i].enabled = false;
        }

        holderObjects = new ArrayList ();

        mapUnitOriginalScale = tMapOriginal.transform.localScale;

        player1 = null;
        player2 = null;
        player3 = null;
        player4 = null;

        inactivityTime = 0.0f;

        inputPressed = false;

        currentMatchTime = 0.0f;
        stepTime = 0.0f;
        passiveTime = 5.0f;

        mapAnimationImage = new ArrayList ();
        mapAnimationPosition = new ArrayList ();
        mapAnimationSize = new ArrayList ();
        mapAnimationIndex = new ArrayList ();
        mapAnimations = new ArrayList ();
        mapIndexes = new ArrayList ();
        mapIndexLimits = new ArrayList ();
        mapAnimationSpeed = new ArrayList ();

        nextPlayers = new ArrayList ();
        nextPlayers.Add (nextPlayer1);
        nextPlayers.Add (nextPlayer2);
        nextPlayers.Add (nextPlayer3);
        nextPlayers.Add (nextPlayer4);

        skillExecutor = null;

        skillInfoDisplaying = false;

        skill = null;
        skillSet = new ArrayList ();

        intro = true;
        outtro = false;

        finishTime = -1.1f;

        holderPlayer = new Player (-1, "", "", "", "", "", "", "", "", -1, 0.0, 0.0, "", "", 1, 0, false, true);
        TEXTMOVEMENTRATE = 0.8f / 2.5f;

        targettedPlayers = new ArrayList ();

        currentSkillInput = currentSkillInput.GetComponent<RawImage>();

        StreamReader inputReader = new StreamReader (@"Assets/Resources/Data/UserInputs/P1.txt");

        P1Up = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1Down = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1Back = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1Forward = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1North = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1South = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1West = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1East = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1Action = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1Cancel = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1Info = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1Confirm = KeyCode.Return; inputReader.ReadLine ().Substring (7);//(KeyCode) ((KeyCode) System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1Pause = KeyCode.Escape; inputReader.ReadLine ().Substring (7);//(KeyCode) ((KeyCode) System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1ActionSet = KeyCode.LeftShift; inputReader.ReadLine ().Substring (7);//(KeyCode) ((KeyCode) System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1JumpSet = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1NormalSet = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1SpecialSet = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1VitalitySet = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1BurstSet = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1ItemSet = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1InventorySet = KeyCode.Backspace; inputReader.ReadLine ().Substring (7);//(KeyCode) ((KeyCode) System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1PaceCancelButton = KeyCode.RightShift; inputReader.ReadLine().Substring(7);//(KeyCode)((KeyCode)System.Enum.Parse(typeof(KeyCode), inputReader.ReadLine().Substring(7)));
        P1GuardButton = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1TauntButton = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1RestButton = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1CrouchButton = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1WaitButton = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1A = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1B = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1C = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1D = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1Y = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1Z = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));

        P1_Alpha1 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Alpha2 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Alpha3 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Alpha4 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Alpha5 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Alpha6 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Alpha7 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Alpha8 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Alpha9 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Alpha0 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));

        P1_Keypad1 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Keypad2 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Keypad3 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Keypad4 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Keypad5 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Keypad6 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Keypad7 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Keypad8 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Keypad9 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_Keypad0 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));

        P1_ScrollUp1 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_ScrollUp2 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_ScrollDown1 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1_ScrollDown2 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P1AB = new ArrayList { P1A, P1B };
        P1AC = new ArrayList { P1A, P1C };
        P1AD = new ArrayList { P1A, P1D };
        P1BC = new ArrayList { P1B, P1C };
        P1BD = new ArrayList { P1B, P1D };
        P1CD = new ArrayList { P1C, P1D };
        P1YZ = new ArrayList { P1Y, P1Z };
        P1ABC = new ArrayList { P1A, P1B, P1C };
        P1BCD = new ArrayList { P1B, P1C, P1D };
        P1ABCD = new ArrayList { P1A, P1B, P1C, P1D };

        inputReader.Close ();

        inputReader = new StreamReader (@"Assets/Resources/Data/UserInputs/P2.txt");

        P2Up = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2Down = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2Back = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2Forward = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2North = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2South = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2West = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2East = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2Action = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2Cancel = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2Info = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2Confirm = KeyCode.Return; inputReader.ReadLine ().Substring (7);//(KeyCode) ((KeyCode) System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2Pause = KeyCode.Escape; inputReader.ReadLine ().Substring (7);//(KeyCode) ((KeyCode) System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2ActionSet = KeyCode.LeftShift; inputReader.ReadLine ().Substring (7);//(KeyCode) ((KeyCode) System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2JumpSet = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2NormalSet = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2SpecialSet = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2VitalitySet = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2BurstSet = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2ItemSet = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2InventorySet = KeyCode.Backspace; inputReader.ReadLine ().Substring (7);//(KeyCode) ((KeyCode) System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2PaceCancelButton = KeyCode.RightShift; inputReader.ReadLine().Substring(7);//(KeyCode)((KeyCode)System.Enum.Parse(typeof(KeyCode), inputReader.ReadLine().Substring(7)));
        //P2PaceCancelButton = (KeyCode)((KeyCode)System.Enum.Parse(typeof(KeyCode), inputReader.ReadLine().Substring(7)));
        P2GuardButton = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2TauntButton = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2RestButton = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2CrouchButton = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2WaitButton = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2A = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2B = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2C = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2D = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2Y = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2Z = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));

        P2_Alpha1 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Alpha2 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Alpha3 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Alpha4 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Alpha5 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Alpha6 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Alpha7 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Alpha8 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Alpha9 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Alpha0 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));

        P2_Keypad1 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Keypad2 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Keypad3 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Keypad4 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Keypad5 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Keypad6 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Keypad7 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Keypad8 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Keypad9 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_Keypad0 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));

        P2_ScrollUp1 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_ScrollUp2 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_ScrollDown1 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2_ScrollDown2 = (KeyCode)((KeyCode)System.Enum.Parse (typeof (KeyCode), inputReader.ReadLine ().Substring (7)));
        P2AB = new ArrayList { P2A, P2B };
        P2AC = new ArrayList { P2A, P2C };
        P2AD = new ArrayList { P2A, P2D };
        P2BC = new ArrayList { P2B, P2C };
        P2BD = new ArrayList { P2B, P2D };
        P2CD = new ArrayList { P2C, P2D };
        P2YZ = new ArrayList { P2Y, P2Z };
        P2ABC = new ArrayList { P2A, P2B, P2C };
        P2BCD = new ArrayList { P2B, P2C, P2D };
        P2ABCD = new ArrayList { P2A, P2B, P2C, P2D };

        inputReader.Close ();


        //SINGLE KEYS

        chargeTime = 4;

        highlightTimer = 0.0f;

        playerTargets = new Player[4];
        for (int i = 0; i < playerTargets.Length; i++)
        {
            playerTargets[i] = null;
        }

        playerHighlightIcon = playerHighlightIcon.GetComponent<RawImage>();

        matchOver = false;

        inputPrompt = inputPrompt.GetComponent<RawImage>();
        inputPrompt.enabled = false;
        inputImages = new ArrayList ();

        playerSprite = playerSprite.GetComponent<RawImage>();
        playerSprite.enabled = false;
        playerReel = new ArrayList ();
        playerSpriteIndex = 0;
        playerLooping = false;
        PLAYERFRAMERATE = 0.2f;
        playerFrame = 0.0f;

        animation = animation.GetComponent<RawImage>();
        animation.enabled = false;
        animationReel = new ArrayList ();
        animationSpriteIndex = 0;
        animationLooping = false;
        REELFRAMERATE = 0.2f;
        reelFrame = 0.0f;

        EMOFRAMERATE = 0.06f;

        playerPowerUpSprite = playerPowerUpSprite.GetComponent<RawImage>();
        playerPowerUpSprite.enabled = false;
        playerPowerUpEffects = new ArrayList ();
        powerUpFrame = 0;
        POWERUPSPEED = 0.1f;
        powerUpReelFrame = 0.0f;

        targetSprite1 = targetSprite1.GetComponent<RawImage>();
        targetSprite1.color = Color.red;
        targetSprite1.enabled = false;
        targetReel1 = new ArrayList ();
        targetSpriteIndex1 = 0;
        targetLooping1 = false;
        TARGETFRAMERATE = 0.2f;
        targetFrame1 = 0.0f;

        targetSprite2 = targetSprite2.GetComponent<RawImage>();
        targetSprite1.color = Color.white;
        targetSprite2.enabled = false;
        targetReel2 = new ArrayList ();
        targetSpriteIndex2 = 0;
        targetLooping2 = false;
        targetFrame2 = 0.0f;

        targetSprite3 = targetSprite3.GetComponent<RawImage>();
        targetSprite3.color = Color.blue;
        targetSprite3.enabled = false;
        targetReel3 = new ArrayList ();
        targetSpriteIndex3 = 0;
        targetLooping3 = false;
        targetFrame3 = 0.0f;

        targetSprite4 = targetSprite4.GetComponent<RawImage>();
        targetSprite4.color = Color.black;
        targetSprite4.enabled = false;
        targetReel4 = new ArrayList ();
        targetSpriteIndex4 = 0;
        targetLooping4 = false;
        targetFrame4 = 0.0f;

        playerAnimationsRemaining = 0;
        target1AnimationsRemaining = 0;
        target2AnimationsRemaining = 0;
        target3AnimationsRemaining = 0;
        target4AnimationsRemaining = 0;

        inputDelay = -1.0f;
        menuInputDelay = -1.0f;
        skillInputDelay = -1.0f;

        timeText = timeText.GetComponent<Text>();
        timeText.text = "";

        inputPrompt = inputPrompt.GetComponent<RawImage>();
        fullInputPrompt = fullInputPrompt.GetComponent<RawImage>();

        inputPrompt.enabled = false;
        fullInputPrompt.enabled = false;

        //TEST
        turnOutput = new StreamWriter (@"Assets/Resources/Data/TurnOutput.txt", true);
        turnOutput.AutoFlush = true;
        turnOutput.WriteLine ("---NEW MATCH---");
        //turnOutput.Close ();
        matchOverTimer = -1.0f;
        engageTimer = -1.0f;

        playerInfoToggled = false;

        dialogueScreenActive = true;

        endGameIndex = 0;

        hpXScale = 15;
        hpYScale = 2;
        hpZScale = 0;

        correctInputs = new ArrayList ();
        playerInputs = new ArrayList ();

        randomLocations = new Location[4];

        skillLocation = null;

        playerIndex = 0;

        finishTime = -0.1f;
        finishTime = 1.0f;
        inputSuccess = false;

        playerPortrait = playerPortrait.GetComponent<RawImage>();
        playerName = playerName.GetComponent<Text>();
        playerStyle = playerStyle.GetComponent<Text>();
        playerStatus = playerStatus.GetComponent<Text>();

        //

        playerHealthBarTimer = -5.0f;

        playerVitalityBarTimer = -5.0f;

        playerStunBarTimer = -5.0f;

        targettedPlayers = new ArrayList ();

        playerOutputs = new ArrayList ();

        playerOutputPosition = new Vector3(notificationTextObject.transform.position.x,
            notificationTextObject.transform.position.y,
            notificationTextObject.transform.position.z);


        notificationText.text = "";

        notificationTextObject.transform.SetAsLastSibling ();

        notificationTextTimer = -1.0f;

        notificationTexts = new ArrayList ();

        ///battleLog = battleLog.GetComponent<Text>();
        sideFrameText = sideFrameText.GetComponent<Text>();
        fullLog = "";

        introP1Portrait = introP1Portrait.GetComponent<RawImage>();
        outroP1Portrait = outroP1Portrait.GetComponent<RawImage>();

        introP2Portrait = introP2Portrait.GetComponent<RawImage>();
        outroP2Portrait = outroP2Portrait.GetComponent<RawImage>();

        p1OriginalPosition = introP1Portrait.transform.position;
        p2OriginalPosition = introP2Portrait.transform.position;

        //pauseMenu = pauseMenu.GetComponent<Canvas> ();
        //pauseMenuArt = pauseMenuArt.GetComponent<RawImage> ();
        continueText = continueText.GetComponent<Text>();
        playerSelectText = playerSelectText.GetComponent<Text>();
        quitText = quitText.GetComponent<Text>();

        //confirmMenu = confirmMenu.GetComponent<Canvas> ();
        //confirmMenuArt = confirmMenuArt.GetComponent<RawImage> ();
        yesText = yesText.GetComponent<Text>();
        noText = noText.GetComponent<Text>();

        numSounds = 0;
        cursorSFX = cursorSFX.GetComponent<AudioSource>();
        numSounds++;
        selectSFX = selectSFX.GetComponent<AudioSource>();
        numSounds++;
        cancelSFX = cancelSFX.GetComponent<AudioSource>();
        numSounds++;
        failSFX = failSFX.GetComponent<AudioSource>();
        numSounds++;
        walkSFX = walkSFX.GetComponent<AudioSource>();
        numSounds++;
        textSFX = textSFX.GetComponent<AudioSource>();
        numSounds++;
        actionSFX = actionSFX.GetComponent<AudioSource>();
        numSounds++;
        hitSFX = hitSFX.GetComponent<AudioSource>();
        numSounds++;
        confirmSFX = confirmSFX.GetComponent<AudioSource>();
        numSounds++;
        bgm = bgm.GetComponent<AudioSource>();
        numSounds++;
        ambience = ambience.GetComponent<AudioSource>();
        numSounds++;
        dizzySFX = dizzySFX.GetComponent<AudioSource>();
        numSounds++;
        announcerSFX = announcerSFX.GetComponent<AudioSource>();
        announcerSFX.volume = announcerSFX.maxDistance;
        numSounds++;
        timerSFX = timerSFX.GetComponent<AudioSource>();
        stepSFX = stepSFX.GetComponent<AudioSource>();

        HitChannel = new ArrayList ();
        HitTextChannel = new ArrayList ();
        EnvironmentChannel = new ArrayList ();
        ElementChannel = new ArrayList ();
        StateChannel = new ArrayList ();
        StatChannel = new ArrayList ();
        LimitChannel = new ArrayList ();
        HealthChannel = new ArrayList ();
        ContactChannel = new ArrayList ();
        TurnChannel = new ArrayList ();
        CollisionChannel = new ArrayList ();
        WhiffChannel = new ArrayList ();
        BonusChannel = new ArrayList ();
        StatusChannel = new ArrayList ();
        KOChannel = new ArrayList ();

        for (int i = 0; i < 3; i++)
        {
            HitChannel.Add (new GameObject ().AddComponent<AudioSource>());
            ((AudioSource)HitChannel[i]).gameObject.name = "Hit Channel A " + (i + 1);
            HitChannel.Add (new GameObject ().AddComponent<AudioSource>());
            ((AudioSource)HitChannel[i]).gameObject.name = "Hit Channel B " + (i + 1);
            HitTextChannel.Add (new GameObject ().AddComponent<AudioSource>());
            ((AudioSource)HitTextChannel[i]).gameObject.name = "Hit Text Channel " + (i + 1);
            EnvironmentChannel.Add (new GameObject ().AddComponent<AudioSource>());
            ((AudioSource)EnvironmentChannel[i]).gameObject.name = "Environment Channel " + (i + 1);
            ElementChannel.Add (new GameObject ().AddComponent<AudioSource>());
            ((AudioSource)ElementChannel[i]).gameObject.name = "Element Channel " + (i + 1);
            StateChannel.Add (new GameObject ().AddComponent<AudioSource>());
            ((AudioSource)StateChannel[i]).gameObject.name = "State Channel " + (i + 1);
            StatChannel.Add (new GameObject ().AddComponent<AudioSource>());
            ((AudioSource)StatChannel[i]).gameObject.name = "Stat Channel " + (i + 1);
            LimitChannel.Add (new GameObject ().AddComponent<AudioSource>());
            ((AudioSource)LimitChannel[i]).gameObject.name = "Limit Channel " + (i + 1);
            HealthChannel.Add (new GameObject ().AddComponent<AudioSource>());
            ((AudioSource)HealthChannel[i]).gameObject.name = "Health Channel " + (i + 1);
            ContactChannel.Add (new GameObject ().AddComponent<AudioSource>());
            ((AudioSource)ContactChannel[i]).gameObject.name = "Contact Channel " + (i + 1);
            TurnChannel.Add (new GameObject ().AddComponent<AudioSource>());
            ((AudioSource)TurnChannel[i]).gameObject.name = "Turn Channel" + (i + 1);
            CollisionChannel.Add (new GameObject ().AddComponent<AudioSource>());
            ((AudioSource)CollisionChannel[i]).gameObject.name = "Collision Channel " + (i + 1);
            WhiffChannel.Add (new GameObject ().AddComponent<AudioSource>());
            ((AudioSource)WhiffChannel[i]).gameObject.name = "Whiff Channel " + (i + 1);
            BonusChannel.Add (new GameObject ().AddComponent<AudioSource>());
            ((AudioSource)BonusChannel[i]).gameObject.name = "Bonus Channel " + (i + 1);
            StatusChannel.Add (new GameObject ().AddComponent<AudioSource>());
            ((AudioSource)StatusChannel[i]).gameObject.name = "Status Channel " + (i + 1);
            KOChannel.Add (new GameObject ().AddComponent<AudioSource>());
            ((AudioSource)KOChannel[i]).gameObject.name = "KO Channel " + (i + 1);
        }

        battleMap.MapOwner.Vocals.Speech = new GameObject ().AddComponent<AudioSource>();
        battleMap.MapOwner.Vocals.Speech.gameObject.name = battleMap.Name + " Sound Channel";

        numSounds++;
        battleMap.MapOwner.Vocals.ContactSound = new GameObject ().AddComponent<AudioSource>();
        battleMap.MapOwner.Vocals.ContactSound.gameObject.name = battleMap.Name + " Contact Channel"; ;
        numSounds++;

        neutralTexture = Resources.Load<Texture2D>(@"Textures/Neutral");

        countdown = 2.0f;

        pauseOptions = new bool[4];
        for (int i = 0; i < pauseOptions.Length; i++)
        {
            pauseOptions[i] = false;
        }

        readingUserCommands = true;
        finishTime = -1.0f;
        finishTimeMax = -1.0f;
        inputSuccess = true;
        readingSkillInputs = false;

        //appropriateSkills = new ArrayList ();

        setPauseMenu (false);
        setConfirmMenu (false);


        //LOAD MAP AND MUSIC
        string musicPath = @"Music/" + battleMap.Music;
        mainPlayerMusic = Resources.Load (musicPath) as AudioClip;
        if (mainPlayerMusic == null)
        {
            print (musicPath + " not found");
        }
        else
        {
            if (battleMap.Team1[0].SearchName.Equals (battleMap.Team2[0].SearchName))
            {

                battleMusic = Resources.Load<AudioClip>(@"Music/mirrormatch");
            }
            else
            {
                battleMusic = mainPlayerMusic;
            }
            print (battleMusic.name);
        }
        bgm.clip = battleMusic;
        bgm.Play ();


        setHeightMap ();

        StreamReader modeReader = new StreamReader (@"Assets/Resources/Data/Current/Mode.txt");
        string mode = modeReader.ReadLine ();

        battleMap.Mode = mode;
        if (mode == "training")
        {
            trainingMode = true;
            chessMode = false;
        }
        else if (mode == "chess")
        {
            battleMap.Team1.ChessMode = true;
            battleMap.Team2.ChessMode = true;
            chessMode = true;
            trainingMode = false;
        }
        else if (mode == "versus")
        {
            trainingMode = false;
            chessMode = false;
        }
        else if (mode == "saved")
        {
            DataReader rd = new DataReader ();
            battleMap = rd.loadMatch ();
        }
        modeReader.Close ();

        sortAllObjects ();
        battleMap.Roster.Sort ();
        setNewActivePlayer (null, false);
        updateMap (activePlayer);

        beginMatch ();

    }

    public void setTileMap ()
    {
        originalMapPositions = new Vector3[battleMap.Rows][];

        tileMap = new RawImage[battleMap.Rows][];
        for (int i = 0; i < tileMap.Length; i++)
        {
            tileMap[i] = new RawImage[battleMap.Columns];
            originalMapPositions[i] = new Vector3[battleMap.Columns];
            for (int j = 0; j < tileMap[i].Length; j++)
            {

                tileMap[i][j] = new GameObject ().AddComponent<RawImage>();

                tileMap[i][j].transform.SetParent (gameCanvas.transform);

                tileMap[i][j].gameObject.name = "Tile" + (i + 1) + "x" + (j + 1);

                tileMap[i][j].GetComponent<RectTransform>().sizeDelta = new Vector2(squareScale, squareScale);

                tileMap[i][j].rectTransform.anchoredPosition = tMapOriginal.rectTransform.anchoredPosition;
                tileMap[i][j].rectTransform.anchorMax = tMapOriginal.rectTransform.anchorMax;
                tileMap[i][j].rectTransform.anchorMin = tMapOriginal.rectTransform.anchorMin;
                tileMap[i][j].rectTransform.pivot = tMapOriginal.rectTransform.pivot;

                tileMap[i][j].texture = tMapOriginal.texture;


                tileMap[i][j].transform.position =
                    new Vector3(tMapOriginal.transform.position.x + (squareScale * j),
                        tMapOriginal.transform.position.y - (squareScale * i),
                        0);
                originalMapPositions[i][j] = new Vector3(tileMap[i][j].transform.position.x,
                    tileMap[i][j].transform.position.y + MapAdjustedHeight (i, j), 0);

                tileMap[i][j].texture = tMapOriginal.texture;

                tileMap[i][j].transform.SetAsLastSibling ();

            }
        }
    }

    public void setMiniMap ()
    {
        miniMap = new RawImage[battleMap.Rows][];
        for (int i = 0; i < miniMap.Length; i++)
        {
            miniMap[i] = new RawImage[battleMap.Columns];
            for (int j = 0; j < miniMap[i].Length; j++)
            {

                miniMap[i][j] = new GameObject ().AddComponent<RawImage>();

                miniMap[i][j].gameObject.name = "MiniMap" + (i + 1) + "x" + (j + 1);

                miniMap[i][j].transform.SetParent (gameCanvas.transform);

                miniMap[i][j].GetComponent<RectTransform>().sizeDelta = new Vector2(squareScale, squareScale);

                miniMap[i][j].rectTransform.anchoredPosition = tMapOriginal.rectTransform.anchoredPosition;
                miniMap[i][j].rectTransform.anchorMax = tMapOriginal.rectTransform.anchorMax;
                miniMap[i][j].rectTransform.anchorMin = tMapOriginal.rectTransform.anchorMin;
                miniMap[i][j].rectTransform.pivot = tMapOriginal.rectTransform.pivot;

                miniMap[i][j].transform.position =
                    new Vector3(tMapOriginal.transform.position.x + (squareScale * j),
                        tMapOriginal.transform.position.y - (squareScale * i),
                        0);

                miniMap[i][j].texture = tMapOriginal.texture;

                miniMap[i][j].transform.SetAsLastSibling ();
            }
        }
    }

    public void setInterMap ()
    {
        interMap = new RawImage[battleMap.Rows][];
        for (int i = 0; i < interMap.Length; i++)
        {
            interMap[i] = new RawImage[battleMap.Columns];
            for (int j = 0; j < interMap[i].Length; j++)
            {

                interMap[i][j] = new GameObject ().AddComponent<RawImage>();

                interMap[i][j].gameObject.name = "Interactibles" + (i + 1) + "x" + (j + 1);

                interMap[i][j].transform.SetParent (gameCanvas.transform);

                interMap[i][j].GetComponent<RectTransform>().sizeDelta = new Vector2(squareScale, squareScale);

                interMap[i][j].rectTransform.anchoredPosition = tMapOriginal.rectTransform.anchoredPosition;
                interMap[i][j].rectTransform.anchorMax = tMapOriginal.rectTransform.anchorMax;
                interMap[i][j].rectTransform.anchorMin = tMapOriginal.rectTransform.anchorMin;
                interMap[i][j].rectTransform.pivot = tMapOriginal.rectTransform.pivot;

                interMap[i][j].transform.position =
                    new Vector3(tMapOriginal.transform.position.x + (squareScale * j),
                        tMapOriginal.transform.position.y - (squareScale * i),
                        0);
                interMap[i][j].texture = tMapOriginal.texture;

                interMap[i][j].transform.SetAsLastSibling ();

            }
        }
    }

    public void setProjMap ()
    {
        projMap = new RawImage[battleMap.Rows][];
        for (int i = 0; i < projMap.Length; i++)
        {
            projMap[i] = new RawImage[battleMap.Columns];
            for (int j = 0; j < projMap[i].Length; j++)
            {

                projMap[i][j] = new GameObject ().AddComponent<RawImage>();

                projMap[i][j].gameObject.name = "Projectiles" + (i + 1) + "x" + (j + 1);

                projMap[i][j].transform.SetParent (gameCanvas.transform);

                projMap[i][j].GetComponent<RectTransform>().sizeDelta = new Vector2(squareScale, squareScale);

                projMap[i][j].rectTransform.anchoredPosition = tMapOriginal.rectTransform.anchoredPosition;
                projMap[i][j].rectTransform.anchorMax = tMapOriginal.rectTransform.anchorMax;
                projMap[i][j].rectTransform.anchorMin = tMapOriginal.rectTransform.anchorMin;
                projMap[i][j].rectTransform.pivot = tMapOriginal.rectTransform.pivot;

                projMap[i][j].transform.position =
                    new Vector3(tMapOriginal.transform.position.x + (squareScale * j),
                        tMapOriginal.transform.position.y - (squareScale * i),
                        0);
                projMap[i][j].texture = tMapOriginal.texture;

                projMap[i][j].transform.SetAsLastSibling ();

            }
        }
    }

    // Update is called once per frame
    void Update ()
    {
        reduceInputDelays ();

        if (dialogueScreenActive)
        {

            //ALWAYS ANIMATED
            if (p1EmoLooping)
            {
                p1EmoFrame += Time.deltaTime;
                if (p1EmoFrame >= EMOFRAMERATE)
                {
                    //ANIMATION INDEX
                    p1EmoSpriteIndex++;
                    if (p1EmoSpriteIndex >= p1EmoReel.Count)
                    {
                        p1EmoSpriteIndex = 0;
                    }
                    if (!matchOver)
                    {
                        introP1Emo.texture = (Texture2D)p1EmoReel[p1EmoSpriteIndex];
                    }
                    else
                    {
                        outroP1Emo.texture = (Texture2D)p1EmoReel[p1EmoSpriteIndex];
                    }

                    p1EmoFrame = 0.0f;
                }
            }

            //ALWAYS ANIMATED
            if (battleMap.StageEffectLoops > 0)
            {
                stageEffectLoop += Time.deltaTime;
                if (stageEffectLoop >= battleMap.StageEffectLoops)
                {
                    stageEffectSpeed++;
                    if (stageEffectSpeed >= battleMap.StageEffectSpeed) {
                        stageEffectSpeed = 0;
                    }

                }
            }

            if (p2EmoLooping)
            {
                p2EmoFrame += Time.deltaTime;
                if (p2EmoFrame >= EMOFRAMERATE)
                {
                    //ANIMATION INDEX
                    p2EmoSpriteIndex++;
                    if (p2EmoSpriteIndex >= p2EmoReel.Count)
                    {
                        p2EmoSpriteIndex = 0;
                    }
                    if (!matchOver)
                    {
                        introP2Emo.texture = (Texture2D)p2EmoReel[p2EmoSpriteIndex];
                    }
                    else
                    {
                        outroP2Emo.texture = (Texture2D)p2EmoReel[p2EmoSpriteIndex];

                    }
                    p2EmoFrame = 0.0f;
                }
            }

            if (p1Dialoguing || p2Dialoguing)
            {
                if (p1Dialoguing)
                {
                    if (!battleMap.Team1.IsDefeated && !battleMap.Team2.IsDefeated)
                    {
                        updateCutsceneText (ref introP1Dialogue, ref introPlayerText, ref p1DialogueIndex, ref p1Dialoguing, ref textCount);
                    }
                    else
                    {
                        updateCutsceneText (ref outroWinnerDialogue, ref outroWinnerText, ref p1DialogueIndex, ref p1Dialoguing, ref textCount);
                    }
                }
                else if (p2Dialoguing)
                {
                    if (!matchOver)
                    {
                        updateCutsceneText (ref introP2Dialogue, ref introPlayerText, ref p2DialogueIndex, ref p2Dialoguing, ref textCount);
                    }
                    else
                    {
                        updateCutsceneText (ref outroWinnerDialogue, ref outroWinnerText, ref p2DialogueIndex, ref p2Dialoguing, ref textCount);
                    }
                }
            }

            if (!MatchIsOver && Input.GetKey (P1Cancel) || Input.GetKey (P2Cancel) || Input.GetKey (P1Pause) || Input.GetKey (P2Pause))
            {
                print (@"KEY:ENDCUTSCENE");

                if (!MatchIsOver)
                {
                    beginMatch ();
                }
            }

            if (MatchIsOver && inputDelay < 0.0f)
            {
                if (Input.GetKey (UserDown))
                {
                    if (endGameIndex < 3)
                    {
                        inputDelay = MAXDELAYBETWEENINPUTS;
                        selectSFX.Play ();
                        endGameIndex++;
                        endgameSelectBox.transform.position = new Vector3(endgameSelectBox.transform.position.x,
                            endgameSelectBox.transform.position.y - endgameSelectBox.rectTransform.sizeDelta.y,
                            endgameSelectBox.transform.position.z);
                    }
                }
                else if (Input.GetKey (UserUp))
                {
                    if (endGameIndex > 0)
                    {
                        inputDelay = MAXDELAYBETWEENINPUTS;
                        selectSFX.Play ();
                        endGameIndex--;
                        endgameSelectBox.transform.position = new Vector3(endgameSelectBox.transform.position.x,
                            endgameSelectBox.transform.position.y + endgameSelectBox.rectTransform.sizeDelta.y,
                            endgameSelectBox.transform.position.z);
                    }
                }
            }

            if (inputDelay < 0.0f && textTimer > 0.0f && (Input.GetKey (P1Confirm) || Input.GetKey (P2Confirm)))
            {
                print (@"KEY:UPDATECUTSCENE");

                if (!MatchIsOver)
                {
                    updateIntroCutscene (battleMap.Team1[0], battleMap.Team2[0], 1);
                }
                else
                {
                    selectSFX.Play ();

                    if (endGameIndex == 0)
                    {
                        this.enabled = false;
                        turnOutput.Close ();
                        SceneManager.LoadScene (3);
                    }
                    else if (endGameIndex == 1)
                    {
                        selectSFX.Play ();
                        this.enabled = false;
                        turnOutput.Close ();
                        SceneManager.LoadScene (2);
                    }
                    else if (endGameIndex == 2)
                    {
                        selectSFX.Play ();
                        this.enabled = false;
                        turnOutput.Close ();
                        SceneManager.LoadScene (1);
                    }
                    else if (endGameIndex == 3)
                    {
                        selectSFX.Play ();
                        this.enabled = false;
                        turnOutput.Close ();
                        SceneManager.LoadScene (0);
                    }
                }
            }
        }
        else if (matchOverTimer < 0.0f && engageTimer < 0.0f)
        {

            totalMatchTime += Time.deltaTime;

            Player p;

            if (activePlayer != null)
            {
                if (activePlayer.MetersSet && NoRemainingAnimations && !activePlayer.CanAct && skillSet.Count <= 0)
                {
                    endTurn ();
                }

                if ((activePlayer.CanAct || skillSet.Count > 0))
                {
                    highlightTimer += Time.deltaTime;
                }

                if (!activePlayer.StateActive (activePlayer.Invisible) && highlightTimer > 0.2f)
                {
                    highlightTimer = 0.0f;
                    if (playerHighlightIcon.color.Equals (Color.white))
                    {
                        playerHighlightIcon.color = mintGreen;
                    }
                    else
                    {
                        playerHighlightIcon.color = Color.white;
                    }
                }
            }

            //ANIMATIONS
            for (int i = 0; i < battleMap.Roster.Count; i++)
            {
                p = (Player)battleMap.Roster[i];

                updateTeamStats (p);
                setHP(p, true);
                setRM(p, true);
                setGM(p, true);
                setVM(p, true);
                setStun (p, true);
                setXP(p);

                //FLASHING BARS
                checkHP(p);
                checkVM(p);
                checkST(p);

                /**
                playerHealthBar.color = healthBarStandard (activePlayer);
                playerVitalityBar.color = vitalityBarStandardColor;
                playerStunBar.color = stunBarStandardColor;
                */

                p.Health.adjust (5);
                p.Rush.adjust (1);
                p.Guard.adjust (1);
                p.Vitality.adjust (1);
                p.Stun.adjust (1);

                cycleColorAndStatus (p);

                if (p.MyReel.IsPlaying)
                {

                    if (p.MyReel.IsAnimated)
                    {
                        p.MyReel.Framerate += Time.deltaTime;

                    }

                    if (p.MyReel.Framerate > Reel.REELFRAMERATE)
                    {
                        p.MyReel.Framerate = 0.0f;

                        p.MyReel.StepIndex ();




                        if (p.MyReel.Next != null)
                        {

                            p.MyReel = p.MyReel.Next;
                        }
                        p.MyReel.LoadFrame ();
                    }
                }
                else
                {

                }
            }

            //PLAYER'S AURA
            if (playerPowerUpSprite.enabled)
            {
                powerUpReelFrame += Time.deltaTime;
                if (powerUpReelFrame >= POWERUPSPEED)
                {
                    powerUpFrame++;
                    if (powerUpFrame >= playerPowerUpEffects.Count)
                    {
                        powerUpFrame = 0;
                    }
                    playerPowerUpSprite.texture = (Texture2D)playerPowerUpEffects[powerUpFrame];
                    powerUpReelFrame = 0.0f;
                }
            }

            /**
             * 
             *  Only the second most inefficient way to create Unity animations
             * PLAY MAP ANIMATIONS
             * 
             */
            for (int i = 0; i < mapAnimationImage.Count; i++)
            {
                //print ("CHECKING ANIMATION #" + (i + 1) + " OUT OF " + mapAnimationImage.Count);
                ((DynamicFloat)mapAnimationSpeed[i]).BaseValue -= Time.deltaTime;
                if (((DynamicFloat)mapAnimationSpeed[i]).BaseValue < 0.0f)
                {

                    RawImage holder = ((RawImage)mapAnimationImage[i]);

                    ((DynamicFloat)mapAnimationSpeed[i]).BaseValue = POWERUPSPEED;

                    if (holder != null && !holder.IsDestroyed ())
                    {
                        //print ("NAHT null animation");
                        holder.enabled = true;

                        holder.transform.SetAsLastSibling ();
                        ((RawImage)mapAnimationImage[i]).transform.position = (Vector3)mapAnimationPosition[i];

                        //((RawImage)mapAnimationImage [i]).GetComponent <RectTransform> ().sizeDelta = new Vector2 (((Vector3)mapAnimationSize [i]).x, ((Vector3)mapAnimationSize [i]).y);

                        if (((DynamicInt)mapAnimationIndex[i]).BaseValue
                            < ((Texture2D[])mapAnimations[i]).Length)
                        {

                            //print ("ANIMATION RUNNING " + (((DynamicInt)mapAnimationIndex [i])).BaseValue);
                            holder.texture = (Texture2D)((Texture2D[])mapAnimations[i])[(((DynamicInt)mapAnimationIndex[i])).BaseValue];
                            (((DynamicInt)mapAnimationIndex[i])).BaseValue++;

                        }
                        else
                        {

                            //METHOD 1 (DESTROY)


                            print ("Destroying " + holder.gameObject.name);


                            mapAnimationImage.RemoveAt (i);
                            Destroy (holder.gameObject);


                            //METHOD 1 ENABLE/DISABLE
                            /**
                            ((RawImage)mapAnimationImage [0]).enabled = false;
                            mapAnimationImage.RemoveAt (0);
                            */

                            mapAnimations.RemoveAt (i);
                            mapAnimationIndex.RemoveAt (i);
                            mapIndexLimits.RemoveAt (i);
                            mapAnimationSpeed.RemoveAt (i);
                            mapAnimationSize.RemoveAt (i);
                            mapAnimationPosition.RemoveAt (i);
                            if (holderObjects.Count > 0)
                            {
                                holderObjects.RemoveAt (i);
                            }
                            i--;
                        }
                    }
                    else
                    {
                        //print ("Null animation");

                        mapAnimationImage.RemoveAt (i);
                        mapAnimations.RemoveAt (i);
                        mapAnimationIndex.RemoveAt (i);
                        mapIndexLimits.RemoveAt (i);
                        mapAnimationSpeed.RemoveAt (i);
                        mapAnimationSize.RemoveAt (i);
                        mapAnimationPosition.RemoveAt (i);
                        if (holderObjects.Count > 0)
                        {
                            holderObjects.RemoveAt (i);
                        }
                        i--;
                    }
                }
            }

            //CURRENT PLAYER ANIMATION
            if (playerReel.Count > 0)
            {
                playerFrame += Time.deltaTime;
                if (playerFrame >= PLAYERFRAMERATE)
                {
                    //ANIMATION INDEX
                    playerSpriteIndex++;
                    if (playerSpriteIndex >= playerReel.Count)
                    {
                        playerSpriteIndex = 0;
                    }
                    playerSprite.texture = (Texture2D)playerReel[playerSpriteIndex];
                    playerFrame = PLAYERFRAMERATE;
                }
            }
            //TARGET 1 ANIMATION
            if (targetSprite1.enabled)
            {
                targetFrame1 += Time.deltaTime;
                if (targetFrame1 >= TARGETFRAMERATE)
                {
                    //TARGET INDEX
                    targetSpriteIndex1++;
                    if (targetSpriteIndex1 >= targetReel1.Count)
                    {
                        targetSpriteIndex1 = 0;
                    }
                    targetSprite1.texture = (Texture2D)targetReel1[targetSpriteIndex1];
                    if (playerTargets[0] != null)
                    {

                        targetSprite1.GetComponent<RectTransform>().sizeDelta = new Vector2(targetSprite1.texture.width / SPRITESCALERATIO, targetSprite1.texture.height / SPRITESCALERATIO);

                    }
                    targetFrame1 = 0.0f;
                }
            }
            //TARGET 2 ANIMATION
            if (targetSprite2.enabled)
            {
                targetFrame2 += Time.deltaTime;
                if (targetFrame2 >= TARGETFRAMERATE)
                {
                    //TARGET INDEX
                    targetSpriteIndex2++;
                    if (targetSpriteIndex2 >= targetReel2.Count)
                    {
                        targetSpriteIndex2 = 0;
                    }
                    targetSprite2.texture = (Texture2D)targetReel2[targetSpriteIndex2];
                    if (playerTargets[1] != null)
                    {

                        targetSprite2.GetComponent<RectTransform>().sizeDelta = new Vector2(targetSprite2.texture.width / SPRITESCALERATIO, targetSprite2.texture.height / SPRITESCALERATIO);

                    }
                    targetFrame2 = 0.0f;
                }
            }
            //TARGET 3 ANIMATION
            if (targetSprite3.enabled)
            {
                targetFrame3 += Time.deltaTime;
                if (targetFrame3 >= TARGETFRAMERATE)
                {
                    //TARGET INDEX
                    targetSpriteIndex3++;
                    if (targetSpriteIndex3 >= targetReel3.Count)
                    {
                        targetSpriteIndex3 = 0;
                    }
                    targetSprite3.texture = (Texture2D)targetReel3[targetSpriteIndex3];
                    if (playerTargets[2] != null)
                    {

                        targetSprite3.GetComponent<RectTransform>().sizeDelta = new Vector2(targetSprite3.texture.width / SPRITESCALERATIO, targetSprite3.texture.height / SPRITESCALERATIO);

                    }
                    targetFrame3 = 0.0f;
                }
            }
            //TARGET 4 ANIMATION
            if (targetSprite4.enabled)
            {
                targetFrame4 += Time.deltaTime;
                if (targetFrame4 >= TARGETFRAMERATE)
                {
                    //TARGET INDEX
                    targetSpriteIndex4++;
                    if (targetSpriteIndex4 >= targetReel4.Count)
                    {
                        targetSpriteIndex4 = 0;
                    }
                    targetSprite4.texture = (Texture2D)targetReel4[targetSpriteIndex4];
                    if (playerTargets[3] != null)
                    {

                        targetSprite4.GetComponent<RectTransform>().sizeDelta = new Vector2(targetSprite4.texture.width / SPRITESCALERATIO, targetSprite4.texture.height / SPRITESCALERATIO);

                    }
                    targetFrame4 = 0.0f;
                }
            }

            //DEBUG TO CLEAR ANY AND ALL INPUTS INPUT ISSUES
            if (Input.GetKey (KeyCode.F15))
            {
                print (@"KEY:CLEARLOG");
                clearNotifications ();
            }

            //PAUSE SCREEN
            if (pauseMenu.enabled)
            {
                if (confirmMenu.enabled)
                {
                    if (menuInputDelay < 0.0f)
                    {
                        if (Input.GetKey (UserBack) && !willExit)
                        {
                            print (@"KEY:LEFT");
                            menuInputDelay = MENUINPUTMAXVALUE;
                            cursorSFX.Play ();
                            yesText.color = highlightAvailableColor;
                            noText.color = nonHighlightAvailableColor;
                            willExit = true;
                        }
                        else if (Input.GetKey (UserForward) && willExit)
                        {
                            print (@"KEY:RIGHT");
                            menuInputDelay = MENUINPUTMAXVALUE;
                            cursorSFX.Play ();
                            yesText.color = nonHighlightAvailableColor;
                            noText.color = highlightAvailableColor;
                            willExit = false;
                        }
                        else if (Input.GetKey (UserConfirm))
                        {
                            print (@"KEY:CONFIRM");
                            menuInputDelay = MENUINPUTMAXVALUE;
                            if (willExit)
                            {
                                if (pauseOptions[1])
                                {
                                    selectSFX.Play ();
                                    this.enabled = false;
                                    SceneManager.LoadScene (2);
                                }
                                else if (pauseOptions[2])
                                {
                                    selectSFX.Play ();
                                    this.enabled = false;
                                    SceneManager.LoadScene (1);
                                }
                                else if (pauseOptions[3])
                                {
                                    selectSFX.Play ();
                                    this.enabled = false;
                                    SceneManager.LoadScene (0);
                                }
                            }
                            else
                            {
                                selectSFX.Play ();
                                setConfirmMenu (false);
                                setPauseMenu (true);
                            }
                        }
                    }
                }
                else
                {
                    if (menuInputDelay < 0.0f)
                    {
                        if (Input.GetKey (UserDown))
                        {
                            cursorSFX.Play ();
                            menuInputDelay = MENUINPUTMAXVALUE;
                            print (@"KEY:MENUDOWN");

                            if (pauseOptions[0])
                            {
                                pauseOptions[0] = false;
                                pauseOptions[1] = true;
                                continueText.color = nonHighlightAvailableColor;
                                stageSelectText.color = highlightAvailableColor;
                            }
                            else if (pauseOptions[1])
                            {
                                pauseOptions[1] = false;
                                pauseOptions[2] = true;
                                stageSelectText.color = nonHighlightAvailableColor;
                                playerSelectText.color = highlightAvailableColor;
                            }
                            else if (pauseOptions[2])
                            {
                                pauseOptions[2] = false;
                                pauseOptions[3] = true;
                                playerSelectText.color = nonHighlightAvailableColor;
                                quitText.color = highlightAvailableColor;
                            }
                        }
                        else if (Input.GetKey (UserUp))
                        {
                            cursorSFX.Play ();
                            menuInputDelay = MENUINPUTMAXVALUE;
                            print (@"KEY:MENUUP");

                            if (pauseOptions[3])
                            {
                                pauseOptions[3] = false;
                                pauseOptions[2] = true;
                                quitText.color = nonHighlightAvailableColor;
                                playerSelectText.color = highlightAvailableColor;
                            }
                            else if (pauseOptions[2])
                            {
                                pauseOptions[2] = false;
                                pauseOptions[1] = true;
                                playerSelectText.color = nonHighlightAvailableColor;
                                stageSelectText.color = highlightAvailableColor;
                            }
                            else if (pauseOptions[1])
                            {
                                pauseOptions[1] = false;
                                pauseOptions[0] = true;
                                stageSelectText.color = nonHighlightAvailableColor;
                                continueText.color = highlightAvailableColor;
                            }

                        }
                        else if (Input.GetKey (UserConfirm))
                        {
                            selectSFX.Play ();
                            print (@"KEY:MENUCONFIRM");

                            //CONTINUE MATCH
                            if (pauseOptions[0])
                            {
                                menuInputDelay = MENUINPUTMAXVALUE;
                                setPauseMenu (false);

                            }
                            else if (pauseOptions[1])
                            {
                                menuInputDelay = MENUINPUTMAXVALUE;
                                setConfirmMenu (true);
                            }
                            else if (pauseOptions[2])
                            {
                                menuInputDelay = MENUINPUTMAXVALUE;
                                setConfirmMenu (true);
                            }
                            else if (pauseOptions[3])
                            {
                                menuInputDelay = MENUINPUTMAXVALUE;
                                setConfirmMenu (true);
                            }
                        }
                    }
                }
            }

            //ACTIVE MAP ACTIONS / NOT PAUSE SCREEN
            ///INDEPENDENT TIME FUNCTIONS THAT ARE NOT ALTERED BY PAUSING, SUCH AS FLASHING HEALTH, VITALITY, AND STUN BARS,
            /// AND THE SPEECH BUBBLE
            else
            {

                //Player motions
                bool posX, posY;

                for (int i = 0; i < battleMap.Roster.Count; i++)
                {

                    p = (Player)battleMap.Roster[i];

                    if (p.PaceCancelCooldownTimer > 0) {
                        p.PaceCancelCooldownTimer -= Time.deltaTime;
                    }

                    if (p.CurrentAnimationTime > 0f)
                    {
                        p.CurrentAnimationTime -= Time.deltaTime;

                        if (p.CurrentAnimationTime <= 0f)
                        {
                            setNextPlayerAnimation (p);
                        }
                    }

                    /**
                     * 
                     * Checks if movement increment Vector3 is null
                     * 
                     */
                    if (p.MovementIncrement != null)
                    {

                        //print ("DISPLAYING CHARACTER MOTION! " + p.SearchName + " " + p.MapSprite.transform.position);

                        posX = p.MapSprite.transform.position.x >= p.Destination.x;
                        posY = p.MapSprite.transform.position.y >= p.Destination.y;

                        print ("Moving " + p.Name + " towards " + p.Destination.ToString () + " with " + p.MapSprite.texture.name);

                        p.MapSprite.transform.position =
                            new Vector3(p.MapSprite.transform.position.x + p.MovementIncrement.A,
                                p.MapSprite.transform.position.y + p.MovementIncrement.B,
                                0);
                        p.ShadowSprite.transform.position =
                            new Vector3(p.MapSprite.transform.position.x + p.MovementIncrement.A,
                                p.MapSprite.transform.position.y + p.MovementIncrement.B,
                                0);
                        p.HealthBar.color = Color.clear;
                        p.HealthBarBackground.color = Color.clear;
                        //p.StatusIcon.color = Color.clear;

                        //print (p.FirstName + "CHANGING MAP SPRITE POSITION TO " + p.MapSprite.transform.position
                        //  + ": " + p.MovementIncrement.A + " " + p.MovementIncrement.B);

                        if (p == activePlayer)
                        {
                            playerHighlightIcon.transform.SetParent (p.MapSprite.transform);
                            playerHighlightIcon.transform.position =
                                new Vector3(0, -20, 0);

                            if (p.StateActive (p.Invisible))
                            {
                                playerHighlightIcon.color = Color.clear;
                                p.HealthBarBackground.color = Color.clear;
                                p.ShadowSprite.color = Color.clear;
                                p.StatusIcon.color = Color.clear;
                            }
                        }

                        if (((p.MovementIncrement.A != 0 && (Math.Abs (p.MapSprite.transform.position.x - p.Destination.x) <= Math.Abs (p.MovementIncrement.A)))
                            || (p.MovementIncrement.B != 0 && Math.Abs (p.MapSprite.transform.position.y - p.Destination.y) <= Math.Abs (p.MovementIncrement.B)))
                            || (Math.Abs (p.MovementIncrement.A) < 0.0010f && Math.Abs (p.MovementIncrement.B) < 0.0010f))
                        {
                            print (p.FirstName + " DESTINATION REACHED!");
                            p.MapSprite.transform.position = p.Destination;
                            p.ShadowSprite.transform.position = p.Destination;

                            p.Destination = new Vector3(-30, -30, -0);
                            p.MovementIncrement = null;

                            if (p.MovementIncrements.Count == 0)
                            {
                                //CHECK
                                clearAnimations (p);
                                print (p.FirstName.ToUpper () + " CLEARING REMAINING ANIMATIONS");
                                displayMapPlayerGraphics (p, p.Row, p.Column);
                                //if (p.CurrentAnimationTime == -5.0f) {
                                //  setNextPlayerAnimation (p);
                                //}

                                if (NoRemainingAnimations)
                                {
                                    updateMap ();

                                    northArrow.enabled = true;
                                    southArrow.enabled = true;
                                    eastArrow.enabled = true;
                                    westArrow.enabled = true;

                                }
                                else
                                {
                                    //  print ("STILL SOME MOTIONS TO GO!");
                                }
                            }
                            if (!p.StateActive (p.Airborne) && !p.StateActive (p.Grounded))
                            {
                                walkSFX.Play ();
                            }
                        }
                    }

                    if (p.MovementIncrement == null && p.Destinations.Count > 0)
                    {

                        print (p.FirstName.ToUpper () + ": Adding position to " + p.Destination + " \t" + ": " + (p.Destinations.Count + 1) + " animations remaining");

                        p.Destination = (Vector3)p.Destinations[0];

                        p.MovementIncrement = (MapVector)p.MovementIncrements[0];

                        p.MovementIncrement = new MapVector (((p.MapSprite.transform.position.x - p.Destination.x) / ((float)p.MovementIncrement.DivRatio)) * -1,
                            ((p.MapSprite.transform.position.y - p.Destination.y) / ((float)p.MovementIncrement.DivRatio)) * -1, p.MovementIncrement.DivRatio);

                        northArrow.enabled = false;
                        southArrow.enabled = false;
                        eastArrow.enabled = false;
                        westArrow.enabled = false;

                        p.Destinations.RemoveAt (0);
                        p.MovementIncrements.RemoveAt (0);
                        p.OriginalPositions.RemoveAt (0);

                        if (p.MovementIncrement.A == 0 && p.MovementIncrement.B == 0)
                        {
                            p.Destination = new Vector3(-30, -30, 0);
                            p.MovementIncrement = null;

                            if (p.CurrentAnimationTimes.Count > 0 && (float)p.CurrentAnimationTimes[0] == -5.0f)
                            {
                                setNextPlayerAnimation (p);
                            }
                        }
                        else
                        {
                            updateMap ();
                        }
                        //print ("THERE! MOVEMENT!");
                    }
                    else if (p.MovementIncrement != null && p.Destinations.Count > 0)
                    {
                        print (p.FirstName.ToUpper () + " GOT FUK'D UP");
                    }
                }

                //PACE CANCEL
                if (Input.GetKey (UserPaceCancelButton)) {

                    if (menuInputDelay < 0
                    && activePlayer != null
                    && activePlayer.CanCancelSkill
                    && activePlayer.PaceCancelCooldownTimer < 0
                    && finishTime > 0
                    && ((activePlayer.Vitality.MeterLevel >= 200 && Math.Abs (finishTimeMax - finishTime) <= 0.4f) || (activePlayer.Vitality.MeterLevel >= 300)))
                    {
                        /**
                        print(@"KEY:PACECANCEL");
                        menuInputDelay = MENUINPUTMAXVALUE * 2;


                        skillSet = activePlayer.CancelSkills;
                        skill = (Skill)activePlayer.CancelSkills[0];
                        skillLocation = activePlayer.currentLocation();
                        setSkillLocations();

                        currentSkillInput.enabled = true;
                        currentSkillInput.texture = ProperInput(skill);

                        updateMap(activePlayer);
                        updateActivePlayer();
                        updatePlayerInfo();
                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                        */
                        print(@"KEY:PACECANCEL");
                        menuInputDelay = MENUINPUTMAXVALUE;
                        activePlayer.PaceCancelCooldownTimer = 1.0f;
                        activePlayer.LongestCombo.Add ("...");

                        cursorSFX.Play();

                        /**
                        if (!NoRemainingAnimations)
                        {
                            clearAnimations();
                        }
                        */
                        activePlayer.CancelSkill.Used = false;
                        activePlayer.CancelSkill.UsedNow = false;

                        skill = null;
                        skillSet = new ArrayList ();
                        skillLocation = activePlayer.currentLocation ();

                        addToBattleLog (executeSkill (activePlayer, activePlayer.CancelSkill, activePlayer.currentLocation (), @"X", true, true, false, activePlayer.CurrentProration), false);

                        updateMap(activePlayer);
                        updateActivePlayer();
                        updatePlayerInfo();
                        determineSpecificSprite(activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                        determineAnimation();
                        return;

                    } else {
                        if (!activePlayer.CanCancelSkill)
                        {
                            print(@"KEY:PACECANCELISNULL");
                        }
                        else if (finishTime <= 0)
                        {
                            print(@"KEY:PACECANCELFINISHTIME");
                        }
                        else if (!activePlayer.CancelSkill.CostsAndConditionsMet)
                        {
                            print(@"KEY:PACECANCELFINISHTIME");
                        }
                        else
                        {
                            print(@"KEY:PACECANCELNAH");
                        }


                    }

                }
                if ((Input.GetKey (UserConfirm) || Input.GetKey (UserAction)) && (menuInputDelay < 0.0f)
                    && skillSet.Count == 0 && skill == null)
                {

                    menuInputDelay = MENUINPUTMAXVALUE * 2;

                    if (PlayerInMotion)
                    {
                        clearAnimations (activePlayer);
                    }


                    if (!NoRemainingAnimations)
                    {
                        //clearDialogues ();
                        //clearNotifications ();
                        clearAnimations ();
                    }

                    else if (passiveTime > 0)
                    {
                        //passiveTime = 0.01f;
                    }
                    else if (endPlayerTimer > 0)
                    {
                        //print ("CONFIRMING NEW PLAYER NOW! 1");
                        //setNewActivePlayer ((Player)battleMap.Roster [battleMap.Index], true);
                    }
                }

                //TOGGLE USER INFO/VISUAL
                if (menuInputDelay < 0.0f && Input.GetKey (UserInfo))
                {
                    print (@"KEY:INFO");
                    if (activePlayer != null && (activePlayer.CanAct || skill != null))
                    {

                        cursorSFX.Play ();
                        menuInputDelay = MENUINPUTMAXVALUE;

                        playerInfoToggled = !playerInfoToggled;
                        if (playerInfoToggled)
                        {
                            focusCamera (null);
                        }
                        else
                        {
                            focusCamera (activePlayer);
                        }

                        updatePlayerInfo ();
                    }
                }

                Player plyr;

                for (int i = 0; i < battleMap.Roster.Count; i++)
                {
                    plyr = (Player)battleMap.Roster[i];

                    //SKILL OCCUPIED
                    if (NoRemainingAnimations && plyr.PlayerOutputIndexes.Count > 0)
                    {

                        skillOutputDelay -= Time.deltaTime;

                        if (skillOutputDelay < 0.0f)
                        {

                            //print ("SLOT 1 NOT OCCUPIED");

                            inactivityTime = 0.0f;
                            addNotification (plyr, soundQueue);

                        }
                    }
                }

                for (int i = 0; i < notificationTexts.Count; i++)
                {

                    //print (((Notification)notificationTexts [i]).Info.text + " " + ((Notification)notificationTexts [i]).Timer);

                    updateNotifications (i);

                    if (((Notification)notificationTexts[i]).Info.text == "DELETE")
                    {

                        Notification txt = (Notification)notificationTexts[i];

                        notificationTexts.RemoveAt (i);

                        Destroy (txt.Info);

                        i--;
                    }

                }

                //SPEECH BUBBLES
                for (int i = 0; i < battleMap.Roster.Count; i++)
                {
                    p = (Player)battleMap.Roster[i];
                    if (p.Vocals.SpeechCountdown > 0.0f)
                    {
                        p.Vocals.SpeechCountdown -= Time.deltaTime;
                        if (p.Vocals.SpeechCountdown <= 0.0f)
                        {
                            if (p.Vocals.Dialogue.Count > 0)
                            {
                                stepDialogue (p, (string)p.Vocals.Dialogue[0]);
                                p.Vocals.Dialogue.RemoveAt (0);
                                p.Emotions.RemoveAt (0);
                            }
                            else
                            {
                                p.Vocals.Clear ();
                            }
                        }
                    }
                }


                checkSoundQueue ();

                //PAUSING AND SOUND MENU
                if (Input.GetKey (UserPause))
                {
                    print (@"KEY:PAUSE");
                    menuInputDelay = MENUINPUTMAXVALUE;
                    setPauseMenu (true);
                    pauseMenu.transform.SetAsLastSibling ();
                    pauseMenuArt.transform.SetAsLastSibling ();
                    confirmMenu.transform.SetAsLastSibling ();
                    pauseMenuArt.transform.SetAsLastSibling ();

                }
                else if (menuInputDelay < 0.0f && Input.GetKey (KeyCode.M))
                {
                    print (@"KEY:TOGGLEMUSIC");
                    menuInputDelay = MENUINPUTMAXVALUE;
                    if (bgm.isPlaying)
                    {
                        bgm.Pause ();
                    }
                    else
                    {
                        playBGM();
                    }
                }
                else if (Input.GetKey (KeyCode.F14))
                {
                    print (@"KEY:TOGGLESOUND");
                    //THIS KEY IS FOR WALKER, TEXAS RANGER
                    for (int i = 0; i < FindObjectsOfType<AudioSource>().Length; i++)
                    {
                        FindObjectsOfType<AudioSource>()[i].volume = -0.5f;

                    }

                }
                else if (menuInputDelay < 0.0f && Input.GetKey (KeyCode.K))
                {
                    print (@"KEY:TOGGLEAMBIENCE");
                    menuInputDelay = MENUINPUTMAXVALUE;
                    if (ambience.isPlaying)
                    {
                        ambience.Pause ();
                    }
                    else
                    {
                        ambience.Play ();
                    }
                }
                else
                {

                    //TIME STEP

                    if (activePlayer == null)
                    {

                        passiveTime -= Time.deltaTime;
                        showActiveAndPassiveStatus ();

                        if (passiveTime <= 0.0f)
                        {

                            battleMap.Index = 0;

                            print ("BEGIN MATCH!");
                            setNewActivePlayer ((Player)battleMap.Roster[battleMap.Index], true);
                        }

                    }
                    else if (activePlayer != null && !activePlayer.CanAct && skillSet.Count == 0 && skill == null && NoRemainingAnimations && activePlayer.MetersSet && NoRemainingNotifications)
                    {
                        endPlayerTimer -= Time.deltaTime;

                        showActiveAndPassiveStatus ();

                        if (endPlayerTimer <= 0.0f)
                        {

                            if (passiveTime <= 0)
                            {

                                setNewActivePlayer ((Player)battleMap.Roster[battleMap.Index], true);
                                return;
                            }
                        }
                        else if (Input.GetKey (UserConfirm) && inputDelay <= 0.0f && menuInputDelay <= 0.0f)
                        {
                            menuInputDelay = MENUINPUTMAXVALUE;

                            if (!NoRemainingAnimations)
                            {
                                clearAnimations ();
                            }

                            if (passiveTime <= 0)
                            {

                                setNewActivePlayer ((Player)battleMap.Roster[battleMap.Index], true);
                                return;
                            }
                        }
                    }

                    //ADD AP METER HERE
                    if (!firstMoveActivated
                        && activePlayer != null)
                    {

                        if (passiveTime > 0.0f && !activePlayer.KOd && activePlayer.InPlay)
                        {
                            passiveTime -= Time.deltaTime;

                            showActiveAndPassiveStatus ();

                            if (passiveTime < 0.0f)
                            {
                                if (activePlayer != null)
                                {

                                    startActiveTime ();
                                }
                            }

                        }
                    }

                    //ACTIVE TIME
                    if (firstMoveActivated &&
                        !readingUserCommands &&
                        //
                        battleMap.ActiveTime > 0.0f && (activePlayer != null && activePlayer.CanAct))
                    {

                        //STOPPAGE
                        if (!activePlayer.TimeStopped && !activePlayer.KOd)
                        {

                            //TURN BACK ON

                            if (!trainingMode && NoRemainingAnimations && !PlayerInMotion)
                            {
                                battleMap.ActiveTime -= Time.deltaTime;
                            }

                            setStepTime ((float)0.5f);
                            //setStepTimeMeter ();

                        }

                        //ADD STEPPING HERE


                        if (battleMap.ActiveTime <= 3)
                        {
                            if (!timerSFX.isPlaying)
                            {
                                timerSFX.Play ();
                            }
                        }

                        setActiveTimeMeter ();

                        //END ACTIVE TIME
                        if (battleMap.ActiveTime < 0.0f)
                        {
                            announce ("roundover");
                            stepTime = -0.01f;

                            //activePlayer.Fatigue += 3;

                            addToBattleLog ("Player turn ends due to inaction!" + '\n', false);
                            setSkill (null, -1, null);
                            skillLocation = null;
                            skillSet = new ArrayList ();
                            endTime = -1.0f;
                            battleMap.ActiveTime = -1.0f;
                            passiveTime = -1.0f;
                            finishTime = -1.0f;

                            timerSFX.Stop ();

                            addToBattleLog (activePlayer.setAction (false), false);
                            activePlayer.HasActed = true;
                            finishTimeMax = -5.0f;
                            updateActivePlayer ();
                            updateMap (activePlayer);
                            updatePlayerInfo ();
                            determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                            determineAnimation ();
                        }
                    }
                    else if (finishTime > 0.0f && !activePlayer.CanAct && (skill == null || !skill.Properties.Contains (" INPUT ")))
                    {

                        //TURN BACK ON
                        finishTime -= Time.deltaTime;

                        setStepTime (0.35f);
                        //setStepTimeMeter ();

                        setFinishTimeMeter ();

                        //END TURN
                        if (finishTime <= 0)
                        {
                            inputPressed = false;
                            delayBetweenInputs = 0.0f;
                            battleMap.ActiveTime = -1.0f;
                            inputImages.Clear ();
                            inputPrompt.texture = null;
                            inputPrompt.enabled = false;
                            announce ("roundover");
                            //failSFX.Play ();
                            confirmSFX.Stop ();

                            //activePlayer.Fatigue += 3;


                            inputDelay = INPUTMAXVALUE;

                            correctInputs.Clear ();
                            playerInputs.Clear ();

                            if (skill != null)
                            {

                                //METER COST

                                if (skill.Cost[0] != 0)
                                {
                                    addToBattleLog (shiftHealth (activePlayer, skill.Cost[0] / 2, false, null, skill), false);
                                }
                                if (skill.Cost[1] != 0 && !activePlayer.StateActive (activePlayer.Fury))
                                {
                                    addToBattleLog (shiftRush (activePlayer, skill.Cost[1] / 2, false, null), false);
                                }
                                if (skill.Cost[2] != 0)
                                {
                                    addToBattleLog (shiftGuard (activePlayer, skill.Cost[2] / 2, false, null), false);
                                }
                                if (skill.Cost[3] != 0)
                                {
                                    addToBattleLog (shiftVitality (activePlayer, skill.Cost[3] / 2, false, null), false);
                                }
                            }
                            inputSuccess = true;
                            setSkill (null, -1, null);
                            skillSet = new ArrayList ();
                            skillLocation = null;
                            currentSkillInput.enabled = false;
                            addToBattleLog (activePlayer.setAction (false), false);
                            activePlayer.HasActed = true;
                            activePlayer.HasJumped = true;
                            activePlayer.MovesRemaining = 0;
                            updateMap (activePlayer);
                            updateActivePlayer ();
                            updatePlayerInfo ();
                            determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                            determineAnimation ();
                        }

                    }
                    else
                    {
                        activeTimeMeter.color = Color.grey;

                    }

                    if (inputDelay < 0.0f)
                    {
                        if (readingUserCommands)
                        {

                            if (skillInputDelay > 0.0f)
                            {
                                skillInputDelay -= Time.deltaTime;
                            }

                            if (inputPressed)
                            {
                                delayBetweenInputs += Time.deltaTime;
                            }

                            if (correctInputs == null)
                            {
                                throw new ArgumentNullException ("WOW DUDE");
                            }

                            if (activePlayer != null)
                            {
                                if (delayBetweenInputs < (MAXDELAYBETWEENINPUTS + (activePlayer.Dexterity / 100)) && skillInputDelay <= 0.0f && correctInputs != null && (skill != null && skill.Inputs.Length > 0) && correctInputs.Count > 0)
                                {
                                    //INPT READER/READING FOR SPECIFIC INPUT MODE, for reading inputs
                                    //Checks  if the correct input is a KeyCode or cluster of KeyCodes
                                    if (correctInputs[playerInputs.Count].GetType ().Name.Equals ("KeyCode"))
                                    {
                                        if (
                                            //(skill.Inputs [0].Contains ("Charge")) && 
                                            Input.GetKey ((KeyCode)correctInputs[playerInputs.Count]))
                                        {
                                            inputPressed = true;
                                            delayBetweenInputs = 0.0f;
                                            playerInputs.Add (1);
                                            skillInputDelay = INPUTRESETTIMER;
                                            confirmSFX.Play ();
                                            failSFX.Stop ();

                                            //print (Math.Abs (skillInputDelay + inputDelay) + " " + " are the lag/delay stats");

                                            inputImages.RemoveAt (0);
                                            if (inputImages.Count > 0)
                                            {
                                                inputPrompt.texture = (Texture)inputImages[0];
                                                inputPrompt.transform.SetAsLastSibling ();
                                            }
                                            else
                                            {
                                                inputPrompt.enabled = false;
                                            }

                                        }
                                        else if (Input.anyKey)
                                        {
                                            //print ("NAHT CORRECT INPUT");
                                            //skillInputDelay = INPUTRESETTIMER;
                                        }
                                    }
                                    else
                                    {
                                        if (Input.anyKeyDown)
                                        {
                                            Boolean inputsCorrect = false;
                                            for (int i = 0; i < ((ArrayList)correctInputs[playerInputs.Count]).Count; i++)
                                            {
                                                if (Input.GetKey ((KeyCode)((ArrayList)correctInputs[playerInputs.Count])[i]))
                                                {
                                                    inputsCorrect = true;
                                                    inputPressed = true;
                                                }
                                                else
                                                {
                                                    inputsCorrect = false;
                                                    break;
                                                }
                                            }
                                            if (inputsCorrect)
                                            {
                                                inputPressed = false;
                                                delayBetweenInputs = 0.0f;
                                                playerInputs.Add (1);
                                                skillInputDelay = INPUTRESETTIMER;
                                                confirmSFX.Play ();
                                                failSFX.Stop ();

                                                inputImages.RemoveAt (0);
                                                if (inputImages.Count > 0)
                                                {
                                                    inputPrompt.texture = (Texture)inputImages[0];
                                                    inputPrompt.transform.SetAsLastSibling ();
                                                }
                                                else
                                                {
                                                    inputPrompt.enabled = false;
                                                }
                                            }
                                        }
                                    }

                                    if (correctInputs.Count.Equals (playerInputs.Count) && skillLocation != null)
                                    {
                                        correctInputs.Clear ();
                                        playerInputs.Clear ();

                                        inputPressed = true;
                                        confirmSFX.Play ();
                                        failSFX.Stop ();
                                        inputDelay = INPUTMAXVALUE;
                                        delayBetweenInputs = 0.0f;
                                        inputSuccess = true;
                                        readingUserCommands = false;
                                        fullInputPrompt.enabled = false;

                                        inputImages.Clear ();
                                        inputPrompt.texture = null;
                                        inputPrompt.enabled = false;

                                        executeSkill ();
                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        determineAnimation ();
                                    }
                                }
                                else if (skill != null && (correctInputs != null && correctInputs.Count > 0)
                                  && delayBetweenInputs > (MAXDELAYBETWEENINPUTS + (activePlayer.Dexterity / 100)))
                                {

                                    if (activePlayer.CurrentProration > 0.20)
                                    {
                                        activePlayer.CurrentProration -= 0.20;
                                    }
                                    if (skill.Recovery > 1)
                                    {
                                        activePlayer.AddFatigue (skill.Recovery / 2);
                                    }
                                    else if (skill.Recovery == 1)
                                    {
                                        activePlayer.AddFatigue (skill.Recovery);
                                    }
                                    inputPressed = false;
                                    failSFX.Play ();
                                    confirmSFX.Stop ();
                                    delayBetweenInputs = 0.0f;
                                    playerInputs = new ArrayList ();
                                    setInputImages ();
                                }
                            }

                            //END TIMER/ TIMESTOP 
                            if (endTime > 0.0f && activePlayer != null && activePlayer.CanAct)
                            {

                                endTime -= Time.deltaTime;
                                upEndTime += Time.deltaTime;

                                if (upEndTime >= 0.5f)
                                {
                                    stepSFX.clip = beepSound;
                                    stepSFX.Play ();
                                    addToBattleLog (WaitSpecial, false);
                                    updateMap (activePlayer);
                                    updateActivePlayer ();
                                    determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                    determineAnimation ();
                                    upEndTime = 0.0f;
                                }

                                if (endTime <= 0.0f)
                                {
                                    upEndTime = -1.0f;
                                    timeText.text = "END";
                                }
                            }
                            else if (Input.GetKey (UserCancel))
                            {
                                print (@"KEY:CANCEL");
                                inputDelay = INPUTMAXVALUE;

                                if (activePlayer != null && !activePlayer.CanAct)
                                {
                                    setSkill (null, -1, null);
                                    skillSet = new ArrayList ();

                                    //endTurn ();
                                }


                                if (skill != null)
                                {
                                    activePlayer.ChainSkills = new ArrayList ();
                                    activePlayer.BurstFollowUpSkills = new ArrayList ();


                                    if (!readingSkillInputs)
                                    {
                                        currentSkillInput.enabled = false;
                                    }

                                    inputImages.Clear ();
                                    inputPrompt.texture = null;
                                    inputPrompt.enabled = false;

                                    inputSuccess = true;
                                    readingUserCommands = false;
                                    fullInputPrompt.enabled = false;

                                    for (int j = 0; j < battleMap.Roster.Count; j++)
                                    {
                                        setCanvas (((Player)battleMap.Roster[j]).InfoFrame, false);
                                    }
                                }
                                currentSkillInput.enabled = false;

                                if (skill == null && !activePlayer.CanAct)
                                {
                                    timerSFX.Stop ();
                                }
                            }

                        }
                        else if (activePlayer != null && (activePlayer.CanAct || (skillSet.Count > 0)))
                        {

                            Location loc = null;
                            ArrayList list = new ArrayList ();

                            if (Input.GetKey (UserAction) && activePlayer.Cooldown <= 0 && ((skillSet.Count == 0) || ((Skill)skillSet[0]).Properties.Contains ("NOCANCEL ")))
                            {
                                print (@"KEY:ACTION");

                                playerInfoToggled = false;

                                if (!NoRemainingAnimations)
                                {
                                    clearAnimations ();
                                }

                            }


                            ///SHORT SKILLZ
                            /// 
                            /// 
                            if (skillSet.Count > 0 &&
                                (menuInputDelay < 0.0f && inputDelay < 0.0f)//!activePlayer.CanAct
                            )
                            {
                                if (Input.GetKey (User_Alpha1))
                                {
                                    print (@"KEY:SKILL1");
                                    if (skillSet.Count > 0 && ((Skill)skillSet[0]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE;

                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        cursorSFX.Play();


                                        setSkill((Skill)skillSet[0], 0, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }

                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha2))
                                {
                                    print (@"KEY:SKILL2");
                                    if (skillSet.Count > 1 && ((Skill)skillSet[1]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        cursorSFX.Play ();

                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[1], 1, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha3))
                                {
                                    print (@"KEY:SKILL3");
                                    if (skillSet.Count > 2 && ((Skill)skillSet[2]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        cursorSFX.Play ();

                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[2], 2, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha4))
                                {
                                    print (@"KEY:SKILL4");
                                    if (skillSet.Count > 3 && ((Skill)skillSet[3]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        cursorSFX.Play ();

                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[3], 3, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha5))
                                {
                                    print (@"KEY:SKILL5");
                                    if (skillSet.Count > 4 && ((Skill)skillSet[4]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        cursorSFX.Play ();

                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[4], 4, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }


                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha6))
                                {
                                    print (@"KEY:SKILL6");
                                    if (skillSet.Count > 5 && ((Skill)skillSet[5]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        cursorSFX.Play ();

                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[5], 5, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha7))
                                {
                                    print (@"KEY:SKILL7");
                                    if (skillSet.Count > 6 && ((Skill)skillSet[6]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        cursorSFX.Play ();

                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[6], 6, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha8))
                                {
                                    print (@"KEY:SKILL8");
                                    if (skillSet.Count > 7 && ((Skill)skillSet[7]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        cursorSFX.Play ();

                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[7], 7, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha9))
                                {
                                    print (@"KEY:SKILL9");
                                    if (skillSet.Count > 8 && ((Skill)skillSet[8]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        cursorSFX.Play ();

                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[8], 8, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha0))
                                {
                                    print (@"KEY:SKILL10");
                                    if (skillSet.Count > 9 && ((Skill)skillSet[9]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        cursorSFX.Play ();

                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[9], 9, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                            }

                            ///SHORT SKILLZ

                            if ((Input.GetKey (UserNorth) || (Input.GetKey (UserUp) && activePlayer.ManualMode)
                            )
                                && skill != null && activePlayer.LockedOnTarget == null && !skill.Properties.Contains (" FOCUS "))
                            {
                                print (@"KEY:TARGETLOCATIONNORTH");

                                inputDelay = INPUTMAXVALUE;

                                if (!NoRemainingAnimations)
                                {
                                    //clearAnimations ();
                                }

                                if (skill != null && skill.LineSkill)
                                {
                                    if (skillLocation != activePlayer.currentLocation ().North)
                                    {
                                        mapHasChanged = true;
                                    }
                                    skillLocation = activePlayer.currentLocation ().North;

                                }
                                else
                                {
                                    if (skill != null && skillLocation != null)
                                    {
                                        if (skill.locationsContains (skillLocation.North))
                                        {
                                            cursorSFX.Play ();
                                            skillLocation = skillLocation.North;
                                            mapHasChanged = true;
                                        }
                                    }
                                }
                                updateMap (activePlayer);
                                updateActivePlayer ();

                            }
                            else if ((Input.GetKey (UserWest) || (Input.GetKey (UserBack) && activePlayer.ManualMode)
                          )
                                     && skill != null && activePlayer.LockedOnTarget == null && !skill.Properties.Contains (" FOCUS "))
                            {
                                print (@"KEY:TARGETLOCATIONWEST");
                                inputDelay = INPUTMAXVALUE;

                                if (!NoRemainingAnimations)
                                {
                                    //clearAnimations ();
                                }

                                if (skill != null && skill.LineSkill)
                                {
                                    if (skillLocation != activePlayer.currentLocation ().West)
                                    {
                                        mapHasChanged = true;
                                    }

                                    skillLocation = activePlayer.currentLocation ().West;
                                }
                                else
                                {

                                    if (skill != null && skillLocation != null)
                                    {
                                        if (skill.locationsContains (skillLocation.West))
                                        {
                                            cursorSFX.Play ();
                                            skillLocation = skillLocation.West;
                                            mapHasChanged = true;
                                        }
                                    }
                                }
                                updateMap (activePlayer);
                                updateActivePlayer ();

                            }
                            else if ((Input.GetKey (UserSouth) || (Input.GetKey (UserDown) && activePlayer.ManualMode)
                          )
                                     && skill != null && activePlayer.LockedOnTarget == null && !skill.Properties.Contains (" FOCUS "))
                            {
                                print (@"KEY:TARGETLOCATIONSOUTH");
                                inputDelay = INPUTMAXVALUE;

                                if (!NoRemainingAnimations)
                                {
                                    //clearAnimations ();
                                }

                                if (skill != null && skill.LineSkill)
                                {
                                    if (skillLocation != activePlayer.currentLocation ().South)
                                    {
                                        mapHasChanged = true;
                                    }
                                    skillLocation = activePlayer.currentLocation ().South;
                                }
                                else
                                {

                                    if (skill != null && skillLocation != null)
                                    {
                                        if (skill.locationsContains (skillLocation.South))
                                        {
                                            cursorSFX.Play ();
                                            skillLocation = skillLocation.South;
                                            mapHasChanged = true;
                                        }
                                    }
                                }
                                updateMap (activePlayer);
                                updateActivePlayer ();

                            }
                            else if ((Input.GetKey (UserEast) || (Input.GetKey (UserForward) && activePlayer.ManualMode)
                          )
                                     && skill != null && activePlayer.LockedOnTarget == null && !skill.Properties.Contains (" FOCUS "))
                            {
                                print (@"KEY:TARGETLOCATIONEAST");
                                inputDelay = INPUTMAXVALUE;

                                if (!NoRemainingAnimations)
                                {
                                    //clearAnimations ();
                                }

                                if (skill != null && skill.LineSkill)
                                {
                                    if (skillLocation != activePlayer.currentLocation ().East)
                                    {
                                        mapHasChanged = true;
                                    }
                                    skillLocation = activePlayer.currentLocation ().East;
                                }
                                else
                                {

                                    if (skill != null && skillLocation != null)
                                    {
                                        if (skill.locationsContains (skillLocation.East))
                                        {
                                            cursorSFX.Play ();
                                            skillLocation = skillLocation.East;
                                            mapHasChanged = true;
                                        }
                                    }
                                }
                                updateMap (activePlayer);
                                updateActivePlayer ();


                            }
                            else
                            {

                                //PLAYER MOVEMENT AND ACTION USER COMMANDS
                                if (menuInputDelay < 0.0f && (Input.GetKey (UserJumpSet))
                                    && !list.Contains (skill) && activePlayer.CanAct
                                    && !activePlayer.HasJumped)
                                {
                                    print (@"KEY:JUMPSKILL");
                                    menuInputDelay = MENUINPUTMAXVALUE;

                                    if (!NoRemainingAnimations)
                                    {
                                        clearAnimations ();
                                    }

                                    playCancelSound ("cancel");
                                    skillLocation = null;
                                    list = activePlayer.JumpSkills;
                                    setSkill (null, startingPoint (list), list);

                                    updateActivePlayer ();
                                    updateMap (activePlayer);
                                    updatePlayerInfo ();
                                    determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                    determineAnimation ();

                                }
                                else if (menuInputDelay < 0.0f && (Input.GetKey (UserNormalSet))
                                         && list != null && !list.Contains (skill) && activePlayer.CanAct)
                                {
                                    print (@"KEY:NORMALSKILL");

                                    menuInputDelay = MENUINPUTMAXVALUE;

                                    if (!NoRemainingAnimations)
                                    {
                                        clearAnimations ();
                                    }

                                    playCancelSound ("cancel");
                                    skillLocation = null;
                                    list = activePlayer.NormalSkills;
                                    setSkill (null, startingPoint (list), list);

                                    updateMap (activePlayer);
                                    updatePlayerInfo ();
                                    determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                    determineAnimation ();

                                }
                                else if (menuInputDelay < 0.0f && (Input.GetKey (UserSpecialSet))
                                         && !list.Contains (skill) && activePlayer.CanAct)
                                {
                                    print (@"KEY:SPECIALSKILL");
                                    menuInputDelay = MENUINPUTMAXVALUE;

                                    if (!NoRemainingAnimations)
                                    {
                                        clearAnimations ();
                                    }

                                    playCancelSound ("cancel");
                                    skillLocation = null;
                                    list = activePlayer.SpecialSkills;
                                    setSkill (null, startingPoint (list), list);

                                    updateMap (activePlayer);
                                    updateActivePlayer ();
                                    updatePlayerInfo ();
                                    determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                    determineAnimation ();

                                }
                                else if (menuInputDelay < 0.0f && (Input.GetKey (UserVitalitySet))
                                         && !list.Contains (skill) && activePlayer.CanAct)
                                {
                                    print (@"KEY:VITALITYSKILL");
                                    menuInputDelay = MENUINPUTMAXVALUE;

                                    if (!NoRemainingAnimations)
                                    {
                                        clearAnimations ();
                                    }

                                    playCancelSound ("cancel");
                                    skillLocation = null;
                                    list = activePlayer.VitalitySkills;
                                    setSkill (null, startingPoint (list), list);

                                    updateMap (activePlayer);
                                    updateActivePlayer ();
                                    updatePlayerInfo ();
                                    determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                    determineAnimation ();

                                }
                                else if (menuInputDelay < 0.0f && (Input.GetKey (UserBurstSet))
                                         && !list.Contains (skill) && activePlayer.CanAct)
                                {
                                    print (@"KEY:BURSTSKILL");
                                    menuInputDelay = MENUINPUTMAXVALUE;

                                    if (!NoRemainingAnimations)
                                    {
                                        clearAnimations ();
                                    }

                                    playCancelSound ("cancel");
                                    skillLocation = null;
                                    list = activePlayer.BurstSkills;
                                    setSkill (null, startingPoint (list), list);

                                    updateMap (activePlayer);
                                    updateActivePlayer ();
                                    updatePlayerInfo ();
                                    determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                    determineAnimation ();

                                }
                                else if (menuInputDelay < 0.0f && (Input.GetKey (UserItemSet))
                                         && !list.Contains (skill) && activePlayer.CanAct)
                                {
                                    print (@"KEY:ITEMS");
                                    menuInputDelay = MENUINPUTMAXVALUE;

                                    if (!NoRemainingAnimations)
                                    {
                                        clearAnimations ();
                                    }

                                    playCancelSound ("cancel");
                                    skillLocation = null;
                                    list = activePlayer.ItemSkills;
                                    setSkill (null, startingPoint (list), list);

                                    updateMap (activePlayer);
                                    updateActivePlayer ();
                                    updatePlayerInfo ();
                                    determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                    determineAnimation ();

                                }
                                else if (menuInputDelay < 0.0f && (Input.GetKey (UserInventorySet))
                                         && !list.Contains (skill)
                                  && activePlayer.CanAct)
                                {
                                    print (@"KEY:INVENTORY");
                                    menuInputDelay = MENUINPUTMAXVALUE;

                                    if (!NoRemainingAnimations)
                                    {
                                        clearAnimations ();
                                    }

                                    playCancelSound ("cancel");
                                    skillLocation = null;
                                    activePlayer.MyTeam.setInventory (activePlayer);
                                    list = activePlayer.MyTeam.Inventory;
                                    setSkill (null, startingPoint (list), list);

                                    updateMap (activePlayer);
                                    updateActivePlayer ();
                                    updatePlayerInfo ();
                                    determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                    determineAnimation ();


                                }
                                else if (Input.GetKey (UserCancel))
                                {
                                    print (@"KEY:CANCEL");
                                    inputDelay = INPUTMAXVALUE;

                                    if (!NoRemainingAnimations)
                                    {
                                        clearAnimations ();
                                    }

                                    playCancelSound ("cancel");
                                    skillSet = new ArrayList ();
                                    activePlayer.ChainSkills = new ArrayList ();
                                    activePlayer.BurstFollowUpSkills = new ArrayList ();

                                    setSkill (null, -1, null);
                                    skillLocation = null;


                                    currentSkillInput.enabled = false;
                                    updateMap (activePlayer);
                                    updateActivePlayer ();
                                    updatePlayerInfo ();
                                    determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                    determineAnimation ();

                                    if (!activePlayer.CanAct)
                                    {
                                        timerSFX.Stop ();
                                        //endTurn ();
                                    }
                                }
                                else if (Input.GetKey (UserAction))
                                {
                                    clearNotifications ();

                                    if (!NoRemainingAnimations)
                                    {
                                        clearAnimations ();
                                    }

                                    if (!firstMoveActivated)
                                    {
                                        startActiveTime ();
                                    }
                                }
                                else if (skill == null && ((Input.GetKey (UserNorth) || (Input.GetKey (UserUp) && activePlayer.ManualMode)) && !PlayerInMotion
                              ))
                                {
                                    if (!activePlayer.StateActive (activePlayer.Airborne) || activePlayer.Flight || activePlayer.CanFly)
                                    {
                                        print (@"KEY:MOVENORTH");
                                        inputDelay = (INPUTMAXVALUE + 0.20f) - (float)((activePlayer.Speed) * 0.2);

                                        if (!activePlayer.getsDizzy (skill))
                                        {
                                            loc = activePlayer.currentLocation ().North;
                                        }
                                        else
                                        {
                                            loc = randomLocations[activePlayer.R.Next (randomLocations.Length)];
                                        }
                                    }
                                }
                                else if (skill == null && ((Input.GetKey (UserWest) || (Input.GetKey (UserBack) && activePlayer.ManualMode)) && !PlayerInMotion
                              ))
                                {
                                    if (!activePlayer.StateActive (activePlayer.Airborne) || activePlayer.Flight || activePlayer.CanFly)
                                    {

                                        print (@"KEY:MOVEWEST");
                                        inputDelay = (INPUTMAXVALUE + 0.20f) - (float)((activePlayer.Speed) * 0.2);

                                        if (!activePlayer.getsDizzy (skill))
                                        {
                                            loc = activePlayer.currentLocation ().West;
                                        }
                                        else
                                        {
                                            loc = randomLocations[activePlayer.R.Next (randomLocations.Length)];
                                        }
                                    }
                                }
                                else if (skill == null && ((Input.GetKey (UserSouth) || (Input.GetKey (UserDown) && activePlayer.ManualMode)) && !PlayerInMotion))
                                {
                                    if (!activePlayer.StateActive (activePlayer.Airborne) || activePlayer.Flight || activePlayer.CanFly)
                                    {

                                        print (@"KEY:MOVESOUTH");
                                        inputDelay = (INPUTMAXVALUE + 0.20f) - (float)((activePlayer.Speed) * 0.2);

                                        if (!activePlayer.getsDizzy (skill))
                                        {
                                            loc = activePlayer.currentLocation ().South;
                                        }
                                        else
                                        {
                                            loc = randomLocations[activePlayer.R.Next (randomLocations.Length)];
                                        }
                                    }
                                }
                                else if (skill == null && ((Input.GetKey (UserEast) || (Input.GetKey (UserForward) && activePlayer.ManualMode)) && !PlayerInMotion
                              ))
                                {
                                    if (!activePlayer.StateActive (activePlayer.Airborne) || activePlayer.Flight || activePlayer.CanFly)
                                    {
                                        print (@"KEY:MOVEEAST");
                                        inputDelay = (INPUTMAXVALUE + 0.20f) - (float)((activePlayer.Speed) * 0.2);

                                        if (!activePlayer.getsDizzy (skill))
                                        {
                                            loc = activePlayer.currentLocation ().East;
                                        }
                                        else
                                        {
                                            loc = randomLocations[activePlayer.R.Next (randomLocations.Length)];
                                        }
                                    }
                                }
                                else if (skill == null &&
                                  (Input.GetKey (UserGuardButton))
                                         && !PlayerInMotion && !activePlayer.StateActive (activePlayer.Grounded)
                                        && passiveTime <= 0.0f)
                                {

                                    print (@"KEY:GUARD");

                                    inputDelay = INPUTMAXVALUE;
                                    menuInputDelay = MENUINPUTMAXVALUE;
                                    if (!NoRemainingAnimations)
                                    {
                                        clearAnimations ();
                                    }

                                    addToBattleLog (activePlayer.GuardStance, false);
                                    if (!activePlayer.StateActive (activePlayer.Invisible))
                                    {
                                        createAnimationOnMap ("Defend", StateChannel, activePlayer.CentralPosition, 3f, true);
                                    }

                                    if (activePlayer.IsGuarding)
                                    {
                                        actionSFX.Play ();
                                        //endTurn ();
                                        updateActivePlayer ();
                                        updateMap (activePlayer);
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        determineAnimation ();
                                    }
                                }
                                else if (skill == null && (Input.GetKey (KeyCode.Y)) && !PlayerInMotion && passiveTime <= 0.0f)
                                {
                                    print (@"KEY:WAIT");
                                    inputDelay = INPUTMAXVALUE;
                                    menuInputDelay = MENUINPUTMAXVALUE;
                                    if (!NoRemainingAnimations)
                                    {
                                        clearAnimations ();
                                    }

                                    //addToBattleLog (activePlayer.GuardStance, false);

                                    //battleMap.Sort ();

                                    actionSFX.Play ();
                                    if (activePlayer.MovesRemaining > 0)
                                    {
                                        activePlayer.MovesRemaining -= 1;
                                    }
                                    else
                                    {
                                        //endTurn ();
                                    }
                                    updateActivePlayer ();
                                    updateMap (activePlayer);
                                    updatePlayerInfo ();
                                    determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                    determineAnimation ();


                                }
                                else if (skill == null && NoPlayerInMotion && (Input.GetKey (KeyCode.F1)) && passiveTime <= 0.0f && !activePlayer.HasActed && !activePlayer.BonusRoundActivated)
                                {
                                    print (@"KEY:SAVE");
                                    inputDelay = INPUTMAXVALUE;
                                    menuInputDelay = MENUINPUTMAXVALUE;


                                    new DataReader ().saveMatch (battleMap);


                                    //if (!NoRemainingAnimations) {
                                    //  clearAnimations ();
                                    //} 

                                    //addToBattleLog (activePlayer.GuardStance, false);

                                    //battleMap.Sort ();

                                    //actionSFX.Play ();
                                    //endTurn ();
                                    //updateActivePlayer ();
                                    //updateMap (activePlayer);
                                    //updatePlayerInfo ();
                                    //determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                    //determineAnimation ();


                                }
                                else if (skill == null && NoPlayerInMotion && (Input.GetKey (KeyCode.F2)) && passiveTime <= 0.0f && !activePlayer.HasActed && !activePlayer.BonusRoundActivated)
                                {
                                    print (@"KEY:LOAD");
                                    inputDelay = INPUTMAXVALUE;
                                    menuInputDelay = MENUINPUTMAXVALUE;


                                    //new DataReader ().loadMatch ();
                                    battleMap = new DataReader ().loadMatch ();
                                    loadMap ();



                                    //if (!NoRemainingAnimations) {
                                    //  clearAnimations ();
                                    //} 

                                    //addToBattleLog (activePlayer.GuardStance, false);

                                    //battleMap.Sort ();

                                    //actionSFX.Play ();
                                    //endTurn ();
                                    //updateActivePlayer ();
                                    //updateMap (activePlayer);
                                    //updatePlayerInfo ();
                                    //determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                    //determineAnimation ();


                                }
                                else if ((Input.GetKey (UserCrouchButton) && !PlayerInMotion && passiveTime <= 0.0f) && skill == null)
                                {

                                    if (activePlayer.StateActive (activePlayer.Airborne))
                                    {
                                        inputDelay = INPUTMAXVALUE;
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        displayMapPlayerGraphics (activePlayer, activePlayer.Row, activePlayer.Column);
                                        //mapHasChanged = true;

                                        //if (activePlayer)
                                        int oldHeight = activePlayer.Potency (activePlayer.Airborne);
                                        activePlayer.SetHeight (0);
                                        displayMapMovement (activePlayer, activePlayer.currentLocation (), oldHeight,
                                                            activePlayer.currentLocation (), activePlayer.Potency (activePlayer.Airborne), "CrouchNeutral", oldHeight, false, null, activePlayer.Direction);
                                        walkSFX.Play ();

                                        //battleMap.Sort ();

                                        updateActivePlayer ();
                                        updateMap (activePlayer);
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        determineAnimation ();

                                    }
                                    else if (activePlayer.StateActive (activePlayer.Grounded))
                                    {
                                        inputDelay = INPUTMAXVALUE;
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        displayMapPlayerGraphics (activePlayer, activePlayer.Row, activePlayer.Column);
                                        //mapHasChanged = true;

                                        //if (activePlayer)
                                        int oldHeight = activePlayer.Potency (activePlayer.Airborne);
                                        activePlayer.Grounded.Potency = 0;
                                        addToBattleLog (activePlayer.Crouch, false);

                                        walkSFX.Play ();

                                        //battleMap.Sort ();

                                        updateActivePlayer ();
                                        updateMap (activePlayer);
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        determineAnimation ();

                                    }
                                    else if ((activePlayer.IsStanding || activePlayer.IsCrouching))
                                    {
                                        print (@"KEY:CROUCH");
                                        inputDelay = INPUTMAXVALUE;
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        if (!NoRemainingAnimations)
                                        {
                                            clearAnimations ();
                                        }

                                        addToBattleLog (activePlayer.Crouch, false);

                                        //battleMap.Sort ();

                                        displayMapPlayerGraphics (activePlayer, activePlayer.Row, activePlayer.Column);
                                        skillSet = new ArrayList ();
                                        setSkill (null, -1, null);
                                        skillLocation = null;
                                        updateActivePlayer ();
                                        updateMap (activePlayer);
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        determineAnimation ();
                                    }

                                }
                                else if ((Input.GetKey (UserRestButton) && passiveTime <= 0.0f)
                                         && !PlayerInMotion && (!activePlayer.StateActive (activePlayer.Airborne) || activePlayer.Flight))
                                {

                                    print (@"KEY:REST");
                                    inputDelay = INPUTMAXVALUE;
                                    menuInputDelay = MENUINPUTMAXVALUE;
                                    if (!NoRemainingAnimations)
                                    {
                                        //clearAnimations ();
                                    }

                                    addToBattleLog (activePlayer.Rest, false);
                                    if (activePlayer.IsResting)
                                    {
                                        if (!activePlayer.StateActive (activePlayer.Invisible))
                                        {
                                            createAnimationOnMap ("Rest", StateChannel, activePlayer.CentralPosition, 3f, false);
                                        }

                                        //battleMap.Sort ();

                                        actionSFX.Play ();
                                        //endTurn ();
                                        updateActivePlayer ();
                                        updateMap (activePlayer);
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        determineAnimation ();
                                    }

                                }
                                else if ((Input.GetKey (UserTauntButton)
                                          && NoPlayerInMotion && passiveTime <= 0.0f) && !activePlayer.StateActive (activePlayer.Counter)
                                  && (skillSet == null || skillSet.Count < 1)
                                  && !activePlayer.StateActive (activePlayer.Grounded)
                                         && (!activePlayer.StateActive (activePlayer.Airborne) || activePlayer.Flight || activePlayer.CanFly))
                                {
                                    print (@"KEY:TAUNT");
                                    if (activePlayer.TauntSkill == null)
                                    {
                                        inputDelay = INPUTMAXVALUE;
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        actionSFX.Play ();
                                        createAnimationOnMap ("Psyche", StateChannel, activePlayer.CentralPosition, 3f, false);
                                        addDialogue (activePlayer.Vocals.RandomTaunt, activePlayer, false, "Taunt");
                                        addToBattleLog (activePlayer.Taunt, false);

                                        //battleMap.Sort ();

                                        //endTurn ();
                                        updateActivePlayer ();
                                        updateMap (activePlayer);
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        determineAnimation ();

                                    }
                                    else
                                    {
                                        inputDelay = INPUTMAXVALUE;
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        playCancelSound ("cancel");
                                        setSkill (null, -1, null);
                                        skillLocation = null;
                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        determineAnimation ();
                                        list = activePlayer.SpecialSkills;

                                    }
                                }

                                else if ((Input.GetKey (UserWaitButton)
                                    && NoPlayerInMotion && passiveTime <= 0.0f) && !activePlayer.StateActive (activePlayer.Counter)
                                    && (skillSet == null || skillSet.Count < 1)
                                    && !activePlayer.StateActive (activePlayer.Grounded)
                                     && !activePlayer.StateActive (activePlayer.Airborne))
                                {
                                    print (@"KEY:WAIT");
                                    inputDelay = INPUTMAXVALUE;

                                    actionSFX.Play ();
                                    addDialogue (activePlayer.Vocals.RandomTaunt, activePlayer, false, "Taunt");
                                    activePlayer.CanAct = false;
                                    activePlayer.MovesRemaining = 0;
                                    addToBattleLog (activePlayer.Taunt, false);

                                    updateActivePlayer ();
                                    updateMap (activePlayer);
                                    updatePlayerInfo ();
                                    determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                    determineAnimation ();

                                }
                                if (loc != null)
                                {
                                    addToBattleLog (recordWalk (activePlayer, loc, true, true, activePlayer.Flight), false);
                                }


                                if (activePlayer != null && activePlayer.setCostsAndConditionsMet (list) && skill == null)
                                {
                                    skillSet = list;
                                    setSkill ((Skill)skillSet[startingPoint (skillSet)], startingPoint (skillSet), skillSet);
                                    updateActivePlayer ();
                                    updatePlayerInfo ();
                                }
                            }
                            if (skillSet.Count > 0)
                            {

                                //SKILL LIST USER COMMANDS
                                if (Input.GetKey (User_Alpha1))
                                {
                                    print (@"KEY:SKILL1");
                                    if (skillSet.Count > 0 && ((Skill)skillSet[0]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE + MenuDexterity;
                                        cursorSFX.Play ();
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[0], 0, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }

                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha2))
                                {
                                    print (@"KEY:SKILL2");
                                    if (skillSet.Count > 1 && ((Skill)skillSet[1]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE + MenuDexterity;
                                        cursorSFX.Play ();
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[1], 1, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha3))
                                {
                                    print (@"KEY:SKILL3");
                                    if (skillSet.Count > 2 && ((Skill)skillSet[2]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE + MenuDexterity;
                                        cursorSFX.Play ();
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[2], 2, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha4))
                                {
                                    print (@"KEY:SKILL4");
                                    if (skillSet.Count > 3 && ((Skill)skillSet[3]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE + MenuDexterity;
                                        cursorSFX.Play ();
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[3], 3, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha5))
                                {
                                    print (@"KEY:SKILL5");
                                    if (skillSet.Count > 4 && ((Skill)skillSet[4]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE + MenuDexterity;
                                        cursorSFX.Play ();
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[4], 4, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }


                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha6))
                                {
                                    print (@"KEY:SKILL6");
                                    if (skillSet.Count > 5 && ((Skill)skillSet[5]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE + MenuDexterity;
                                        cursorSFX.Play ();
                                        if (!NoRemainingAnimations)
                                        {
                                            // clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[5], 5, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha7))
                                {
                                    print (@"KEY:SKILL7");
                                    if (skillSet.Count > 6 && ((Skill)skillSet[6]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE + MenuDexterity;
                                        cursorSFX.Play ();
                                        if (!NoRemainingAnimations)
                                        {
                                            //    clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[6], 6, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha8))
                                {
                                    print (@"KEY:SKILL8");
                                    if (skillSet.Count > 7 && ((Skill)skillSet[7]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE + MenuDexterity;
                                        cursorSFX.Play ();
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[7], 7, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha9))
                                {
                                    print (@"KEY:SKILL9");
                                    if (skillSet.Count > 8 && ((Skill)skillSet[8]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE + MenuDexterity;
                                        cursorSFX.Play ();
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[8], 8, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (User_Alpha0))
                                {
                                    print (@"KEY:SKILL10");
                                    if (skillSet.Count > 9 && ((Skill)skillSet[9]).CostsAndConditionsMet)
                                    {
                                        menuInputDelay = MENUINPUTMAXVALUE + MenuDexterity;
                                        cursorSFX.Play ();
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[9], 9, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (UserJumpSet))
                                {
                                    print (@"KEY:SKILLJUMP");
                                    if (getSkillOfType ("JUMP ") >= 0 && ((Skill)skillSet[getSkillOfType ("JUMP ")]).CostsAndConditionsMet)
                                    {
                                        int inde = getSkillOfType ("JUMP ");
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        cursorSFX.Play ();
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[inde], inde, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (UserNormalSet))
                                {
                                    print (@"KEY:SKILLNORMAL");
                                    if (getSkillOfType ("NORMAL ") >= 0 && ((Skill)skillSet[getSkillOfType ("NORMAL ")]).CostsAndConditionsMet)
                                    {
                                        int inde = getSkillOfType ("NORMAL ");
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        cursorSFX.Play ();
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[inde], inde, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (UserSpecialSet))
                                {
                                    print (@"KEY:SKILLSPECIAL");
                                    if (getSkillOfType ("SPECIAL ") >= 0 && ((Skill)skillSet[getSkillOfType ("SPECIAL ")]).CostsAndConditionsMet)
                                    {
                                        int inde = getSkillOfType ("SPECIAL ");
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        cursorSFX.Play ();
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[inde], inde, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (UserVitalitySet))
                                {
                                    print (@"KEY:SKILLVITALITY");
                                    if (getSkillOfType ("VITALITY ") >= 0 && ((Skill)skillSet[getSkillOfType ("VITALITY ")]).CostsAndConditionsMet)
                                    {
                                        int inde = getSkillOfType ("VITALITY ");
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        cursorSFX.Play ();
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[inde], inde, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (UserBurstSet))
                                {
                                    print (@"KEY:SKILLBURST");
                                    if (getSkillOfType ("BURST ") >= 0 && ((Skill)skillSet[getSkillOfType ("BURST ")]).CostsAndConditionsMet)
                                    {
                                        int inde = getSkillOfType ("BURST ");
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        cursorSFX.Play ();
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[inde], inde, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (UserActionSet) && activePlayer.SActionSkill.CostsAndConditionsMet)
                                {
                                    print (@"KEY:SKILLACTION");

                                    menuInputDelay = MENUINPUTMAXVALUE;

                                    if (!NoRemainingAnimations)
                                    {
                                        //clearAnimations ();
                                    }

                                    playCancelSound ("cancel");
                                    skillLocation = null;
                                    list = new ArrayList { activePlayer.SActionSkill };
                                    setSkill (activePlayer.SActionSkill, 0, list);
                                    activePlayer.SActionSkill.setLocations ();
                                    skillLocation = activePlayer.currentLocation ();

                                    if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                    {
                                        skillLocation = activePlayer.currentLocation ();
                                    }

                                    if (skill.Inputs.Length > 0)
                                    {
                                        currentSkillInput.enabled = true;
                                        currentSkillInput.texture = ProperInput (skill);
                                    }
                                    else
                                    {
                                        currentSkillInput.enabled = false;
                                    }

                                    if (!firstMoveActivated)
                                    {
                                        startActiveTime ();
                                    }


                                    updateMap (activePlayer);
                                    updateActivePlayer ();
                                    updatePlayerInfo ();
                                    determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                    determineAnimation ();

                                }
                                else if (Input.GetKey (UserItemSet))
                                {
                                    print (@"KEY:SKILLITEM");
                                    if (getSkillOfType ("ITEM ") >= 0 && ((Skill)skillSet[getSkillOfType ("ITEM ")]).CostsAndConditionsMet)
                                    {
                                        int inde = getSkillOfType ("ITEM ");
                                        menuInputDelay = MENUINPUTMAXVALUE;
                                        cursorSFX.Play ();
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        setSkill ((Skill)skillSet[inde], inde, skillSet);
                                        setSkillLocations ();

                                        if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                        {
                                            skillLocation = activePlayer.currentLocation ();
                                        }
                                        if (skill.Inputs.Length > 0)
                                        {
                                            currentSkillInput.enabled = true;
                                            currentSkillInput.texture = ProperInput (skill);
                                        }
                                        else
                                        {
                                            currentSkillInput.enabled = false;
                                        }

                                        if (!firstMoveActivated)
                                        {
                                            startActiveTime ();
                                        }

                                        updateMap (activePlayer);
                                        updateActivePlayer ();
                                        updatePlayerInfo ();
                                        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                        //setAnimation ();
                                    }
                                }
                                else if (Input.GetKey (UserInventorySet)
                                  && activePlayer.CanAct
                                  && activePlayer.setCostsAndConditionsMet (activePlayer.MyTeam.Inventory))
                                {
                                    print (@"KEY:INVENTORY");
                                    menuInputDelay = MENUINPUTMAXVALUE;
                                    playCancelSound ("cancel");
                                    if (!NoRemainingAnimations)
                                    {
                                        //clearAnimations ();
                                    }

                                    setSkill ((Skill)activePlayer.MyTeam.Inventory[0], 0, activePlayer.MyTeam.Inventory);
                                    skillLocation = null;
                                    activePlayer.MyTeam.setInventory (activePlayer);
                                    list = activePlayer.MyTeam.Inventory;

                                    updateMap (activePlayer);
                                    updateActivePlayer ();
                                    updatePlayerInfo ();
                                    determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                    determineAnimation ();

                                }
                                else if (Input.GetKey (User_ScrollDown1))
                                {
                                    print (@"KEY:SKILL+1");
                                    int indx = nextAvailableIndex (1);
                                    if (indx >= 0)
                                    {
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        if (((Skill)skillSet[indx]).CostsAndConditionsMet)
                                        {
                                            inputDelay = INPUTMAXVALUE;
                                            cursorSFX.Play ();

                                            setSkill ((Skill)skillSet[indx], indx, skillSet);
                                            setSkillLocations ();

                                            if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                            {
                                                skillLocation = activePlayer.currentLocation ();
                                            }
                                            if (skill.Inputs.Length > 0)
                                            {
                                                currentSkillInput.enabled = true;
                                                currentSkillInput.texture = ProperInput (skill);
                                            }
                                            else
                                            {
                                                currentSkillInput.enabled = false;
                                            }

                                            if (!firstMoveActivated)
                                            {
                                                startActiveTime ();
                                            }

                                            updateMap (activePlayer);
                                            updateActivePlayer ();
                                            updatePlayerInfo ();
                                            determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                            //setAnimation ();
                                        }
                                    }
                                }
                                else if (Input.GetKey (User_ScrollUp1))
                                {
                                    print (@"KEY:SKILL-1");
                                    int indx = nextAvailableIndex (-1);
                                    if (indx >= 0)
                                    {
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        if (((Skill)skillSet[indx]).CostsAndConditionsMet)
                                        {
                                            inputDelay = INPUTMAXVALUE;
                                            cursorSFX.Play ();

                                            setSkill ((Skill)skillSet[indx], indx, skillSet);
                                            setSkillLocations ();

                                            if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                            {
                                                skillLocation = activePlayer.currentLocation ();
                                            }
                                            if (skill.Inputs.Length > 0)
                                            {
                                                currentSkillInput.enabled = true;
                                                currentSkillInput.texture = ProperInput (skill);
                                            }
                                            else
                                            {
                                                currentSkillInput.enabled = false;
                                            }

                                            if (!firstMoveActivated)
                                            {
                                                startActiveTime ();
                                            }

                                            updateMap (activePlayer);
                                            updateActivePlayer ();
                                            updatePlayerInfo ();
                                            determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                            //setAnimation ();
                                        }
                                    }
                                }
                                else if (Input.GetKey (User_ScrollDown2))
                                {
                                    print (@"KEY:SKILL+3");
                                    int indx = nextAvailableIndex (3);
                                    if (indx >= 0)
                                    {
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        if (((Skill)skillSet[indx]).CostsAndConditionsMet)
                                        {
                                            inputDelay = INPUTMAXVALUE;
                                            cursorSFX.Play ();

                                            setSkill ((Skill)skillSet[indx], indx, skillSet);
                                            setSkillLocations ();

                                            if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                            {
                                                skillLocation = activePlayer.currentLocation ();
                                            }
                                            if (skill.Inputs.Length > 0)
                                            {
                                                currentSkillInput.enabled = true;
                                                currentSkillInput.texture = ProperInput (skill);
                                            }
                                            else
                                            {
                                                currentSkillInput.enabled = false;
                                            }

                                            if (!firstMoveActivated)
                                            {
                                                startActiveTime ();
                                            }

                                            updateMap (activePlayer);
                                            updateActivePlayer ();
                                            updatePlayerInfo ();
                                            determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                            //setAnimation ();
                                        }
                                    }
                                }
                                else if (Input.GetKey (User_ScrollUp2))
                                {
                                    print (@"KEY:SKILL-3");
                                    int indx = nextAvailableIndex (-3);
                                    if (indx >= 0)
                                    {
                                        if (!NoRemainingAnimations)
                                        {
                                            //clearAnimations ();
                                        }

                                        if (((Skill)skillSet[indx]).CostsAndConditionsMet)
                                        {
                                            inputDelay = INPUTMAXVALUE;
                                            cursorSFX.Play ();

                                            setSkill ((Skill)skillSet[indx], indx, skillSet);
                                            setSkillLocations ();

                                            if (activePlayer.LockedOnTarget == null || !skill.locationsContains (skillLocation))
                                            {
                                                skillLocation = activePlayer.currentLocation ();
                                            }
                                            if (skill.Inputs.Length > 0)
                                            {
                                                currentSkillInput.enabled = true;
                                                currentSkillInput.texture = ProperInput (skill);
                                            }
                                            else
                                            {
                                                currentSkillInput.enabled = false;
                                            }

                                            if (!firstMoveActivated)
                                            {
                                                startActiveTime ();
                                            }

                                            updateMap (activePlayer);
                                            updateActivePlayer ();
                                            updatePlayerInfo ();
                                            determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                            //setAnimation ();
                                        }
                                    }
                                }


                                if (Input.GetKey (UserCancel))
                                {
                                    print (@"KEY:CANCEL");
                                    inputDelay = INPUTMAXVALUE;

                                    skillSet = new ArrayList ();
                                    setSkill (null, -1, null);
                                    skillLocation = null;

                                    inputImages.Clear ();
                                    inputPrompt.texture = null;
                                    inputPrompt.enabled = false;

                                    activePlayer.ChainSkills = new ArrayList ();
                                    activePlayer.BurstFollowUpSkills = new ArrayList ();

                                    currentSkillInput.enabled = false;
                                    updateMap (activePlayer);
                                    updateActivePlayer ();
                                    updatePlayerInfo ();
                                    determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
                                    determineAnimation ();

                                    if (!activePlayer.CanAct)
                                    {
                                        if (!NoRemainingAnimations)
                                        {
                                            clearAnimations ();
                                        }

                                        timerSFX.Stop ();
                                        //endTurn ();
                                    }
                                }
                            }

                            if ((Input.GetKey (UserConfirm) || Input.GetKey (UserAction)) && inputDelay < 0.0f && menuInputDelay < 0.0f && !activePlayer.CanAct && skillSet.Count == 0)
                            {

                                if (!NoRemainingAnimations)
                                {
                                    //clearAnimations ();
                                    updateMap (activePlayer);
                                }

                                //setNewActivePlayer ((Player)battleMap.Roster [index], true);
                            }

                            //DEBUG ONLY, ITERATE THROUGH ROSTER
                            //DEBUG BUTTONS
                            if (trainingMode)
                            {
                                if (Input.GetKey (KeyCode.Home))
                                {
                                    inputDelay = INPUTMAXVALUE;
                                    firstMoveActivated = false;
                                    addToBattleLog ("", true);
                                    addToBattleLog (shiftHealth (activePlayer, activePlayer.Health.MeterMax, false, null, null), false);
                                    addToBattleLog (shiftRush (activePlayer, activePlayer.Guard.MeterMax, false, null), false);
                                    addToBattleLog (shiftGuard (activePlayer, activePlayer.Rush.MeterMax, false, null), false);
                                    addToBattleLog (shiftVitality (activePlayer, activePlayer.Vitality.MeterMax, false, null), false);
                                    addToBattleLog (shiftStun (activePlayer, -1 * activePlayer.Stun.MeterMax, false, null), false);
                                    activePlayer.HasActed = false;
                                    addToBattleLog (activePlayer.setAction (true), false);
                                    activePlayer.HasJumped = false;
                                    activePlayer.SActionEnabled = true;
                                    activePlayer.Cooldown = 0;
                                    activePlayer.MovesRemaining = activePlayer.Movement;
                                    updateActivePlayer ();
                                    updateMap (activePlayer);
                                    updatePlayerInfo ();
                                }
                                else if (Input.GetKey (KeyCode.Help))
                                {
                                    inputDelay = INPUTMAXVALUE;
                                    addToBattleLog (shiftHealth (
                                        activePlayer, -1 * (activePlayer.Health.MeterLevel - 1), true, null, null), true);
                                    updateActivePlayer ();
                                    updateMap (activePlayer);
                                    updatePlayerInfo ();
                                }
                                else if (Input.GetKey (KeyCode.PageDown))
                                {
                                    inputDelay = INPUTMAXVALUE;
                                    addToBattleLog (shiftHealth (
                                        activePlayer, -1 * (activePlayer.Health.MeterLevel / 2), true, null, null), true);
                                    updateActivePlayer ();
                                    updateMap (activePlayer);
                                    updatePlayerInfo ();
                                }
                                else if (Input.GetKey (KeyCode.PageUp))
                                {
                                    addToBattleLog (levelUp (activePlayer, true), true);
                                    addToBattleLog (activePlayer.Speed + " " + activePlayer.ActiveSpeed, false);
                                    updateActivePlayer ();
                                    updateMap (activePlayer);
                                    updatePlayerInfo ();
                                }
                                else if (Input.GetKey (KeyCode.End) && menuInputDelay < 0.0f)
                                {
                                    addToBattleLog (levelUp (activePlayer, true), true);
                                    addToBattleLog (activePlayer.Speed + " " + activePlayer.ActiveSpeed, false);
                                    updateActivePlayer ();
                                    updateMap (activePlayer);
                                    updatePlayerInfo ();
                                }
                                else if (Input.GetKey (KeyCode.Numlock) && menuInputDelay < 0.0f)
                                {
                                    setNewActivePlayer ((Player)battleMap.Roster[battleMap.Index], true);
                                }
                            }

                            if (Input.GetKey (KeyCode.Delete) && !trainingMode)
                            {
                                koPlayer (activePlayer, null, null, false);
                                updateActivePlayer ();
                                updateMap (activePlayer);
                                updatePlayerInfo ();
                            }

                            if (Input.GetKey (UserConfirm))
                            {
                                inputDelay = INPUTMAXVALUE;
                                menuInputDelay = MENUINPUTMAXVALUE;


                                //if (!NoRemainingAnimations) {
                                //  clearAnimations ();
                                //  updateMap (activePlayer);
                                //} 

                                if (skill == null && skillSet.Count == 0 && inputDelay < 0 && menuInputDelay < 0)
                                {
                                    inputSuccess = true;
                                    readingUserCommands = false;

                                    if (passiveTime <= 0)
                                    {
                                        clearNotifications ();
                                        //  setNewActivePlayer ((Player)battleMap.Roster [index], true);
                                    }
                                    else
                                    {
                                        passiveTime = 0.01f;
                                    }
                                }
                                else if (canExecuteSkill ())
                                {
                                    selectSFX.Play ();

                                    if (activePlayer.getsDizzy (skill))
                                    {
                                        skillLocation = (Location)skill.Locations[activePlayer.R.Next (skill.Locations.Count)];
                                        while (!canExecuteSkill ())
                                        {
                                            skillLocation = (Location)skill.Locations[activePlayer.R.Next (skill.Locations.Count)];
                                        }
                                        updateActivePlayer ();
                                        updateMap (activePlayer);
                                    }

                                    if (skill != null && skill.Inputs.Length > 0)
                                    {
                                        setInputs ();
                                        inputSuccess = true;
                                        readingUserCommands = true;
                                        inputPrompt.enabled = true;
                                        fullInputPrompt.enabled = true;
                                        if (skill.Properties.Contains (@"SECRET "))
                                        {
                                            fullInputPrompt.texture = noInput;
                                        }
                                        else
                                        {
                                            fullInputPrompt.texture = Resources.Load<Texture2D>(@"Inputs/" + skill.Inputs[0]);
                                        }

                                    }
                                    else
                                    {
                                        readingUserCommands = false;
                                        executeSkill ();

                                        if (skill != null && skill.Inputs.Length > 0)
                                        {
                                            setInputs ();
                                        }

                                        updateActivePlayer ();
                                        updateMap (activePlayer);
                                        //updatePlayerInfo ();
                                    }
                                }
                            }

                        }
                    }
                }
            }
        }
        else
        {
            if (matchOverTimer > 0.0f)
            {
                matchOverTimer -= Time.deltaTime;
                bgm.volume -= Time.deltaTime;
                if (matchOverTimer <= 0.0f)
                {
                    SceneManager.LoadScene (1);
                }
            }
            else if (engageTimer > 0.0f)
            {
                engageTimer -= Time.deltaTime;
                bgm.volume -= Time.deltaTime;
                if (engageTimer <= 0.0f)
                {
                    SceneManager.LoadScene (4);
                }
            }
        }
    }

    public RawImage cloneRawImage (string name, RawImage original, Transform parent)
    {
        RawImage clone = new GameObject ().AddComponent<RawImage>();
        clone.gameObject.name = name;
        clone.transform.SetParent (parent);
        clone.GetComponent<RectTransform>().sizeDelta = new Vector2(original.rectTransform.sizeDelta.x, original.rectTransform.sizeDelta.y);
        clone.rectTransform.anchorMin = original.rectTransform.anchorMin;
        clone.rectTransform.anchorMax = original.rectTransform.anchorMax;
        clone.rectTransform.pivot = original.rectTransform.pivot;
        clone.transform.position = original.transform.position;
        clone.transform.SetSiblingIndex (original.transform.GetSiblingIndex ());
        clone.texture = original.texture;
        //= targetHealthBars [i].transform.position;
        return clone;
    }

    public Text cloneText (string name, Text original, Transform parent)
    {
        Text clone = new GameObject ().AddComponent<Text>();
        clone.gameObject.name = name;
        clone.transform.SetParent (gameCanvas.transform);
        clone.transform.SetAsLastSibling ();
        //clone.transform.SetSiblingIndex (original.transform.GetSiblingIndex ());
        clone.GetComponent<RectTransform>().sizeDelta = new Vector2(original.preferredWidth, original.preferredHeight);
        clone.alignment = original.alignment;
        clone.font = original.font;
        clone.fontStyle = original.fontStyle;
        clone.fontSize = original.fontSize;
        clone.horizontalOverflow = original.horizontalOverflow;
        clone.verticalOverflow = original.verticalOverflow;
        clone.alignByGeometry = original.alignByGeometry;
        clone.transform.position = original.transform.position;
        clone.text = original.text;
        clone.color = original.color;
        return clone;
    }

    /**
    public Boolean canExecuteSkill ()
    {
        return false;
    }
    */
    public Boolean canExecuteSkill ()
    {
        if (skill == null || skillLocation == null)
        {
            return false;
        }
        if (!skill.CostsAndConditionsMet)
        {
            return false;
        }

        if (!skill.Auto && (!skill.locationsContains (skillLocation) && !skill.Targetless))
        {
            return false;
        }

        if (skill.Properties.Contains (@"ALLHEIGHT") || skill.Properties.Contains (@"TELEPORT"))
        {
            return true;
        }
        if (skill.Properties.Contains (@"LEAP") || skill.Properties.Contains (@"JUMP") || skill.MotionRange != 0)
        {
            return (battleMap.HeightMap[activePlayer.Row][activePlayer.Column] - battleMap.HeightMap[skillLocation.Row][skillLocation.Column] >= -1)
                || skill.Properties.Contains (@"LEVELDIFF") || (skill.Properties.Contains (@"JUMP")
                    && battleMap.HeightMap[activePlayer.Row][activePlayer.Column] - battleMap.HeightMap[skillLocation.Row][skillLocation.Column] >= (-1 * activePlayer.JumpHeight))
                || (skill.Properties.Contains (@"LEAP")
                    && battleMap.HeightMap[activePlayer.Row][activePlayer.Column] - battleMap.HeightMap[skillLocation.Row][skillLocation.Column] >= (skill.Range * -1));
        }
        return true;
    }


    public void updateInteractable (Location loc)
    {
        interMap[loc.Row][loc.Column].GetComponent<RectTransform>().sizeDelta = new Vector2(tMapOriginal.rectTransform.sizeDelta.x, tMapOriginal.rectTransform.sizeDelta.y);
        interMap[loc.Row][loc.Column].transform.position = miniMap[loc.Row][loc.Column].transform.position;

        if (!battleMap.isEmptyInteractable (loc) && !battleMap.interactableAt (loc).Properties.Contains (@"INVISIBLE "))
        {
            interMap[loc.Row][loc.Column].texture = battleMap.interactableAt (loc).mapTexture ();
            interMap[loc.Row][loc.Column].color = Color.white;
            //print (interMap [loc.Row] [loc.Column].texture.name);
        }
        else if (!battleMap.isEmptyBenign (loc) && !battleMap.benignAt (loc).Properties.Contains (@"INVISIBLE "))
        {
            interMap[loc.Row][loc.Column].texture = battleMap.benignAt (loc).mapTexture ();
            interMap[loc.Row][loc.Column].color = Color.white;
            //print (interMap [loc.Row] [loc.Column].texture.name);
        }
        else
        {
            interMap[loc.Row][loc.Column].texture = neutralTexture;
            interMap[loc.Row][loc.Column].color = Color.clear;
        }
    }

    public void updateProjectile (Location loc)
    {
        projMap[loc.Row][loc.Column].GetComponent<RectTransform>().sizeDelta = new Vector2(tMapOriginal.rectTransform.sizeDelta.x, tMapOriginal.rectTransform.sizeDelta.y);
        projMap[loc.Row][loc.Column].transform.position = miniMap[loc.Row][loc.Column].transform.position;

        if (!battleMap.isEmptyProjectile (loc) && !battleMap.projectileAt (loc).Properties.Contains (@"INVISIBLE "))
        {
            projMap[loc.Row][loc.Column].texture = battleMap.projectileAt (loc).mapTexture ();
            projMap[loc.Row][loc.Column].color = Color.white;
            //print (projMap [loc.Row] [loc.Column].texture.name);
        }
        else if (!battleMap.isEmptyBenign (loc) && !battleMap.benignAt (loc).Properties.Contains (@"INVISIBLE "))
        {
            projMap[loc.Row][loc.Column].texture = battleMap.benignAt (loc).mapTexture ();
            projMap[loc.Row][loc.Column].color = Color.white;
            //print (projMap [loc.Row] [loc.Column].texture.name);
        }
        else
        {
            projMap[loc.Row][loc.Column].texture = neutralTexture;
            projMap[loc.Row][loc.Column].color = Color.clear;
        }
    }


    public void updateMap (Player pl)
    {
        if (mapHasChanged)
        {
            Location loc;
            Locatable obj;
            Player p;

            mapHasChanged = false;

            for (int i = 0; i < battleMap.Rows; i++)
            {
                for (int j = 0; j < battleMap.Columns; j++)
                {

                    loc = new Location (i, j);

                    miniMap[i][j].color = Color.clear;
                    miniMap[i][j].GetComponent<RectTransform>().sizeDelta = new Vector2(tMapOriginal.rectTransform.sizeDelta.x, tMapOriginal.rectTransform.sizeDelta.y);

                    obj = battleMap.objectAt (loc);

                    if (obj != null && !obj.sentient () && obj.isVisible ())
                    {

                        miniMap[i][j].texture = obj.mapTexture ();
                        miniMap[i][j].GetComponent<RectTransform>().sizeDelta = new Vector2(tMapOriginal.rectTransform.sizeDelta.x, tMapOriginal.rectTransform.sizeDelta.y + (5 * (((MapObject)battleMap.objectAt (loc)).Height - 1)));
                        miniMap[i][j].color = Color.white;

                    }
                    else
                    {
                        miniMap[i][j].texture = neutralTexture;
                        miniMap[i][j].GetComponent<RectTransform>().sizeDelta = new Vector2(tMapOriginal.rectTransform.sizeDelta.x, tMapOriginal.rectTransform.sizeDelta.y);
                    }


                    if (loc.Equals (skillLocation) && skill != null
                        && (pl != null
                            && pl.currentLocation () != null
                            && skill != null
                            && !pl.currentLocation ().Equals (loc) || !skill.LineSkill)
                        && !activePlayer.StateActive (activePlayer.Blind)
                        && !activePlayer.StateActive (activePlayer.Confuse))
                    {

                        if (skill != null && canExecuteSkill ())
                        {

                            miniMap[i][j].color = Color.green;

                        }
                        else
                        {

                            miniMap[i][j].color = darkGrey;

                        }
                    }
                    else if (!battleMap.isEmpty (loc) && obj.isVisible ())
                    {

                        if (!obj.sentient ())
                        {
                            if (skill != null && skill.locationsContains (loc))
                            {
                                miniMap[i][j].color = Color.grey;
                            }
                        }
                    }
                    else if (skill != null && (skill.locationsContains (loc) || skill.locationInRange (loc, skillLocation))
                             && activePlayer.LockedOnTarget == null
                             && !activePlayer.StateActive (activePlayer.Invisible))
                    {
                        if (!skill.locationInRange (loc, skillLocation) || activePlayer.StateActive (activePlayer.Confuse))
                        {
                            miniMap[i][j].color = Color.grey;
                        }
                        else
                        {
                            miniMap[i][j].color = Color.white;
                        }
                    }

                    updateInteractable (loc);
                    updateProjectile (loc);

                    if (battleMap.playerAt (loc) != null)
                    {
                        p = battleMap.playerAt (loc);
                        if (!p.InMovement)
                        {
                            displayMapPlayerGraphics (p, p.Row, p.Column);
                        }

                    }

                    if (miniMap[i][j].enabled)
                    {
                        miniMap[i][j].transform.position =
                            new Vector3(originalMapPositions[i][j].x,
                                originalMapPositions[i][j].y,
                                originalMapPositions[i][j].z);
                    }
                    if (interMap[i][j].enabled)
                    {
                        interMap[i][j].transform.position =
                            new Vector3(miniMap[i][j].transform.position.x,
                                miniMap[i][j].transform.position.y,
                                miniMap[i][j].transform.position.z);
                    }
                    if (projMap[i][j].enabled)
                    {
                        projMap[i][j].transform.position =
                            new Vector3(miniMap[i][j].transform.position.x,
                                miniMap[i][j].transform.position.y,
                                miniMap[i][j].transform.position.z);
                    }

                }
            }
            sortAllObjects ();
        }
    }

    public void sortAllObjects ()
    {
        //if (!dialogueScreenActive) {
        ArrayList allObs = new ArrayList ();
        ArrayList allLocs = new ArrayList ();

        ArrayList tiles = new ArrayList (),
        tileLocs = new ArrayList ();


        Location loc;
        Player p;

        for (int i = 0; i < battleMap.Roster.Count; i++)
        {
            p = (Player)battleMap.Roster[i];
            //print (p.SearchName + " at " + p.currentLocation ());
            allObs.Add (((Player)battleMap.Roster[i]).ShadowSprite);
            allObs.Add (((Player)battleMap.Roster[i]).MapSprite);
            allLocs.Add (((Player)battleMap.Roster[i]).currentLocation ());
            allLocs.Add (((Player)battleMap.Roster[i]).currentLocation ());
        }


        for (int i = 0; i < battleMap.Rows; i++)
        {
            for (int j = 0; j < battleMap.Columns; j++)
            {
                loc = new Location (i, j);

                if (battleMap.isValid (loc))
                {

                    if (battleMap.heightOf (loc) != 0)
                    {
                        //  print (loc + " Height " + battleMap.heightOf (loc));
                        tiles.Add (tileMap[i][j]);
                        tileLocs.Add (new Location (i, j));
                    }
                    if (battleMap.isEmpty (loc) || !battleMap.objectAt (loc).sentient ())
                    {
                        //if (battleMap.isEmpty (loc)) {
                        //  print (loc + " Empty");
                        //} else {
                        //  print (loc + " " + battleMap.objectAt (loc).mapName ());
                        //}
                        allObs.Add (miniMap[i][j]);
                        allLocs.Add (new Location (i, j));
                    }
                    if (!battleMap.isEmptyBenign (loc) || !battleMap.isEmptyInteractable (loc))
                    {
                        //if (!battleMap.isEmptyInteractable (loc)) {
                        //  print (loc + " " + battleMap.interactableAt (loc).SearchName);
                        //} else {
                        //  print (loc + " " + battleMap.benignAt (loc).SearchName);
                        //}
                        allObs.Add (interMap[i][j]);
                        allLocs.Add (new Location (i, j));
                    }
                }
                else
                {
                    //print (loc + " Not Valid");
                }
            }
        }

        RawImage[] imgs = new RawImage[allObs.Count];
        Location[] locs = new Location[imgs.Length];

        for (int i = 0; i < imgs.Length; i++)
        {
            imgs[i] = (RawImage)allObs[i];
            locs[i] = (Location)allLocs[i];
        }

        for (int i = 0; i < imgs.Length; i++)
        {
            InsertionSort (imgs, locs);
        }

        RawImage[] imgs2 = new RawImage[tiles.Count];
        Location[] locs2 = new Location[imgs.Length];

        for (int i = 0; i < imgs2.Length; i++)
        {
            imgs2[i] = (RawImage)tiles[i];
            locs2[i] = (Location)tileLocs[i];
        }

        for (int i = 0; i < imgs.Length; i++)
        {
            InsertionSort (imgs2, locs2);
        }

        Player pl;

        for (int i = 0; i < battleMap.Roster.Count; i++)
        {

            pl = (Player)battleMap.Roster[i];

            pl.MapSprite.transform.SetAsLastSibling ();

            if (pl.Equals (activePlayer))
            {
                playerHighlightIcon.transform.SetAsLastSibling ();
            }

            pl.HealthBarBackground.transform.SetAsLastSibling ();
            pl.HealthBar.transform.SetAsLastSibling ();
            pl.StatusIcon.transform.SetAsLastSibling ();


            if (pl.ShadowSprite.transform.GetSiblingIndex () >
                pl.MapSprite.transform.GetSiblingIndex ())
            {

                exchange (pl.ShadowSprite, pl.MapSprite);
            }

            if (pl.ShadowSprite.transform.GetSiblingIndex () ==
                pl.MapSprite.transform.GetSiblingIndex ())
            {
                throw new NullReferenceException ("COME ON MAN, I WAS CHECKING");
            }
        }

        stageFloor.transform.SetAsFirstSibling ();

        stageWings.transform.SetAsFirstSibling ();

        stageEffects.transform.SetAsFirstSibling ();

        for (int i = 0; i < notificationTexts.Count; i++)
        {
            if (((Notification)notificationTexts[i]).Info.transform.parent != null)
            {
                ((Notification)notificationTexts[i]).Info.transform.SetAsLastSibling ();
            }
        }

        timeText.transform.SetAsLastSibling ();

        if (matchOver)
        {
            setCanvas (outroCutsceneCanvas);
        }
    }

    public void InsertionSort (RawImage[] data, Location[] locs)
    {
        int i, j;
        int N = data.Length;

        for (j = 1; j < N; j++)
        {
            ///for (i=j; i>0 &&(locs [i].Row < locs [i-1].Row); i--) {
            /**
            for (i=j; i>0; i--) {

                if (locs [i].Row < locs [i-1].Row) {
                //print ("Switching " + data [i - 1].transform.GetSiblingIndex () + " up to " + data [i].transform.GetSiblingIndex ());
                    if (data [i - 1].texture != null) {
                        //print (data [i - 1].texture.name + " is first");
                    }
                    if (data [i].texture != null) {
                        //print (data [i].texture.name + " is last");
                    }

                    //print ("Switching " + data [i - 1].transform.GetSiblingIndex () + " up to " + data [i].transform.GetSiblingIndex ());

                    //exchange (data, locs, i, i - 1);
                }
            }
            */
        }
    }

    public void setCanvas (RawImage canv)
    {
        if (canv.enabled)
        {
            canv.transform.SetAsLastSibling ();

            for (int i = 0; i < canv.transform.childCount; i++)
            {
                if (canv.transform.GetChild (i).GetComponent<RawImage>() != null)
                {
                    canv.transform.GetChild (i).transform.SetAsLastSibling ();
                    if (canv.transform.GetChild (i).transform.childCount > 0)
                    {
                        setCanvas (canv.transform.GetChild (i).GetComponent<RawImage>());
                    }
                }
                if (canv.transform.GetChild (i).GetComponent<Text>() != null)
                {
                    canv.transform.GetChild (i).transform.SetAsLastSibling ();
                }
            }
        }

    }

    public void loadMap ()
    {
        battleMap.setTraps ();
        setTileMap ();
        setMiniMap ();
        setInterMap ();
        setProjMap ();

        stageFloor = stageFloor.GetComponent<RawImage>();
        stageFloor.texture = Resources.Load<Texture2D>(@"Maps/" + battleMap.SearchName + @"/Graphics/View");

        stageWings = stageWings.GetComponent<RawImage>();
        Texture2D text = Resources.Load<Texture2D>(@"Maps/" + battleMap.SearchName + @"/Graphics/BackgroundVertical");
        int height = text.height, width = text.width;

        stageEffectImages = new ArrayList ();
        for (int i = 0; i < battleMap.StageEffectLoops; i ++) {
            stageEffectImages.Add (Resources.Load<Texture2D> (@"Maps/" + battleMap.SearchName + @"/Graphics/Effect" + (i + 1)));
        }
        if (battleMap.StageEffectLoops >= 0) {
            stageEffects.texture = Resources.Load<Texture2D> (@"Maps/" + battleMap.SearchName + @"/Graphics/Effect1");
        } else {
            stageEffects.enabled = false;
        }

        stageWings.texture = text;
        mapHasChanged = true;
        updateMap ();
        updateMap (activePlayer);

        Skill s;
        Location l;

        for (int i = 0; i < battleMap.TrapsAdded.Count && battleMap.TrapsAdded.Count == battleMap.LocsAdded.Count; i++)
        {
            s = (Skill)battleMap.TrapsAdded[i];
            l = (Location)battleMap.LocsAdded[i];
            print (@"TRAP ADDED ---------->>>>> --------------- >>>> " + s.Name + " @" + l.ToString ());
        }
    }

    //SETS UP ALL PLAYER GRAPHICS
    public void setPlayerGraphicsAndAudio (Player p, int index)
    {
        p.VitalityTimer = 0.0f;
        p.StunTimer = 0.0f;

        p.InPlay = true;
        p.OnField = true;

        print (@"SETTING GRAPHICS AND AUDIO FOR " + p.FirstName.ToUpper ());

        p.StepTime = 0;
        p.StepTimeModulus = 0;


        p.MapSprite = cloneRawImage (@"Player " + p.FirstName + " " + p.MyTeam.Abbreviation + @" MapSprite",
            playerSprite1, gameCanvas.transform);
        p.ShadowSprite = cloneRawImage (@"Player " + p.FirstName + " " + p.MyTeam.Abbreviation + @" ShadowSprite",
            p.MapSprite, gameCanvas.transform);

        //if (!dialogueScreenActive) {
        p.ShadowSprite.transform.SetAsLastSibling ();
        p.MapSprite.transform.SetAsLastSibling ();
        //}

        p.MapSprite.enabled = true;
        p.ShadowSprite.enabled = true;

        p.MapSprite.color = Color.white;
        p.ShadowSprite.color = Color.black;

        if (battleMap.isValid (p.currentLocation ()))
        {
            displayMapPlayerGraphics (p, p.Row, p.Column);
        }

        //HIT SFX
        p.PlayerOutputIndexes = new ArrayList ();

        p.Index = playerIndex;
        p.Vocals.Speech = new GameObject ().AddComponent<AudioSource>();
        p.Vocals.ContactSound = new GameObject ().AddComponent<AudioSource>();

        p.Vocals.Speech.gameObject.name = p.FirstName + @" Speech Channel";
        p.Vocals.ContactSound.gameObject.name = p.FirstName + @" Contact Sound Channel";

        p.Vocals.ContactSound.volume = 2.0f;
        p.Vocals.Speech.volume = 0.7f;
        p.Experience = 0;

        p.MyReel.Frame = ProperOrientation (p);//GameObject ().AddComponent<RawImage>();

        /**
        //p.MyReel.Frame.transform.SetParent (gameCanvas.transform);

        //p.MyReel.Frame.gameObject.name = p.FirstName + " Sprite";


        p.MyReel.Frame.transform.SetParent (gameCanvas.transform);
        p.MyReel.Frame.transform.position = animation.transform.position;
        p.MyReel.Frame.enabled = false;
        */

        //DIALOGUE
        p.Vocals.Dialogue = new ArrayList ();

        //HEALTH DISPLAY

        p.HealthBar = cloneRawImage (p.FirstName + p.MyTeam.Abbreviation + @" Health",
                                     sampleHealthBar, gameCanvas.transform);//new GameObject ().AddComponent<RawImage>();

        p.HealthBarBackground = cloneRawImage (p.FirstName + p.MyTeam.Abbreviation + @" Health BG",
                             sampleHealthBar, gameCanvas.transform);//new GameObject ().AddComponent<RawImage>();

        p.HealthBar.enabled = true;

        p.HealthBarBackground.enabled = true;

        p.HealthBar.gameObject.name = p.FirstName + p.MyTeam.Abbreviation + @" Health";

        p.HealthBarBackground.gameObject.name = p.FirstName + p.MyTeam.Abbreviation + @" Health BG";


        p.HealthBar.texture = Resources.Load<Texture2D>(@"Textures/White");

        p.HealthBarBackground.texture = Resources.Load<Texture2D>(@"Textures/White");

        p.HealthBar.GetComponent<RectTransform>().sizeDelta = new Vector2(sampleHealthBar.rectTransform.sizeDelta.x * p.Health.MeterRatio, sampleHealthBar.rectTransform.sizeDelta.y + MapAdjustedHeight (p.currentLocation ().Row, p.currentLocation ().Column));

        p.HealthBarBackground.GetComponent<RectTransform>().sizeDelta = new Vector2(sampleHealthBar.rectTransform.sizeDelta.x, sampleHealthBar.rectTransform.sizeDelta.y + MapAdjustedHeight (p.currentLocation ().Row, p.currentLocation ().Column));

        p.HealthBar.transform.position = new Vector3(p.MapSprite.transform.position.x,
                                                      p.MapSprite.transform.position.y + 10, 0);

        p.HealthBarBackground.transform.position = new Vector3(p.MapSprite.transform.position.x,
                                              p.MapSprite.transform.position.y + 10, 0);

        p.HealthBarBackground.color = Color.black;

        p.HealthBarBackground.transform.SetAsLastSibling ();

        p.HealthBar.transform.SetAsLastSibling ();

        //

        float variant = targetHealthBarBackground.transform.localScale.y / 7;

        p.StatusIcon = cloneRawImage (p.FirstName + p.MyTeam.Abbreviation + @" Status",
                                     sampleHealthBar, gameCanvas.transform);//new GameObject ().AddComponent<RawImage>();

        p.StatusIcon.gameObject.name = p.FirstName + @"Status";

        //p.StatusIcon.transform.SetParent (p.MapSprite.transform);

        p.StatusIcon.GetComponent<RectTransform>().sizeDelta = new Vector2(15, 15);

        p.StatusIcon.enabled = true;

        p.StatusIcon.transform.position = new Vector3(p.MapSprite.transform.position.x,
                                              p.MapSprite.transform.position.y + 10, 0);

        //p.StatusIcon.transform.position = new Vector3 (0, 15, 0);

        p.SpriteScale = SPRITESCALERATIO;

        p.InfoFrame = targetInfoFrames[playerIndex];

        p.NameDisplay = targetNames[playerIndex];
        p.InfoPortrait = targetPortraits[playerIndex];
        p.InfoFrameBlurb = targetBasicInfos[playerIndex];
        p.ClassRatioInfo = targetClassRatios[playerIndex];

        p.InfoHealthBar = targetHealthBars[playerIndex];
        p.InfoHealthBarBack = targetHealthBarsBackground[playerIndex];
        p.InfoHealthBarEffect = targetHealthBarsEffected[playerIndex];

        p.InfoRushBar = targetRushBars[playerIndex];
        p.InfoRushBarBack = targetRushBarsBackground[playerIndex];
        p.InfoRushBarEffect = targetRushBarsEffected[playerIndex];

        p.InfoGuardBar = targetGuardBars[playerIndex];
        p.InfoGuardBarBack = targetGuardBarsBackground[playerIndex];
        p.InfoGuardBarEffect = targetGuardBarsEffected[playerIndex];

        p.InfoVitalityBar = targetVitalityBars[playerIndex];
        p.InfoVitalityBarBack = targetVitalityBarsBackground[playerIndex];
        p.InfoVitalityBarEffect = targetVitalityBarsEffected[playerIndex];

        p.InfoStunBar = targetStunBars[playerIndex];
        p.InfoStunBarBack = targetStunBarsBackground[playerIndex];
        p.InfoStunBarEffect = targetStunBarsEffected[playerIndex];

        p.InfoFrame.transform.position = new Vector3(0, 0, 0);

        p.Colors = new ArrayList () { Color.red, orange };

        playerIndex++;

        int teamIndex = p.MyTeam.playerIndex (p);

        print (p.NameAndTeam.ToUpper () + @" INDEX IS " + teamIndex);

        if (teamIndex >= 0)
        {
            if (p.MyTeam.Abbreviation.Equals ("1"))
            {
                p.TeamInfoDisplay = team1Names[teamIndex];
                p.TeamHealthBar = team1HealthBars[teamIndex];
                p.TeamHealthBarBackground = team1HealthBarBackgrounds[teamIndex];
                p.TeamRushBar = team1RushBars[teamIndex];
                p.TeamRushBarBackground = team1RushBarBackgrounds[teamIndex];
                p.TeamGuardBar = team1GuardBars[teamIndex];
                p.TeamGuardBarBackground = team1GuardBarBackgrounds[teamIndex];
                p.TeamVitalityBar = team1VitalityBars[teamIndex];
                p.TeamVitalityBarBackground = team1VitalityBarBackgrounds[teamIndex];
                p.TeamStunBar = team1StunBars[teamIndex];
                p.TeamSprite = team1TargetSprites[teamIndex];
                p.TeamTimer = 0.0f;
            }
            else if (p.MyTeam.Abbreviation.Equals ("2"))
            {
                p.TeamInfoDisplay = team2Names[teamIndex];
                p.TeamHealthBar = team2HealthBars[teamIndex];
                p.TeamHealthBarBackground = team2HealthBarBackgrounds[teamIndex];
                p.TeamRushBar = team2RushBars[teamIndex];
                p.TeamRushBarBackground = team2RushBarBackgrounds[teamIndex];
                p.TeamGuardBar = team2GuardBars[teamIndex];
                p.TeamGuardBarBackground = team2GuardBarBackgrounds[teamIndex];
                p.TeamVitalityBar = team2VitalityBars[teamIndex];
                p.TeamVitalityBarBackground = team2VitalityBarBackgrounds[teamIndex];
                p.TeamStunBar = team2StunBars[teamIndex];
                p.TeamSprite = team2TargetSprites[teamIndex];
                p.TeamTimer = 0.0f;
            }
            else
            {
                throw new NullReferenceException (p.NameAndTeam + @" AIN'T ON A TEAM!");
            }

            p.TeamInfoDisplay.enabled = true;
            p.TeamHealthBar.enabled = true;
            p.TeamHealthBarBackground.enabled = true;
            p.TeamRushBar.enabled = true;
            p.TeamRushBarBackground.enabled = true;
            p.TeamGuardBar.enabled = true;
            p.TeamGuardBarBackground.enabled = true;
            p.TeamVitalityBar.enabled = true;
            p.TeamVitalityBarBackground.enabled = true;
            p.TeamStunBar.enabled = true;
            p.TeamSprite.enabled = true;
            p.TeamSprite.texture = p.NeutralStance;

        }
        else
        {
            throw new NullReferenceException (p.Name + p.MyTeam.Abbreviation + @" IS A PROBLEM! " + teamIndex);
        }

        p.PaceCancelCooldownTimer = -1.0f;

        p.printAllSkillsOnOnePage ();

    }

    public void displayMapPlayerGraphics (Player p, int i, int j)
    {

        p.MapSprite.texture = ProperOrientation (p);

        //print (@"Setting next animation FOR THIS PLAYER " + p.Name + @" at " + p.MapSprite.texture.name + @" " + i + @" " + j);


        p.ShadowSprite.texture = p.MapSprite.texture;
        p.SpriteRatio = new int[] { p.MapSprite.texture.width, p.MapSprite.texture.height };

        if (!p.InMovement)
        {

            p.MapSprite.transform.position =
            new Vector3(originalMapPositions[i][j].x,
                         originalMapPositions[i][j].y + (p.Potency (p.Airborne) * 5),
                p.MapSprite.transform.position.z);
            p.ShadowSprite.transform.position =
            originalMapPositions[i][j];
        }

        if (p == activePlayer)
        {
            //focusCamera (p);
            int z;

            setArrows (p);

            timeText.transform.SetAsLastSibling ();
            timeText.transform.position = new Vector3(activePlayer.MapSprite.transform.position.x,
            activePlayer.MapSprite.transform.position.y, activePlayer.MapSprite.transform.position.z);

        }


        if (p.HealthBar != null)
        {
            //print (@"Health Bar " + p.HealthBar.name + " updated!");
            p.HealthBarBackground.transform.SetAsLastSibling ();
            p.HealthBar.transform.SetAsLastSibling ();
            //p.HealthBar.GetComponent<RectTransform> ().sizeDelta = new Vector2 ((sampleHealthBar.rectTransform.sizeDelta.x * p.Health.MeterRatioAppearance) * p.Ratio, sampleHealthBar.rectTransform.sizeDelta.y);
            p.HealthBar.color = teamColors (p);
            if (!p.StateActive (p.Invisible))
            {
                p.HealthBarBackground.color = Color.black;
            }
            else
            {
                p.HealthBarBackground.color = Color.clear;
            }
            p.HealthBar.transform.position = new Vector3(p.MapSprite.transform.position.x,
                                              p.MapSprite.transform.position.y + 10, 0);
            p.HealthBarBackground.transform.position = p.HealthBar.transform.position;
            //p.HealthBar.transform.position = new Vector3 (0, 10, 0);
        }

        if (p.StatusIcon != null)
        {
            p.StatusIcon.transform.SetAsLastSibling ();
            p.StatusIcon.transform.position = new Vector3(p.MapSprite.transform.position.x + (p.HealthBarBackground.rectTransform.sizeDelta.x / 3),
                                              p.MapSprite.transform.position.y, 0);

        }

        //print ("MAP PLAYER " + p.FirstName + " " + i + " " + j);
        //print (p.FirstName + " SETTING MAP SPRITE POSITION TO " + p.MapSprite.transform.position.x + " " + p.MapSprite.transform.position.y);

        adjustPlayerSpriteBasedOnScale (p);


        targetIcon.color = Color.clear;

        if (p.StateActive (p.Invisible))
        {
            p.MapSprite.enabled = false;
            /**
            p.MapSprite.color = Color.clear;
            p.ShadowSprite.color = Color.clear;
            p.HealthBar.color = Color.clear;
            p.StatusIcon.color = Color.clear;
            miniMap[i][j].color = Color.clear;
            */
            if (p.Equals (activePlayer))
            {
                playerHighlightIcon.color = Color.clear;
            }
        }
        else
        {
            p.MapSprite.enabled = true;

        }
    }

    public void adjustCamera ()
    {

    }

    public Texture2D ProperOrientation (Player p)
    {


        if (p.Direction.Contains ("W") || p.Direction.Equals ("N"))
        {
            p.MapSprite.rectTransform.rotation = new Quaternion (0, 180, 0, 0);
            p.ShadowSprite.rectTransform.rotation = new Quaternion (0, 180, 0, 0);
        }
        else
        {
            p.MapSprite.rectTransform.rotation = new Quaternion (0, 0, 0, 0);
            p.ShadowSprite.rectTransform.rotation = new Quaternion (0, 0, 0, 0);
        }

        return p.SpriteAppearance;
    }

    public Color teamColors (Player plr)
    {
        if (plr != null && plr.Invisible.IsActive)
        {
            return Color.clear;
        }
        if (activePlayer != null && activePlayer.StateActive (activePlayer.Confuse))
        {
            return Color.yellow;
        }
        if (plr.MyTeam.Equals (battleMap.Team1) || plr.MyTeam.Name.Contains ("1"))
        {
            if (chessMode && battleMap.Team1[0] == plr)
            {
                return orange;
            }
            return Color.red;
        }
        else if (plr.MyTeam.Equals (battleMap.Team2) || plr.MyTeam.Name.Contains ("2"))
        {
            if (chessMode && battleMap.Team2[0] == plr)
            {
                return purple;
            }
            return Color.blue;
        }
        return Color.white;
    }

    public void adjustPlayerSpriteBasedOnScale (Player p)
    {
        p.MapSprite.GetComponent<RectTransform>().sizeDelta = new Vector2(p.MapSprite.texture.width / SPRITESCALERATIO, p.MapSprite.texture.height / SPRITESCALERATIO);
        adjustShadow (p);

    }

    public void setArrows (Player p)
    {

        playerHighlightIcon.transform.position =
            new Vector3(p.MapSprite.transform.position.x,
                p.MapSprite.transform.position.y, 0);

        northArrow.transform.position = new Vector3(p.MapSprite.transform.position.x,
            p.MapSprite.transform.position.y + 5, 0);

        eastArrow.transform.position = new Vector3(p.MapSprite.transform.position.x + 20,
            p.MapSprite.transform.position.y, 0);

        southArrow.transform.position = new Vector3(p.MapSprite.transform.position.x,
            p.MapSprite.transform.position.y - 5, 0);

        westArrow.transform.position = new Vector3(p.MapSprite.transform.position.x - 20,
            p.MapSprite.transform.position.y, 0);

        northArrow.transform.SetAsLastSibling ();
        p.MapSprite.transform.SetAsLastSibling ();
        eastArrow.transform.SetAsLastSibling ();
        southArrow.transform.SetAsLastSibling ();
        westArrow.transform.SetAsLastSibling ();

        if (p.CanAct && p.MovesRemaining > 0 && skillSet.Count == 0)
        {

            if (p.StateActive (p.Invisible))
            {

                northArrow.color = Color.clear;
                eastArrow.color = Color.clear;
                southArrow.color = Color.clear;
                westArrow.color = Color.clear;

            }
            else if (p.MovesRemaining > 6)
            {

                northArrow.color = Color.white;
                eastArrow.color = Color.white;
                southArrow.color = Color.white;
                westArrow.color = Color.white;

            }
            else if (p.MovesRemaining == 6)
            {

                northArrow.color = purple;
                eastArrow.color = purple;
                southArrow.color = purple;
                westArrow.color = purple;

            }
            else if (p.MovesRemaining == 5)
            {

                northArrow.color = Color.blue;
                eastArrow.color = Color.blue;
                southArrow.color = Color.blue;
                westArrow.color = Color.blue;

            }
            else if (p.MovesRemaining == 4)
            {

                northArrow.color = Color.green;
                eastArrow.color = Color.green;
                southArrow.color = Color.green;
                westArrow.color = Color.green;

            }
            else if (p.MovesRemaining == 3)
            {

                northArrow.color = Color.yellow;
                eastArrow.color = Color.yellow;
                southArrow.color = Color.yellow;
                westArrow.color = Color.yellow;

            }
            else if (p.MovesRemaining == 2)
            {

                northArrow.color = orange;
                eastArrow.color = orange;
                southArrow.color = orange;
                westArrow.color = orange;

            }
            else if (p.MovesRemaining == 1)
            {

                northArrow.color = Color.red;
                eastArrow.color = Color.red;
                southArrow.color = Color.red;
                westArrow.color = Color.red;

            }

            if (!p.canWalk (p.currentLocation ().North))
            {

                northArrow.color = transparent (Color.white, 0.0f);
            }

            if (!p.canWalk (p.currentLocation ().East))
            {

                eastArrow.color = transparent (Color.white, 0.0f);
            }

            if (!p.canWalk (p.currentLocation ().South))
            {

                southArrow.color = transparent (Color.white, 0.0f);
            }

            if (!p.canWalk (p.currentLocation ().West))
            {

                westArrow.color = transparent (Color.white, 0.0f);
            }

        }
        else
        {

            northArrow.color = transparent (Color.white, 0.0f);

            eastArrow.color = transparent (Color.white, 0.0f);

            southArrow.color = transparent (Color.white, 0.0f);

            westArrow.color = transparent (Color.white, 0.0f);

        }
    }

    public void adjustShadow (Player p)
    {
        if (p.MapSprite == null)
        {
            throw new NullReferenceException (p.FirstName + @" Sprite null");
        }
        if (p.MapSprite.texture == null)
        {
            throw new NullReferenceException (@" Sprite text null");
        }
        if (p.ShadowSprite == null)
        {
            throw new NullReferenceException (@" Sprite shadow null");
        }
        if (p.ShadowSprite.texture == null)
        {
            throw new NullReferenceException (@" Sprite shadow text null");
        }

        p.ShadowSprite.GetComponent<RectTransform>().sizeDelta = new Vector2(p.MapSprite.texture.width / (SPRITESCALERATIO * 1.5f), p.MapSprite.texture.height / (SPRITESCALERATIO * 1.5f));
        if (p.ShadowSprite.transform.GetSiblingIndex () > p.MapSprite.transform.GetSiblingIndex ())
        {
            exchange (p.ShadowSprite, p.MapSprite);
        }
    }

    public Color transparent (Color p, float percent)
    {
        return new Color (p.r, p.g, p.b, percent);
    }

    public void exchange (RawImage a, RawImage b)
    {
        int temp = a.transform.GetSiblingIndex ();
        a.transform.SetSiblingIndex (b.transform.GetSiblingIndex ());
        b.transform.SetSiblingIndex (temp);
    }

    public void exchange (RawImage[] data, Location[] locs, int m, int n)
    {
        //RawImage temporary;
        RawImage temporary;
        Location tempLoc;

        exchange (data[m], data[n]);

        temporary = data[m];
        data[m] = data[n];
        data[n] = temporary;

        tempLoc = locs[m];
        locs[m] = locs[n];
        locs[n] = tempLoc;

    }

    public void checkSoundQueue ()
    {
        for (int i = 0; i < soundQueue.Count; i++)
        {
            if (!((AudioSource)soundQueue[i]).isPlaying)
            {
                Destroy (((AudioSource)soundQueue[i]).gameObject);

                soundQueue.Remove (soundQueue[i]);
                i--;
            }
        }
    }


    public void setHP(Player p, Boolean adjust)
    {
        if (adjust)
        {
            if (p.Equals (activePlayer))
            {
                playerHealthDisplay.text = p.Health.MeterLevelAppearance + @"/" + p.Health.MeterMax;
                playerHealthBar.GetComponent<RectTransform>().sizeDelta = new Vector2((playerHealthBarBackground.rectTransform.sizeDelta.x * p.Health.MeterRatioAppearance), playerHealthBarBackground.rectTransform.sizeDelta.y);
            }
            p.HealthBar.GetComponent<RectTransform>().sizeDelta = new Vector2((p.HealthBarBackground.rectTransform.sizeDelta.x * p.Health.MeterRatioAppearance), p.HealthBarBackground.rectTransform.sizeDelta.y);
            p.TeamHealthBar.GetComponent<RectTransform>().sizeDelta = new Vector2((p.TeamHealthBarBackground.rectTransform.sizeDelta.x * p.Health.MeterRatioAppearance), p.TeamHealthBarBackground.rectTransform.sizeDelta.y);
        }
        else
        {
            if (p.Equals (activePlayer))
            {
                playerHealthDisplay.text = p.Health.MeterLevel + @"/" + p.Health.MeterMax;
                playerHealthBar.GetComponent<RectTransform>().sizeDelta = new Vector2((playerHealthBarBackground.rectTransform.sizeDelta.x * p.Health.MeterRatio), playerHealthBarBackground.rectTransform.sizeDelta.y);
            }
            p.HealthBar.GetComponent<RectTransform>().sizeDelta = new Vector2((p.HealthBarBackground.rectTransform.sizeDelta.x * p.Health.MeterRatio), p.HealthBarBackground.rectTransform.sizeDelta.y);
            p.TeamHealthBar.GetComponent<RectTransform>().sizeDelta = new Vector2((p.TeamHealthBarBackground.rectTransform.sizeDelta.x * p.Health.MeterRatio), p.TeamHealthBarBackground.rectTransform.sizeDelta.y);
        }

        if (p.Equals (activePlayer) && skill != null && Math.Abs (skill.Cost[0]) <= p.Health.MeterLevel && skill.Cost[0] != 0)
        {
            if (adjust)
            {
                playerHealthBarSkill.GetComponent<RectTransform>().sizeDelta = new Vector2(playerHealthBarBackground.rectTransform.sizeDelta.x * p.Health.MeterRatioAppearance, playerHealthBarBackground.rectTransform.sizeDelta.y);
            }
            else
            {
                playerHealthBarSkill.GetComponent<RectTransform>().sizeDelta = new Vector2(playerHealthBarBackground.rectTransform.sizeDelta.x * p.Health.MeterRatio, playerHealthBarBackground.rectTransform.sizeDelta.y);
            }

        }
        else
        {
            playerHealthBarSkill.GetComponent<RectTransform>().sizeDelta = new Vector2 (0, playerHealthBarBackground.rectTransform.sizeDelta.y);

        }
    }

    public void checkHP(Player p)
    {
        if (p.CriticalAppearance || p.LastStand)
        {
            if (p.TeamTimer > 0.0f)
            {
                p.TeamTimer -= Time.deltaTime;
            }
            else
            {
                p.TeamTimer = FLASHTIMER * 2;


                if (p.TeamHealthBar.color.Equals (healthBarStandard (p)))
                {
                    p.TeamHealthBar.color = healthBarAlt (p);
                    if (p.Equals (activePlayer))
                    {
                        playerHealthBar.color = healthBarAlt (p);
                    }
                }
                else
                {
                    p.TeamHealthBar.color = healthBarStandard (p);
                    if (p.Equals (activePlayer))
                    {
                        playerHealthBar.color = healthBarStandard (p);
                    }
                }
            }
        }
        else
        {
            p.TeamHealthBar.color = healthBarStandard (p);
            if (p.Equals (activePlayer))
            {
                playerHealthBar.color = healthBarStandard (p);
            }
        }

    }

    public void setRM(Player p, Boolean adjust)
    {

        if (adjust)
        {
            if (p.Equals (activePlayer))
            {
                playerRushDisplay.text = p.Rush.MeterLevelAppearance + @"/" + p.Rush.MeterMax;
                playerRushBar.GetComponent<RectTransform>().sizeDelta = new Vector2(playerRushBarBackground.rectTransform.sizeDelta.x * p.Rush.MeterRatioAppearance, playerRushBarBackground.rectTransform.sizeDelta.y);
            }
            p.TeamRushBar.GetComponent<RectTransform>().sizeDelta = new Vector2(p.TeamRushBarBackground.rectTransform.sizeDelta.x * p.Rush.MeterRatioAppearance, p.TeamRushBarBackground.rectTransform.sizeDelta.y);

        }
        else
        {
            if (p.Equals (activePlayer))
            {
                playerRushDisplay.text = p.Rush.MeterLevel + @"/" + p.Rush.MeterMax;
                playerRushBar.GetComponent<RectTransform>().sizeDelta = new Vector2(playerRushBarBackground.rectTransform.sizeDelta.x * p.Rush.MeterRatio, playerRushBarBackground.rectTransform.sizeDelta.y);
            }
            p.TeamRushBar.GetComponent<RectTransform>().sizeDelta = new Vector2(p.TeamRushBarBackground.rectTransform.sizeDelta.x * p.Rush.MeterRatio, p.TeamRushBarBackground.rectTransform.sizeDelta.y);

        }

        if (p.Equals (activePlayer) && skill != null && Math.Abs (skill.Cost[1]) < activePlayer.Rush.MeterLevel && skill.Cost[1] != 0)
        {
            //print(playerRushBarBackground.rectTransform.sizeDelta.x * ((((float)p.Rush.MeterLevel) - ((float)Math.Abs(skill.Cost[1]))) / ((float)p.Rush.MeterMax)) + "/" + playerRushBarBackground.rectTransform.sizeDelta.x);
            playerRushBarSkill.GetComponent<RectTransform>().sizeDelta = new Vector2(playerRushBarBackground.rectTransform.sizeDelta.x * ((((float)p.Rush.MeterLevel) - ((float)Math.Abs (skill.Cost[1]))) / ((float)p.Rush.MeterMax)),
                playerRushBarBackground.rectTransform.sizeDelta.y);
        }
        else
        {
            playerRushBarSkill.GetComponent<RectTransform>().sizeDelta = new Vector2(0, playerRushBarBackground.rectTransform.sizeDelta.y);
        }
    }

    public void setGM(Player p, Boolean adjust)
    {
        if (adjust)
        {
            if (p.Equals (activePlayer))
            {
                playerGuardDisplay.text = p.Guard.MeterLevelAppearance + @"/" + p.Guard.MeterMax;
                playerGuardBar.GetComponent<RectTransform>().sizeDelta = new Vector2(playerGuardBarBackground.rectTransform.sizeDelta.x * p.Guard.MeterRatioAppearance, playerGuardBarBackground.rectTransform.sizeDelta.y);
            }
            p.TeamGuardBar.GetComponent<RectTransform>().sizeDelta = new Vector2(p.TeamGuardBarBackground.rectTransform.sizeDelta.x * p.Guard.MeterRatioAppearance, p.TeamGuardBarBackground.rectTransform.sizeDelta.y);

        }
        else
        {
            if (p.Equals (activePlayer))
            {
                playerGuardDisplay.text = p.Guard.MeterLevel + @"/" + p.Guard.MeterMax;
                playerGuardBar.GetComponent<RectTransform>().sizeDelta = new Vector2(playerGuardBarBackground.rectTransform.sizeDelta.x * p.Guard.MeterRatio, playerGuardBarBackground.rectTransform.sizeDelta.y);
            }
            p.TeamGuardBar.GetComponent<RectTransform>().sizeDelta = new Vector2(p.TeamGuardBarBackground.rectTransform.sizeDelta.x * p.Guard.MeterRatio, p.TeamGuardBarBackground.rectTransform.sizeDelta.y);
        }

        if (p.Equals (activePlayer) && skill != null && Math.Abs (skill.Cost[2]) < activePlayer.Guard.MeterLevel && skill.Cost[2] != 0)
        {
            playerGuardBarSkill.GetComponent<RectTransform>().sizeDelta = new Vector2(playerGuardBarBackground.rectTransform.sizeDelta.x * ((((float)p.Guard.MeterLevel) - ((float)Math.Abs (skill.Cost[2]))) / ((float)p.Guard.MeterMax)),
                playerGuardBarBackground.rectTransform.sizeDelta.y);
        }
        else
        {
            playerGuardBarSkill.GetComponent<RectTransform>().sizeDelta = new Vector2(0, playerGuardBarBackground.rectTransform.sizeDelta.y);

        }
    }

    public void setVM(Player p, Boolean adjust)
    {
        /**
        if (adjust)
        {
            if (p.Equals (activePlayer))
            {
                playerVitalityDisplay.text = p.Vitality.MeterLevelAppearance + @"/" + p.Vitality.MeterMax;
                playerVitalityBar.GetComponent<RectTransform>().sizeDelta = new Vector2(playerVitalityBarBackground.rectTransform.sizeDelta.x * p.Vitality.MeterRatioAppearance, playerVitalityBarBackground.rectTransform.sizeDelta.y);
            }
            p.TeamVitalityBar.GetComponent<RectTransform>().sizeDelta = new Vector2(p.TeamVitalityBarBackground.rectTransform.sizeDelta.x * p.Vitality.MeterRatioAppearance, p.TeamVitalityBarBackground.rectTransform.sizeDelta.y);

        }
        else
        {
        */
            if (p.Equals (activePlayer))
            {
                playerVitalityDisplay.text = p.Vitality.MeterLevel + @"/" + p.Vitality.MeterMax;
                playerVitalityBar.GetComponent<RectTransform>().sizeDelta = new Vector2(playerVitalityBarBackground.rectTransform.sizeDelta.x * p.Vitality.MeterRatio, playerVitalityBarBackground.rectTransform.sizeDelta.y);
            }
            p.TeamVitalityBar.GetComponent<RectTransform>().sizeDelta = new Vector2(p.TeamVitalityBarBackground.rectTransform.sizeDelta.x * p.Vitality.MeterRatio, p.TeamVitalityBarBackground.rectTransform.sizeDelta.y);
        //}

        if (p.Equals (activePlayer) && skill != null && skill.Cost[3] != 0)
        {
            playerVitalityBarSkill.GetComponent<RectTransform>().sizeDelta = new Vector2(playerVitalityBarBackground.rectTransform.sizeDelta.x * (((float)p.Vitality.MeterLevel) - ((float)Math.Abs (skill.Cost[3]))) / ((float)p.Vitality.MeterMax), playerVitalityBarBackground.rectTransform.sizeDelta.y);
        }
        else
        {
            playerVitalityBarSkill.GetComponent<RectTransform>().sizeDelta = new Vector2(0, playerVitalityBarBackground.rectTransform.sizeDelta.y);
        }
    }

    public void checkVM(Player p)
    {
        if (p.PlayStyleMeterPrimed)//(playerVitalityBarTimer != -5.0f)
        {
            if (p.VitalityTimer > 0.0f)
            {
                p.VitalityTimer -= Time.deltaTime;
            }
            else
            {
                p.VitalityTimer = FLASHTIMER;
                if (p.TeamVitalityBar.color.Equals (vitalityBarStandardColor))
                {
                    p.TeamVitalityBar.color = vitalityBarAltColor;
                    if (p.Equals (activePlayer))
                    {
                        playerVitalityBar.color = vitalityBarAltColor;
                    }
                }
                else
                {
                    p.TeamVitalityBar.color = vitalityBarStandardColor;
                    if (p.Equals (activePlayer))
                    {
                        playerVitalityBar.color = vitalityBarStandardColor;
                    }
                }
            }
        }
        else
        {
            p.TeamVitalityBar.color = vitalityBarStandardColor;
        }

    }

    public void setStun (Player p, Boolean adjust)
    {
        if (adjust)
        {
            if (p.Equals (activePlayer))
            {
                playerStunBar.GetComponent<RectTransform>().sizeDelta = new Vector2(playerStunBarBackground.rectTransform.sizeDelta.x * p.Stun.MeterRatioAppearance, playerStunBarBackground.rectTransform.sizeDelta.y);
            }
            p.TeamStunBar.GetComponent<RectTransform>().sizeDelta = new Vector2(t1P1StunBar.rectTransform.sizeDelta.x * p.Stun.MeterRatioAppearance, t1P1StunBar.rectTransform.sizeDelta.y);
        }
        else
        {
            if (p.Equals (activePlayer))
            {
                playerStunBar.GetComponent<RectTransform>().sizeDelta = new Vector2(playerStunBarBackground.rectTransform.sizeDelta.x * p.Stun.MeterRatio, playerStunBarBackground.rectTransform.sizeDelta.y);
            }
            p.TeamStunBar.GetComponent<RectTransform>().sizeDelta = new Vector2(t1P1StunBar.rectTransform.sizeDelta.x * p.Stun.MeterRatio, t1P1StunBar.rectTransform.sizeDelta.y);

        }
    }

    public void checkST(Player p)
    {
        if (p.Stun.MeterLevelAppearance > (4 * p.Stun.MeterMax) / 6)//if (playerStunBarTimer != -5.0f)
        {
            if (p.StunTimer > 0.0f)
            {
                p.StunTimer -= Time.deltaTime;
            }
            else
            {
                p.StunTimer = FLASHTIMER;
                if (p.TeamStunBar.color.Equals (stunBarStandardColor))
                {
                    p.TeamStunBar.color = stunBarAltColor;
                    if (p.Equals (activePlayer))
                    {
                        playerStunBar.color = stunBarAltColor;
                    }
                }
                else
                {
                    p.TeamStunBar.color = stunBarStandardColor;
                    if (p.Equals (activePlayer))
                    {
                        playerStunBar.color = stunBarStandardColor;
                    }
                }
            }
        }
        else
        {
            p.TeamStunBar.color = stunBarStandardColor;
            if (p.Equals (activePlayer))
            {
                playerStunBar.color = stunBarStandardColor;
            }
        }
    }

    public void setXP(Player p)
    {
        if (p.ExperienceDisplay > 0)
        {

            playerXPBar.GetComponent<RectTransform>().sizeDelta = new Vector2(playerXPBarBackground.rectTransform.sizeDelta.x * (((float)p.ExperienceDisplay) / ((float)p.ExperienceCheckpointDisplayInt)), playerXPBarBackground.rectTransform.sizeDelta.y);
            //print ("EXP " + ((double)p.ExperienceDisplay) + "/" + ((double)p.ExperienceCheckpointDisplayInt));

        }
        else
        {

            playerXPBar.GetComponent<RectTransform>().sizeDelta = new Vector2(0, playerXPBarBackground.rectTransform.sizeDelta.y);
            //print ("EXP 0/" + ((double)p.ExperienceCheckpointDisplayInt));

        }
    }

    public float MapAdjustedHeight (int i, int j)
    {
        return 5 * battleMap.heightOf (new Location (i, j));
    }

    public void setCanvas (RawImage canv, Boolean enabled)
    {
        canv.enabled = enabled;

        for (int i = 0; i < canv.transform.childCount; i++)
        {
            if (canv.transform.GetChild (i).GetComponent<RawImage>() != null)
            {
                canv.transform.GetChild (i).GetComponent<RawImage>().enabled = enabled;
                if (canv.transform.GetChild (i).transform.childCount > 0)
                {
                    setCanvas (canv.transform.GetChild (i).GetComponent<RawImage>(), enabled);
                }
            }
            if (canv.transform.GetChild (i).GetComponent<Text>() != null)
            {
                canv.transform.GetChild (i).GetComponent<Text>().enabled = enabled;
            }
        }

    }

    public Color healthBarStandard (Player p)
    {
        if (p != null)
        {
            if (p.StateActive (p.Poison))
            {
                return healthBarStandardPoison;
            }
            if (p.PlayStyle.Equals ("B"))
            {
                if (p.LastStand)
                {
                    return Color.red;
                }
            }
            if (p.Health.MeterLevel == p.Health.MeterMax)
            {
                return healthBarStandardColorMax;
            }
            if (p.Health.MeterRatio > 0.5f)
            {
                return healthBarStandardColor;
            }
            return healthBarStandardColorLow;
        }
        return Color.white;
    }

    public Color healthBarAlt (Player p)
    {
        if (p != null)
        {
            if (p.StateActive (p.Poison))
            {
                return healthBarAltPoison;
            }
            if (p.PlayStyle.Equals ("B"))
            {
                if (p.LastStand)
                {
                    return new Color (Color.red.r - 0.3f, Color.red.g, Color.red.b, 1f);
                }
            }
            if (p.Health.MeterLevel == p.Health.MeterMax)
            {
                return healthBarAltColorMax;
            }
            if (p.Health.MeterRatio > 0.5f)
            {
                return healthBarAltColor;
            }
            return healthBarAltColorLow;
        }
        return Color.black;
    }

    public void setPauseMenu (bool ble)
    {
        pauseMenu.enabled = ble;
        continueText.enabled = ble;
        stageSelectText.enabled = ble;
        playerSelectText.enabled = ble;
        quitText.enabled = ble;
        pauseMenuArt.enabled = ble;
        if (ble)
        {

            if (timerSFX.isPlaying)
            {
                timerSFX.Stop ();
            }

            continueText.color = highlightAvailableColor;
            stageSelectText.color = nonHighlightAvailableColor;
            playerSelectText.color = nonHighlightAvailableColor;
            quitText.color = nonHighlightAvailableColor;
            pauseOptions[0] = true;
            for (int i = 1; i < pauseOptions.Length; i++)
            {
                pauseOptions[i] = false;
            }
            bgm.volume /= 2.0f;
        }
        else
        {
            bgm.volume *= 2.0f;
        }
    }

    public void setConfirmMenu (bool ble)
    {
        confirmMenu.enabled = ble;
        confirmMenuArt.enabled = ble;
        yesText.enabled = ble;
        noText.enabled = ble;
        if (ble)
        {
            yesText.color = nonHighlightAvailableColor;
            noText.color = highlightAvailableColor;
            willExit = false;
        }
    }

    public void setHeightMap ()
    {
        for (int i = 0; i < battleMap.Rows; i++)
        {
            for (int j = 0; j < battleMap.Columns; j++)
            {
                if (battleMap.HeightMap[i][j] > 0)
                {
                    //print (i + " " + j + " HEIGHT: " + battleMap.HeightMap [i] [j]);

                    tileMap[i][j].enabled = true;

                    tileMap[i][j].GetComponent<RectTransform>().sizeDelta = new Vector2(squareScale, squareScale + MapAdjustedHeight (i, j));

                    //print ("SETTING TILE MAP TO " + tileMap[i]);

                    tileMap[i][j].color = Color.grey;
                    tileMap[i][j].texture = Resources.Load<Texture2D>(@"Maps/" + battleMap.SearchName + "/Graphics/tile");
                }
                else
                {
                    if (battleMap.HeightMap[i][j] < 0)
                    {

                        tileMap[i][j].GetComponent<RectTransform>().sizeDelta = new Vector2(squareScale, squareScale);

                        tileMap[i][j].enabled = true;
                        tileMap[i][j].color = Color.black;
                    }
                    else
                    {
                        tileMap[i][j].enabled = false;
                        tileMap[i][j].color = Color.clear;
                    }
                }
            }
        }
    }

    public Boolean NoRemainingNotifications
    {
        get
        {
            return notificationTexts.Count == 0;

        }
    }

    public Boolean NoRemainingAnimations
    {
        get
        {
            Player p;
            if (!NoPlayerInMotion)
            {
                return false;
            }
            for (int i = 0; i < battleMap.Roster.Count; i++)
            {
                p = (Player)battleMap.Roster[i];
                if (!p.MyReel.NoRemainingAnimations)
                {
                    return false;
                }
            }
            return true;
        }
    }

    public Boolean NoPlayerInMotion
    {
        get
        {
            for (int i = 0; i < battleMap.Roster.Count; i++)
            {
                if (((Player)battleMap.Roster[i]).InMovement)
                {
                    return false;
                }
            }
            return true;
        }
    }

    public Boolean PlayerInMotion
    {
        get
        {
            return activePlayer != null && activePlayer.InMovement;
        }
    }

    public void clearAnimations ()
    {
        Player pl;
        for (int i = 0; i < battleMap.Roster.Count; i++)
        {
            pl = ((Player)battleMap.Roster[i]);
            pl.Vocals.Clear ();
            pl.Destination = new Vector3(-1, -1, -1);
            pl.MovementIncrement = null;
            displayMapPlayerGraphics (pl, pl.currentLocation ().Row, pl.currentLocation ().Column);
            pl.Destinations = new ArrayList ();
            pl.MovementIncrements = new ArrayList ();
            pl.MovementTextures = new ArrayList ();
            pl.OriginalPositions = new ArrayList ();
            pl.CurrentAnimationTime = -1.0f;
            sortAllObjects ();
        }
        updateMap (activePlayer);
    }

    public void playCancelSound (string source)
    {
        cancelSFX.clip = Resources.Load<AudioClip>(@"Sounds/" + source);
        //print (cancelSFX.clip.name);
        cancelSFX.Play ();
    }

    public void setSkill (Skill s, int ind, ArrayList list)
    {
        if (skill != s || currentSkillIndex != ind)
        {
            mapHasChanged = true;

        }
        skill = s;
        currentSkillIndex = ind;
        if (s == null && ind != -1 && list != null)
        {
            //skill = (Skill)list [ind];
        }

        if (s != null)
        {
            /**
            if (s.Owner.currentMap () == null) {
                print (battleMap.Index + " " + battleMap.Rounds + " " + s.Name + " " + s.Owner.Name + " has no map");
                s.Owner.CurrentMap = battleMap;
            }
            */
            s.setLocations ();
        }

        if (ind == -1)
        {
            readingUserCommands = false;
            passiveTime = -1.1f;

            fullInputPrompt.enabled = false;
            inputImages.Clear ();
            inputPrompt.texture = null;
            inputPrompt.enabled = false;
            activePlayer.MyReel.Clear (false);

        }
        else
        {
            if (s != null)
            {

                if (s.Properties.Contains ("INVENTORY"))
                {
                    addAnimation (activePlayer,
                        "", animation.transform.position, s, @"Textures/Inventory/" + s.SearchName,
                        1, false, false, true, false, -1.5f, false, true);
                }
                else
                {
                    addAnimation (activePlayer,
                        "", animation.transform.position, s, "",
                        s.AnimationFrames, true, false, true, true, -1.5f, false, true);
                }
            }
        }
    }

    public int startingPoint (ArrayList lst)
    {
        for (int i = 0; i < lst.Count; i++)
        {
            if (((Skill)lst[i]).CostsAndConditionsMet)
            {
                return i;
            }
        }
        return -1;
    }

    public void updatePlayerInfo ()
    {
        if (activePlayer != null)
        {
            Location loc = null;

            for (int i = 0; i < skillInputs.Length; i++)
            {
                skillInputs[i].enabled = false;
                linkIcons[i].enabled = false;
                cancelIcons[i].enabled = false;
                counterIcons[i].enabled = false;
                actIcons[i].enabled = false;

                skillTexts[i].enabled = false;
                skillInfoTexts[i].enabled = false;
                skillTypeIcons[i].enabled = false;

            }

            if (skillSet == null || skillSet.Count == 0)
            {
                sideFrameText.text = activePlayer.InfoText;
                playerPopUpText.text = "";
                playerStatus.text = playerStatusAndCombos (activePlayer);
            }
            else
            {

                if (skill != null && (skillSet.Count > 0 || activePlayer.CanAct))
                {
                    playerPopUpText.text = displaySkillInfo ();
                    sideFrameText.text = displaySkillInfo ();
                }
                else
                {
                    playerPopUpText.text = "";
                    sideFrameText.text = "";
                }
                playerStatus.text = printSkillAndChains (currentSkillIndex);

            }

            Vector3 placementOnMap = new Vector3(-1, -1, -1);

            if (skillLocation == null || battleMap.playerAt (loc) == null)
            {
                placementOnMap = findObjectInMap (activePlayer);
                loc = activePlayer.currentLocation ();
            }
            else
            {
                placementOnMap = findObjectInMap (battleMap.playerAt (loc));
                loc = skillLocation;
            }

            int xMod = 0, yMod = 0;

            if (loc.Row > 4)
            {
                yMod = 170;
            }
            else
            {
                yMod = -170;
            }

            xMod = -200;

        }
    }

    public Vector3 findObjectInMap (Player p)
    {
        if (p != null)
        {
            for (int i = 0; i < battleMap.MapGrid.Length; i++)
            {
                for (int j = 0; j < battleMap.MapGrid[0].Length; j++)
                {
                    if (p.Equals (battleMap.playerAt (new Location (i, j))))
                    {
                        return miniMap[i][j].transform.position;
                    }
                }
            }
        }
        return new Vector3(0, 0, 0);
    }

    public string playerStatusAndCombos (Player p)
    {
        string output = "";

        output += @" " + '\n';

        if (p.CanAct)
        {
            if (p.setCostsAndConditionsMet (p.JumpSkills))
            { output += string.Format ("JUMPS: {0}" + '\n', UserJumpSet.ToString ()); }
            else
            { output += string.Format ("JUMPS: --" + '\n'); }

            if (p.setCostsAndConditionsMet (p.NormalSkills))
            { output += string.Format ("NORMALS: {0}" + '\n', UserNormalSet.ToString ()); }
            else
            { output += string.Format ("NORMALS: --" + '\n'); }

            if (p.setCostsAndConditionsMet (p.SpecialSkills))
            { output += string.Format ("SPECIALS: {0}" + '\n', UserSpecialSet.ToString ()); }
            else
            { output += string.Format ("SPECIALS: --" + '\n'); }

            if (p.setCostsAndConditionsMet (p.VitalitySkills))
            { output += string.Format ("VITALITY: {0}" + '\n', UserVitalitySet.ToString ()); }
            else
            { output += string.Format ("VITALITY: --" + '\n'); }

            if (p.setCostsAndConditionsMet (p.BurstSkills))
            { output += string.Format ("BURSTS: {0}" + '\n', UserBurstSet.ToString ()); }
            else
            { output += string.Format ("BURSTS: --" + '\n'); }

            if (p.setCostsAndConditionsMet (p.ItemSkills))
            { output += string.Format ("ITEMS: {0}" + '\n', UserItemSet.ToString ()); }
            else
            { output += string.Format ("NORMALS: --" + '\n'); }

            if (p.setCostsAndConditionsMet (p.MyTeam.Inventory))
            { output += string.Format ("INVENTORY: {0}" + '\n' + '\n', UserInventorySet.ToString ()); }
            else
            { output += string.Format ("INVENTORY: --" + '\n' + '\n'); }
        }
        output += string.Format ("STATE: {0}" + '\n', p.PlayerStates);
        /**
        if (p.PlayerStats.Length > 0)
        {
            output += string.Format ("STAT: {0}" + '\n', p.PlayerStats);
        }
        */

        if (p.LongestCombo.Count > 0)
        {
            output += string.Format ("CHAIN: ");

            int numCombos = 0;
            string comboText = "";
            for (int i = 0; i < p.LongestCombo.Count && i < 15; i++)
            {
                comboText = (string)p.LongestCombo[i];

                if (i != 0)
                {
                    if (numCombos > 1 || comboText.Length > 20)
                    {
                        output += string.Format (" " + '\n');
                        numCombos = 0;
                    }
                    if (p.LongestCombo.Count > i)
                    {
                        if (!comboText.Equals ("...") && !comboText.Contains ("*COUNTER*"))
                        {
                            output += string.Format (" --> ");
                        }
                    }
                }
                else
                {
                    output += string.Format ("   ");
                }

                output += string.Format (comboText);
                if (!comboText.Equals ("..."))
                {
                    numCombos++;
                }
            }
            output += string.Format ("" + '\n');

        }
        if (p.AttacksPerRound != 0)
        {
            output += string.Format ("DMG: {0} HP --- {1} / {2} HIT" + '\n',
                p.DamagePerRound, p.ConnectsPerRound, p.AttacksPerRound);
        }
        if (p.Combo > 0)
        {

            output += string.Format ("COM: {0} HP --- {1} HITS",
                p.ComboDamagePerRound, p.Combo);

            if (p.ComboDamagePerRound >= 5000)
            {
                output += string.Format (" - BROKEN!" + '\n');
            }
            else if (p.ComboDamagePerRound >= 4000)
            {
                output += string.Format (" - UNBELIEVABLE!" + '\n');
            }
            else if (p.ComboDamagePerRound >= 3000)
            {
                output += string.Format (" - AMAZING!" + '\n');
            }
            else if (p.ComboDamagePerRound >= 2000)
            {
                output += string.Format (" - EXCELLENT!" + '\n');
            }
            else if (p.ComboDamagePerRound >= 1000)
            {
                output += string.Format (" - NICE!" + '\n');
            }
            else
            {
                output += string.Format (" - " + '\n');
            }
        }
        if (p.StunPerRound != 0)
        {
            output += string.Format ("STN: {0} ST" + '\n', p.StunPerRound);
        }
        if (p.HealingPerRound != 0)
        {
            output += string.Format ("HEAL: {0} HP" + '\n', p.HealingPerRound, p.HealingTotal);
        }
        if (p.StatusAidsPerRound != 0 || p.StatusAfflictionsPerRound != 0)
        {
            output += string.Format ("STATUS (+, -): {0}, {1}" + '\n', p.StatusAidsPerRound, p.StatusAfflictionsPerRound);
        }
        if (p.Victories != 0)
        {
            output += string.Format ("KO: {0}" + '\n', p.Victories);
        }

        output += "" + '\n';
        return output;
        //}
    }

    public string printSkillAndChains (int ind)
    {
        string output = "" + '\n';
        Skill s;
        if (skillSet.Count > 0)
        {

            if (skillSet.Count > 5)
            {
                if (ind >= 3)
                {
                    output += "<<< MORE <<<" + '\n' + '\n';
                }
                else
                {
                    output += "" + '\n' + '\n';

                }
            }
            else
            {
                output += "" + '\n' + '\n';

            }

            int min = 0;

            if (ind == -1 || ind == 0 || ind == 1)
            {
                min = 0;
            }
            else if ((ind + 1) == skillSet.Count || (ind + 2) == skillSet.Count)
            {
                min = skillSet.Count - 5;
            }
            else
            {
                min = ind - 2;
            }

            for (int i = 0; i < skillInputs.Length; i++)
            {
                skillTexts[i].enabled = false;
                skillInfoTexts[i].enabled = false;
                skillInputs[i].enabled = false;
                linkIcons[i].enabled = false;
                cancelIcons[i].enabled = false;
                counterIcons[i].enabled = false;
                actIcons[i].enabled = false;
                skillTypeIcons[i].enabled = false;
            }

            for (int i = 0; i < 3; i++)
            {
                output += string.Format (" " + '\n' + '\n');

            }

            int max = 0;
            for (int i = 0; i < skillSet.Count && max < 5; i++)
            {

                s = (Skill)skillSet[i];

                if (i >= min)
                {


                    skillTexts[max].enabled = true;
                    skillInfoTexts[max].enabled = true;
                    skillInputs[max].enabled = true;
                    skillInputs[max].texture = ProperInput (s);
                    linkIcons[max].enabled = true;
                    cancelIcons[max].enabled = true;
                    counterIcons[max].enabled = true;
                    actIcons[max].enabled = true;
                    skillTypeIcons[max].enabled = true;

                    skillTexts[max].text = s.Name.ToUpper () + " ~" + s.Mastery;
                    skillInfoTexts[max].text = s.InfoText;
                    skillInfoTexts[max].color = skillTextColor (s);
                    if (s.NumUses >= 0)
                    {
                        skillTexts[max].text += string.Format (" (" + s.NumUses + ")");
                    }
                    else if (!s.NoConditions && !s.ExpendableAmmo.Equals ("N/A") && activePlayer.inventoryGet (s.ExpendableAmmo) != null)
                    {
                        skillTexts[max].text += string.Format (" (" +
                            activePlayer.inventoryGet (s.ExpendableAmmo).NumUses + ")");
                    }
                    skillTypeIcons[max].texture = Resources.Load<Texture2D>(@"Textures/Skill/" + s.Type);

                    linkIcons[max].color = Color.black;
                    cancelIcons[max].color = Color.black;
                    counterIcons[max].color = Color.black;
                    actIcons[max].color = Color.black;

                    if (s.CanCancel)
                    {
                        cancelIcons[max].color = lightPurple;
                    }
                    if (s.CanLink)
                    {
                        linkIcons[max].color = snowBlue;
                    }
                    if (s.Properties.Contains ("CTRFREE"))
                    {
                        counterIcons[max].color = Color.red;
                    }
                    if (s.CanAct)
                    {
                        actIcons[max].color = Color.green;
                    }

                    if (i != ind)
                    {
                        if (s.CostsAndConditionsMet)
                        {
                            skillInputs[max].color = Color.grey;
                            //output += string.Format ("{0} - {1}", i + 1, s.Name);
                        }
                        else
                        {
                            if (!s.LevelConditionsMet)
                            {
                                skillInputs[max].color = orange;
                            }
                            else if (!s.ConditionsMet)
                            {
                                skillInputs[max].color = purple;
                            }
                            else
                            {
                                skillInputs[max].color = Color.red;
                            }
                        }


                    }
                    else
                    {
                        skillTexts[max].text = ">" + s.Name.ToUpper () + " ~" + s.Mastery;
                        skillInfoTexts[max].text = s.InfoText;
                        skillInfoTexts[max].color = skillTextColor (s);
                        if (s.NumUses >= 0)
                        {
                            skillTexts[max].text += string.Format (" (" + s.NumUses + ")");
                        }
                        else if (!s.NoConditions && !s.ExpendableAmmo.Equals ("N/A") && activePlayer.inventoryGet (s.ExpendableAmmo) != null)
                        {
                            skillTexts[max].text += string.Format (" (" +
                                activePlayer.inventoryGet (s.ExpendableAmmo).NumUses + ")");
                        }



                        linkIcons[max].enabled = true;
                        cancelIcons[max].enabled = true;
                        counterIcons[max].enabled = true;
                        actIcons[max].enabled = true;


                        skillInputs[max].color = Color.white;

                        //output += string.Format ("------> {0} - {1} [{2}]", i + 1, s.Name, s.Type);

                        if (s.NumUses >= 0)
                        {
                            //  output += string.Format ("(" + s.NumUses + ")" + '\n');
                        }
                        else if (!s.NoConditions && !s.ExpendableAmmo.Equals ("N/A") && activePlayer.inventoryGet (s.ExpendableAmmo) != null)
                        {
                            //output += string.Format ("(" +
                            //activePlayer.inventoryGet (s.ExpendableAmmo).NumUses + ")" + '\n');
                        }
                        else
                        {
                            //output += string.Format ("" + '\n');
                        }
                    }

                    max++;
                }
            }

            if (skillSet.Count > 5)
            {
                if (ind < skillSet.Count - 3)
                {
                    output += "" + '\n' + '\n' + '\n' + ">>> MORE >>>" + '\n';
                }
            }

        }
        return output;
        //return "";
    }

    public Color skillTextColor (Skill s)
    {
        int highestPotency = 0;
        int correspondingIndex = -1;
        for (int i = 0; i < s.Elementals.Length; i++)
        {
            if (s.Elementals[i].Potency > highestPotency)
            {
                highestPotency = s.Elementals[i].Potency;
                correspondingIndex = i;
            }
        }

        if (correspondingIndex == -1)
        {
            return Color.black;
        }

        if (correspondingIndex == 0)
        {
            return fire;
        }

        if (correspondingIndex == 1)
        {
            return ice;
        }

        if (correspondingIndex == 2)
        {
            return electricity;
        }

        if (correspondingIndex == 3)
        {
            return wind;
        }

        if (correspondingIndex == 4)
        {
            return water;
        }

        if (correspondingIndex == 5)
        {
            return earth;
        }

        if (correspondingIndex == 6)
        {
            return metal;
        }

        if (correspondingIndex == 7)
        {
            return darkness;
        }

        if (correspondingIndex == 8)
        {
            return light;
        }

        if (correspondingIndex == 9)
        {
            return broken;
        }

        return Color.gray;
    }

    public void addAnimation (Player exec, string action, Vector3 position, Skill s, string path, int frames, Boolean play, Boolean loop, Boolean act, Boolean ani, float fade, Boolean cut, Boolean clear)
    {
        /**
        if (clear && exec.MyReel.NoRemainingAnimations) {
            exec.MyReel.Clear (act);
        }
        if (path != "") {
            print ("CHECKING ANIMATION PATH FOR " + path);
            exec.MyReel.AddReel ( new Reel (action, path,
                frames, play, loop, act, fade, ani, cut, true, position));

        } else {
            print ("CHECKING ANIMATION PATH FOR SKILL " + s.SearchName);

            exec.MyReel.AddReel ( new Reel (s.SearchName, @"Universal/Players/" + exec.SearchName + "/Animations/" + s.SearchName,
                frames, play, loop, act, fade, true, cut, true, animation.transform.position));              

        }
        */
    }

    public string displaySkillInfo ()
    {
        if (battleMap.isValid (skillLocation)
            && !battleMap.isEmpty (skillLocation)
            && battleMap.objectAt (skillLocation).sentient ()
            && skill.locationsContains (skillLocation)
            && skill.willConnectToTarget (battleMap.playerAt (skillLocation)))
        {

            return skill.infoOutput (battleMap.playerAt (skillLocation));
        }
        return skill.infoOutput (null);
    }

    public Texture2D ProperInput (Skill s)
    {
        if (s.Properties.Contains ("BURST "))
        {
            return superInput;
        }
        if (s.Inputs.Length == 0)
        {
            return noInput;
        }
        return Resources.Load<Texture2D>(@"Inputs/" + s.Inputs[0]);
    }

    public void determineSpecificSprite (Player p, RawImage sprite, ArrayList reel, float frame, int indx)
    {

        if (p != null)
        {
            reel.Clear ();
            sprite.enabled = true;

            reel.Add (ProperOrientation (p));

            sprite.texture = (Texture2D)reel[0];

            adjustPlayerSpriteBasedOnScale (p, sprite);

            frame = 0.0f;
            indx = 0;

            if (p.Equals (activePlayer) && activePlayer.Vitality.MeterLevel == activePlayer.Vitality.MeterMax
                && activePlayer.setCostsAndConditionsMet (activePlayer.BurstSkills))
            {
                //print ("It's over 9000!");
                if (!playerPowerUpSprite.enabled)
                {
                    playerPowerUpSprite.enabled = true;
                    playerPowerUpEffects.Clear ();
                    if (activePlayer.Element.Equals ("Fire"))
                    {
                        playerPowerUpEffects.Add (fireAura1);
                        playerPowerUpEffects.Add (fireAura2);
                        playerPowerUpEffects.Add (fireAura3);
                        playerPowerUpEffects.Add (fireAura4);
                    }
                    playerPowerUpSprite.texture = (Texture2D)playerPowerUpEffects[0];
                    powerUpReelFrame = 0.0f;
                    powerUpFrame = 0;
                }
            }
            else
            {
                if (p.Equals (activePlayer))
                {
                    playerPowerUpSprite.enabled = false;
                }
            }
        }
        else
        {
            sprite.enabled = false;
        }
    }

    public void determineAnimation ()
    {

    }

    public void adjustPlayerSpriteBasedOnScale (Player p, RawImage sprite)
    {
        sprite.GetComponent<RectTransform>().sizeDelta = new Vector2(sprite.texture.width / SPRITESCALERATIO, sprite.texture.height / SPRITESCALERATIO);
        adjustShadow (p);

    }

    public void displayPlayerAnimation (Player p, string path, int frames, string type)
    {

    }

    public void displayMapMovement (Player p, Location originLoc, int originHeight, Location newLoc, int newHeight, string path, int frames, Boolean over, Skill skl, string direct)
    {

        int destRow = newLoc.Row, destCol = newLoc.Column,
        oriRow = originLoc.Row, oriCol = originLoc.Column;

        Vector3 origin = p.MapSprite.transform.position;

        Vector3 dest = new Vector3(originalMapPositions[destRow][destCol].x,
            originalMapPositions[destRow][destCol].y + (newHeight * 5),
            0);

        MapVector movementIncrements = new MapVector (((origin.x - dest.x) / ((float)frames)) * -1,
            ((origin.y - dest.y) / ((float)frames)) * -1, frames);

        if (movementIncrements == null)
        {
            throw new NullReferenceException (@"ONLINE LAG MAN");
        }

        //print (p.Name + @" " + origin.x + @" X " + origin.y + @" Y ORIGIN");
        //print (p.Name + @" " + dest.x + @" Y " + dest.y + @" Y DESTINATION");

        if (((dest.x != origin.x) || (dest.y != origin.y)) || over || skl != null)
        {

            //print (movementIncrements);

            if (battleMap.isEmpty (originLoc))
            {
                miniMap[originLoc.Row][originLoc.Column].color = Color.clear;
            }

            p.Destinations.Add (dest);

            p.OriginalPositions.Add (origin);

            p.MovementIncrements.Add (movementIncrements);

            p.MovementDirections.Add (direct);

            if (path == @"")
            {
                p.MovementTextures.Add (p.SpriteRepresentation (skl.SearchName, direct));

                if (p.SpriteRepresentation (skl.SearchName, direct) == null)
                {
                    throw new NullReferenceException (p.FirstName + @" " + skl.SearchName + @" returns null");
                }

                if (p.Completed)
                {
                    print (p.SpriteRepresentation (skl.SearchName, direct).name + @" SpriteRepresentation is the graphical path, do the MAAAAAAAAAAAAAAAAAAAATH");
                }
            }
            else
            {
                p.MovementTextures.Add (p.SpriteOf (path, direct));
                if (p.Completed)
                {
                    print (p.SpriteOf (path, direct).name + @" SpriteOf (" + path + @") is the graphical path, do the MAAAAAAAAAAAAAAAAAAAATH");
                }
            }

            if (p.MovementIncrement == null)
            {
                p.MapSprite.texture = (Texture2D)p.MovementTextures[0];
                adjustPlayerSpriteBasedOnScale (p);
            }


            if (skl != null)
            {
                print (skl.SearchName + " IS NOT NULL -- ANIMATION MUST BE ACCURATE");
            }

            if (((dest.x != origin.x) || (dest.y != origin.y)))
            {

                p.CurrentAnimationTime = -5.0f;

            }
            else
            {

                if (p == skl.Owner)
                {
                    p.CurrentAnimationTime = (2 * skl.Speed) / 3.0f;
                }
                else
                {
                    p.CurrentAnimationTime = (2 * skl.HitStun) / 3.0f;
                }
            }

            print (((Texture2D)p.MovementTextures[0]).name + @", " + p.CurrentAnimationTime + @", " + p.currentLocation () + @" ADDED TO MATCH");
        }
    }

    void setNextPlayerAnimation (Player p)
    {
        string direct;
        if (p.MovementTextures.Count > 0 && p.CurrentAnimationTimes.Count > 0)
        {
            p.CurrentAnimationTime = (float)p.CurrentAnimationTimes[0];
            p.MapSprite.texture = (Texture2D)p.MovementTextures[0];
            direct = (string)p.MovementDirections[0];
            if (direct.Equals ("N") || direct.Contains ("W"))
            {
                p.MapSprite.rectTransform.rotation = new Quaternion (0, 180, 0, 0);
            }
            else
            {
                p.MapSprite.rectTransform.rotation = new Quaternion (0, 0, 0, 0);

            }

            p.MovementTextures.RemoveAt (0);
            p.CurrentAnimationTimes.RemoveAt (0);
            p.MovementDirections.RemoveAt (0);
            print ("Setting next animation FOR THIS PLAYER");
        }
        else
        {
            p.CurrentAnimationTime = -1.0f;
            displayMapPlayerGraphics (p, p.Row, p.Column);
            print ("Setting animation FOR THIS PLAYER");
        }
        if (NoPlayerInMotion)
        {
            updateMap (p);
        }
        adjustPlayerSpriteBasedOnScale (p);
        p.ShadowSprite.texture = p.MapSprite.texture;
        adjustShadow (p);
    }

    public void clearAnimations (Player pl)
    {
        pl.Vocals.Clear ();
        pl.Destination = new Vector3(-1, -1, -1);
        pl.MovementIncrement = null;
        displayMapPlayerGraphics (pl, pl.currentLocation ().Row, pl.currentLocation ().Column);
        pl.Destinations = new ArrayList ();
        pl.MovementIncrements = new ArrayList ();
        pl.MovementTextures = new ArrayList ();
        pl.OriginalPositions = new ArrayList ();
        pl.CurrentAnimationTime = -1.0f;

        updateMap (activePlayer);
    }

    public void updateMap ()
    {
        Location loc;
        for (int i = 0; i < battleMap.Rows; i++)
        {
            for (int j = 0; j < battleMap.Columns; j++)
            {

                loc = new Location (i, j);

                if (miniMap[i][j] == null)
                {
                    throw new NullReferenceException (i + @" " + j + @" is null");
                }

                if (battleMap.isEmpty (loc))
                {
                    miniMap[i][j].texture = neutralTexture;
                }
                else
                {
                    //miniMap [i] [j].texture = neutralTexture;
                }

                if (miniMap[i][j].texture == null || miniMap[i][j].texture.Equals (neutralTexture))
                {
                    miniMap[i][j].color = Color.clear;
                    miniMap[i][j].GetComponent<RectTransform>().sizeDelta = new Vector2(squareScale, squareScale);

                }
                updateInteractable (loc);
                updateProjectile (loc);



                if (interMap[i][j].enabled)
                {
                    interMap[i][j].transform.position =
                        miniMap[i][j].transform.position;
                }
                if (projMap[i][j].enabled)
                {
                    projMap[i][j].transform.position =
                    miniMap[i][j].transform.position;
                }
            }
        }
        sortAllObjects ();
    }

    public string switchLocations (Locatable obj, Locatable obj2, Skill s, Boolean reduceMovement, Boolean stepFalling, Boolean update, Boolean canBeHit)
    {
        string output = "";
        //output += string.Format ("{0} is switching with {1}." + '\n', obj.mapName (), obj2.mapName ());
        Location loc1 = new Location (obj.currentLocation ().Row, obj.currentLocation ().Column);
        Location loc2 = new Location (obj2.currentLocation ().Row, obj2.currentLocation ().Column);
        battleMap.MapGrid[loc1.Row][loc1.Column] = null;
        battleMap.MapGrid[loc2.Row][loc2.Column] = null;
        obj.changeLocation (loc2);
        obj2.changeLocation (loc1);
        if (obj.sentient ())
        {
            int hgt = ((Player)obj).Potency (((Player)obj).Airborne);
            output += recordMovement ((Player)obj, s, loc2, reduceMovement, stepFalling, false, update, true, canBeHit, loc1.DirectionOf (loc2));
            displayMapMovement ((Player)obj, loc1, hgt, ((Player)obj).currentLocation (), ((Player)obj).Potency (((Player)obj).Airborne),
                                "Neutral", 5, false, null, loc1.DirectionOf (obj));
        }
        else
        {
            output += obj.mapName () + " " + '\n';
            output += recordMovement (obj, loc2, stepFalling, update);
        }
        if (obj2.sentient ())
        {
            if (battleMap.isEmpty (loc1) || battleMap.objectAt (loc1).Equals (obj2))
            {
                int hgt = ((Player)obj).Potency (((Player)obj).Airborne);
                output += recordMovement ((Player)obj2, s, loc1, false, false, false, update, true, true, loc2.DirectionOf (loc1));
                displayMapMovement ((Player)obj2, loc2, hgt, ((Player)obj2).currentLocation (), ((Player)obj2).Potency (((Player)obj2).Airborne),
                                    "Neutral", 5, false, null, loc2.DirectionOf (obj2));

            }
            else
            {
                //output += loc1 + " is not empty" + '\n';
                Location openLoc = ((Player)obj2).openBorderOf (loc2, true, null);
                //print (openLoc);
                obj2.changeLocation (openLoc);
                output += recordMovement ((Player)obj2, s, openLoc,
                    false, false, false, update, false, canBeHit, "");
            }
        }
        else
        {
            output += obj2.mapName () + " " + '\n';
            output += recordMovement (obj2, loc1, false, update);
        }

        if (!trainingMode)
        {
            ((Player)obj).MovesRemaining--;
        }
        return output;
    }

    public string recordMovement (Locatable obj, Location loc, Boolean stepFalling, Boolean update)
    {
        string output = "";
        int fallDamage = 0;
        if (battleMap.Objects.Contains (obj) && battleMap.isValid (loc) && battleMap.isEmpty (loc))
        {
            output += battleMap.MapGrid[loc.Row][loc.Column];
            if (battleMap.isValid (obj.currentLocation ()))
            {
                battleMap.MapGrid[obj.currentLocation ().Row][obj.currentLocation ().Column] = null;

            }
            //mapHasChanged = true;

            obj.changeLocation (loc);
            battleMap.MapGrid[obj.currentLocation ().Row][obj.currentLocation ().Column] = obj;
        }

        if (update)
        {
            updateMap (activePlayer);
            updateActivePlayer ();
            determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
            determineAnimation ();
        }
        return output;
    }

    //KEEP
    public void updateActivePlayer ()
    {
        if (activePlayer != null)
        {
            updatePlayerInfo ();

            if (activePlayer.MyTeam.Name.Contains ("1"))
            {
                player1Text.color = broken;
                player2Text.color = metal;
            }
            else
            {

                player1Text.color = metal;
                player2Text.color = water;

            }


            playerPortrait.texture = activePlayer.Portrait;

            playerPortrait.color = teamColors (activePlayer);

            playerName.text = activePlayer.FirstName;
            playerStyle.text = activePlayer.StyleUIInfo;
            playerStyleRatio.text = activePlayer.PlayStyleActual + "" + activePlayer.Ratio;

            if (activePlayer.PlayStyle == "A")
            {

                playerName.color = Color.black;
                playerStyle.color = Color.black;

            }
            else if (activePlayer.PlayStyle == "B")
            {

                if (activePlayer.LastStand)
                {

                    playerName.color = broken;
                    playerStyle.color = broken;

                }
                else
                {

                    playerName.color = darkGrey;
                    playerStyle.color = darkGrey;

                }

            }
            else if (activePlayer.PlayStyle == "C")
            {

                playerName.color = purple;
                playerStyle.color = purple;


            }

            Location lc = activePlayer.currentLocation ();

            if (activePlayer.CanAct || skill != null)
            {
                if (activePlayer.CanAct)
                {
                    if (activePlayer.IsCrouching)
                    {
                        actionIndicator.color = lightPurple;
                    }
                    else
                    {
                        actionIndicator.color = Color.green;
                    }
                }
                else if (skill != null)
                {
                    actionIndicator.color = Color.yellow;
                }
                else
                {
                    actionIndicator.color = Color.red;
                }

                if (activePlayer.SActionEnabled && activePlayer.SActionSkill.CostsAndConditionsMet && activePlayer.Cooldown == 0)
                {
                    movementIndicator.color = Color.blue;
                }
                else
                {
                    if (activePlayer.SActionEnabled && activePlayer.SActionSkill.CostsAndConditionsMet && activePlayer.Cooldown != 0)
                    {
                        if (activePlayer.Cooldown >= 3)
                        {
                            movementIndicator.color = Color.red;
                        }
                        else if (activePlayer.Cooldown >= 3)
                        {
                            movementIndicator.color = orange;
                        }
                        else
                        {
                            movementIndicator.color = Color.yellow;
                        }
                    }
                    else
                    {
                        movementIndicator.color = Color.black;
                    }
                }

                if (activePlayer.Vitality.MeterLevel >= 200)
                {
                    jumpIndicator.color = lightPurple;
                }
                else
                {
                    jumpIndicator.color = Color.black;
                }
            }
            else
            {
                actionIndicator.color = Color.black;
                movementIndicator.color = Color.black;
                jumpIndicator.color = Color.black;
            }
        }
        setNextPlayers ();
    }

    public void setNextPlayers ()
    {
        int newIndex = battleMap.Index + 1;
        RawImage pImage;
        Player pl;
        for (int i = 0; i < nextPlayers.Count; i++)
        {
            pImage = (RawImage)nextPlayers[i];
            if (newIndex > battleMap.Roster.Count - 1)
            {
                newIndex = 1;
            }

            pl = (Player)battleMap.Roster[newIndex - 1];
            pImage.enabled = true;
            pImage.texture = ProperOrientation (pl);
            if (pl.KOd || !pl.OnField)
            {
                pImage.color = Color.black;
            }
            else
            {
                pImage.color = teamColors (pl);
            }
            newIndex++;
        }
    }

    public void checkText (Text t, string token)
    {
        if (getSkillOfType (token) > 0)
            t.color = appropriateColor ();
        else
            t.color = Color.clear;
    }

    public void checkText (Text t, ArrayList list)
    {
        if (activePlayer.setCostsAndConditionsMet (list))
            t.color = appropriateColor ();
        else
            t.color = Color.clear;
    }

    public void setInfoFramePriority (Player p, Boolean isTarget)
    {
        if (isTarget)
        {
            setCanvas (p.InfoFrame, true);
            p.InfoFrame.transform.SetAsLastSibling ();

            p.NameDisplay.transform.SetAsLastSibling ();
            p.InfoPortrait.transform.SetAsLastSibling ();
            p.InfoFrameBlurb.transform.SetAsLastSibling ();
            p.ClassRatioInfo.transform.SetAsLastSibling ();

            p.InfoHealthBarBack.transform.SetAsLastSibling ();
            p.InfoRushBarBack.transform.SetAsLastSibling ();
            p.InfoGuardBarBack.transform.SetAsLastSibling ();
            p.InfoVitalityBarBack.transform.SetAsLastSibling ();
            p.InfoStunBarBack.transform.SetAsLastSibling ();

            p.InfoHealthBar.transform.SetAsLastSibling ();
            p.InfoRushBar.transform.SetAsLastSibling ();
            p.InfoGuardBar.transform.SetAsLastSibling ();
            p.InfoVitalityBar.transform.SetAsLastSibling ();
            p.InfoStunBar.transform.SetAsLastSibling ();

            p.InfoHealthBarEffect.transform.SetAsLastSibling ();
            p.InfoRushBarEffect.transform.SetAsLastSibling ();
            p.InfoGuardBarEffect.transform.SetAsLastSibling ();
            p.InfoVitalityBarEffect.transform.SetAsLastSibling ();
            p.InfoStunBarEffect.transform.SetAsLastSibling ();

        }
        else
        {
            setCanvas (p.InfoFrame, false);
        }
    }

    public void updateTeamStats (Player p)
    {
        if (p.TeamInfoDisplay != null)
        {
            p.TeamInfoDisplay.text = p.FirstName + " " + p.PlayStyleActual + p.Ratio + "-LV" + p.Level;
            p.TeamSprite.texture = p.MapSprite.texture;

            if (skill != null && skill.locationsContains (p.CurrentLocation))
            {
                print (p.FirstName + @" in skill target location");
                p.TeamInfoDisplay.color = teamColors (p);

                if (skillLocation != null && battleMap.isValid (skillLocation)
                    && battleMap.playerAt (skillLocation) != null && battleMap.playerAt (skillLocation).Equals (p)
                    && !p.Confuse.IsActive)
                {
                    print (p.FirstName + @" targetted");
                    p.TeamInfoDisplay.color = Color.green;
                }

            }
            else
            {
                p.TeamSprite.color = Color.black;
                if (p.Equals (activePlayer))
                {
                    p.TeamInfoDisplay.color = purple;
                    p.TeamSprite.color = purple;
                }
                else
                {
                    p.TeamSprite.color = Color.black;
                    p.TeamInfoDisplay.color = Color.black;
                }

            }


            /**
            setInfoFramePriority (p, skillLocation != null && battleMap.isValid (skillLocation)
                && battleMap.playerAt (skillLocation) != null && battleMap.playerAt (skillLocation).Equals (p)
                && !p.Confuse.IsActive);
            */

            p.TeamHealthBar.GetComponent<RectTransform>().sizeDelta = new Vector2(p.TeamHealthBarBackground.rectTransform.sizeDelta.x * p.Health.MeterRatio, p.TeamHealthBarBackground.rectTransform.sizeDelta.y);
            //p.TeamHealthBar.color = Color.yellow;//teamColors (p);
            p.TeamRushBar.GetComponent<RectTransform>().sizeDelta = new Vector2(p.TeamRushBarBackground.rectTransform.sizeDelta.x * p.Rush.MeterRatio, p.TeamRushBarBackground.rectTransform.sizeDelta.y);
            p.TeamGuardBar.GetComponent<RectTransform>().sizeDelta = new Vector2(p.TeamGuardBarBackground.rectTransform.sizeDelta.x * p.Guard.MeterRatio, p.TeamGuardBarBackground.rectTransform.sizeDelta.y);
            p.TeamVitalityBar.GetComponent<RectTransform>().sizeDelta = new Vector2(p.TeamVitalityBar.rectTransform.sizeDelta.x * p.Vitality.MeterRatio, p.TeamVitalityBarBackground.rectTransform.sizeDelta.y);
            p.TeamStunBar.GetComponent<RectTransform>().sizeDelta = new Vector2(t1P1StunBar.rectTransform.sizeDelta.x * p.Stun.MeterRatio, t1P1StunBar.rectTransform.sizeDelta.y);


            /**
            if (p.Critical && !p.KOd)
            {
                p.TeamTimer = FLASHTIMER * 2;
            }
            else
            {
                hp.color = healthBarStandard (p);
                p.TeamTimer = -5.0f;
            }
            */
        }

    }

    public string recordMovement (Player p, Skill sk, Location loc, Boolean reduceMovement, Boolean stepFalling, Boolean noDamageDuringFall, Boolean update, Boolean zeroMovement, Boolean canBeHit, string direct)
    {
        print (string.Format ("@Recording movement: {0} from {1} to {2} -- Reduce:{3} Step:{4} NoDamage:{5} Update:{6} Zeroed:{7} Hit:{8} Direction:{9}",
            new object[] { p.NameAndTeam, p.currentLocation (), loc, reduceMovement, stepFalling, noDamageDuringFall, update, zeroMovement, canBeHit, direct }));
        if (sk != null)
        {
            print ("SKILL: " + sk.Name);
        }
        else
        {
            print ("NO SKILL");
        }
        string output = "";
        int fallDamage = 0;
        Skill s = null;

        Location originLoc = p.currentLocation ();
        int oldHeight = p.Potency (p.Airborne);

        if (p.currentLocation () != loc)
        {
            p.NumRests = 0;
            p.HasChangedLocations = true;
        }
        if (battleMap.Roster.Contains (p) && battleMap.isValid (loc) && battleMap.isEmpty (loc))
        {
            output += battleMap.MapGrid[loc.Row][loc.Column];

            if (battleMap.isValid (p.currentLocation ()))
            {
                battleMap.MapGrid[p.Row][p.Column] = null;

                if (originLoc != loc || loc.Height != p.Potency (p.Airborne))
                {
                    //mapHasChanged = true;
                }

                if (direct == "")
                {
                    p.Direction = "X";
                    if (p.isMostlyNorth (loc))
                    {
                        p.Direction = "E";
                    }
                    else if (p.isMostlySouth (loc))
                    {
                        p.Direction = "S";
                    }

                    if (p.isMostlyEast (loc))
                    {
                        p.Direction += "E";
                    }
                    else if (p.isMostlyWest (loc))
                    {
                        p.Direction += "W";
                    }
                }
                else
                {
                    p.Direction = direct;
                }

                if (battleMap.heightOf (p.currentLocation ()) != battleMap.heightOf (loc))
                {
                    if (p.StateActive (p.Airborne))
                    {
                        p.Airborne.Potency += (battleMap.heightOf (p.currentLocation ()) - battleMap.heightOf (loc));
                        if (p.FallingHeight != 0)
                        {
                            p.FallingHeight += (battleMap.heightOf (p.currentLocation ()) - battleMap.heightOf (loc));
                        }
                        if (p.Potency (p.Airborne) <= 0)
                        {
                            p.SetHeight (0);
                            output += p.Airborne.Name + " " + p.Potency (p.Airborne) + '\n';
                        }
                    }
                }

                if (battleMap.HeightMap[p.Row][p.Column] - battleMap.HeightMap[loc.Row][loc.Column] > p.LandingHeight)
                {

                    if (!noDamageDuringFall)
                    {
                        fallDamage = (-50 * Math.Abs (battleMap.HeightMap[p.Row][p.Column] - battleMap.HeightMap[loc.Row][loc.Column])) + p.Grit;
                        if (fallDamage > 0)
                        {
                            fallDamage = -1;
                        }
                    }
                }
            }

            if (reduceMovement && !trainingMode)
            {

                Boolean notNegativeAlready = p.MovesRemaining >= 0;
                p.MovesRemaining -= loc.span (p.currentLocation ());
                if (zeroMovement && p.MovesRemaining < 0 && notNegativeAlready)
                {
                    p.MovesRemaining = 0;
                }
            }

            p.changeLocation (loc);
            battleMap.MapGrid[p.Row][p.Column] = p;

            if (!p.KOd && ((battleMap.heightOf (loc) < 0 && battleMap.MapFall) || fallDamage < 0) && !p.Flight && !p.StateActive (p.Airborne))
            {
                if (!battleMap.MapFall)
                {
                    output += string.Format ("{0} falls! ({1})" + '\n', p.FirstName, p.LandingHeight);

                    createAnimationOnMap ("Earth", EnvironmentChannel, getImageFromLocation (p.currentLocation ()).transform.position, 2f, true);

                    //p.Vocals.ContactSound.clip = crashSound;
                    //p.Vocals.ContactSound.Play ();

                    p.Vocals.Speech.clip = Resources.Load<AudioClip>(@"Sounds/players/" + p.Sex.ToLower () + "damage");
                    p.Vocals.Speech.Play ();

                    if (fallDamage < 0)
                    {
                        output += shiftHealth (p, fallDamage, true, null, null);
                    }
                }
                else
                {
                    koPlayer (p, null, null, true);
                }
            }

            if (!battleMap.isEmptyInteractable (loc) && canBeHit)
            {
                battleMap.interactableAt (loc).CurrentLocation = loc;
                s = battleMap.interactableAt (loc);
                if (s.properHitSection (p)
                    && s.ThresholdMeasure > 0
                    && s.properAllegiance (p)
                    && s.CostsAndConditionsMet
                    //&& !s.Benign
                    && (!s.Properties.Contains (@"SPECPLY") || s.properPlayer (p, s.Properties.Substring (s.Properties.IndexOf ("&") + 1))))
                {
                    output += string.Format (@"{0} ({1}) IS ACTIVATED ON {2}!" + '\n', s.Name, s.ThresholdMeasure, p.FirstName);
                    output += executeSkill (battleMap.interactableAt (loc).Owner, battleMap.interactableAt (loc),
                        loc, loc.DirectionOf (p), true, false, !battleMap.interactableAt (loc).HasLinks, 1.0);
                    if (s.ThresholdMeasure == 0 || s.Properties.Contains ("REMOVE"))
                    {
                        battleMap.removeInteractable (battleMap.interactableAt (loc));
                    }
                }

                //TEST
                else
                {
                    if (!s.properHitSection (p))
                    {
                        print (s.Name + @" TRAP IS NOT PROPER HIT SECTION!");
                    }
                    if (s.ThresholdMeasure <= 0)
                    {
                        print (s.Name + @" TRAP THRESHOLD IS TOO LOW!");
                    }
                    if (!s.properAllegiance (p))
                    {
                        print (s.Name + @" TRAP ALLEGIANGE IS NOT CfORRECT!");
                    }
                    if (!s.CostsAndConditionsMet)
                    {
                        print (s.Name + @" TRAP COSTS AND CONDITIONS NOT MET!");
                    }

                }

            }
            else
            {
                if (battleMap.isEmptyInteractable (loc))
                {
                    print (loc.ToString () + @" IS EMPTY!");
                }
                if (!canBeHit)
                {
                    print (p.FirstName + @" CANNOT BE HIT!");
                }
            }

            if (!battleMap.isEmptyProjectile (loc) && canBeHit && activePlayer.currentLocation ().Equals (loc))
            {
                battleMap.projectileAt (loc).CurrentLocation = loc;
                s = battleMap.projectileAt (loc);
                if (s.properHitSection (p)
                    && s.ThresholdMeasure > 0
                    && s.properAllegiance (p)
                    && s.CostsAndConditionsMet
                    //&& !s.Benign
                    && (!s.Properties.Contains ("SPECPLY") || s.properPlayer (p, s.Properties.Substring (s.Properties.IndexOf ("&") + 1))))
                {
                    output += string.Format ("{0} ({1}) is activated on {2}!" + '\n', s.Name, s.ThresholdMeasure, p.FirstName);
                    output += executeSkill (battleMap.projectileAt (loc).Owner, battleMap.projectileAt (loc),
                    loc, loc.DirectionOf (p), true, false, !battleMap.projectileAt (loc).HasLinks, 1.0);
                    if (s.ThresholdMeasure == 0 || s.Properties.Contains ("REMOVE"))
                    {
                        battleMap.removeInteractable (battleMap.projectileAt (loc));
                    }
                }
            }


            Location trackLoc, oldLoc;
            Skill trackSkl;
            for (int i = 0; i < p.TrackSkills.Count; i++)
            {
                trackSkl = (Skill)p.TrackSkills[i];

                if (trackSkl.ThresholdMeasure < 1)
                {
                    battleMap.removeInteractable (trackSkl);
                    p.TrackSkills.Remove (trackSkl);
                    i--;
                }
                trackLoc = new Location (p.currentLocation ().Row + trackSkl.RowDifference,
                    p.currentLocation ().Column + trackSkl.ColumnDifference);

                if (trackSkl.TrackLocation == null)
                {
                    throw new DivideByZeroException ("AW GEEZ");
                }
                oldLoc = new Location (trackSkl.TrackLocation.Row, trackSkl.TrackLocation.Column);


                if (battleMap.isValid (trackLoc)
                    && battleMap.locationInHeightRange (trackLoc, trackSkl)
                    && battleMap.lineSkillCanReach (trackSkl, trackLoc))
                {

                    battleMap.ProjectileGrid[oldLoc.Row][oldLoc.Column] = null;
                    output += changeSkillLocation (trackSkl, trackLoc, ref i, p.TrackSkills);

                }
                else
                {
                    playAppropriateSound (hitSFX, trackSkl);
                    output += string.Format ("{0} ({1}) ceases to exist." + '\n', trackSkl.Name, trackSkl.Location);
                    battleMap.removeInteractable (trackSkl);
                    p.TrackSkills.Remove (trackSkl);
                    i--;
                }
            }
        }

        if (update)
        {
            updateMap (p);
            updateActivePlayer ();
            determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
            determineAnimation ();
        }

        return output;
    }

    public RawImage getImageFromLocation (Location loc)
    {
        if (battleMap.isValid (loc))
        {
            return miniMap[loc.Row][loc.Column];
        }
        return null;
    }

    public string changeSkillLocation (Skill skl, Location loc, ref int val, ArrayList list)
    {
        string output = @"";
        output += string.Format (@"{0} ({1}) object moving." + '\n', skl.Name, loc);
        print (@"--------------------MOVING " + skl.Name.ToUpper () + @" TO " + loc.ToString ());
        Skill trapInLoc;
        Player target = null;
        if (!battleMap.isEmpty (loc) && battleMap.objectAt (loc).sentient ())
        {
            target = (Player)battleMap.objectAt (loc);
            print (@"--------------------PLAYER " + target.Name.ToUpper () + " IN LOCATION");
            /**
             *             && !skl.Owner.mapHeightDifferenceTooLarge (skl, loc)
            && skl.willConnectToTarget ((Player)battleMap.objectAt (loc))) {

             */


            if (skl.Owner.mapHeightDifferenceTooLarge (skl, loc))
            {
                print (@"--------------------PLAYER " + target.Name.ToUpper () + @" HEIGHT DIFFERENCE TOO LARGE");
            }
            else
            {
                print (@"--------------------PLAYER " + target.Name.ToUpper () + @" HEIGHT DIFFERENCE IS CORRECT");
            }

            if (skl.willConnectToTarget (target))
            {
                print (@"--------------------SKILL " + skl.Name.ToUpper () + @" WILL CONNECT TO " + target.Name.ToUpper ());
            }
            else
            {
                print (@"--------------------SKILL " + skl.Name.ToUpper () + @" WILL NOT CONNECT TO " + target.Name.ToUpper ());
            }

        }

        if (battleMap.isEmptyInteractable (loc) && battleMap.isEmptyInteractable (loc))
        {
            print (@"--------------------EMPTY LOC ");
        }
        else
        {
            if (battleMap.interactableAt (loc) != null)
            {
                print (battleMap.interactableAt (loc).Name.ToUpper () + @" " + loc + @" IS IN LOC");
                if (!skl.sameHitSections (battleMap.interactableAt (loc)))
                {
                    print (@"SAME HIT SECTIONS ");
                    if (skl.Owner.skillHeightDifferenceTooLarge (skl, battleMap.interactableAt (loc)))
                    {
                        print (@"DIFFERENCE TOO LARGE ");
                    }
                }
            }
            else
            {
                print (battleMap.projectileAt (loc).Name.ToUpper () + @" " + loc + @" IS IN LOC");
                if (!skl.sameHitSections (battleMap.projectileAt (loc)))
                {
                    print (@"SAME HIT SECTIONS ");
                    if (skl.Owner.skillHeightDifferenceTooLarge (skl, battleMap.projectileAt (loc)))
                    {
                        print (@"DIFFERENCE TOO LARGE ");
                    }
                }
            }

        }

        //BENIGN
        if (skl.Benign)
        {
            //EMPTY LOCATION
            if (battleMap.isEmptyBenign (loc))
            {
                //EMPTY LOCATION
                skl.Location = loc;
                if (skl.TrackLocation != null)
                {
                    skl.TrackLocation = loc;
                }
                battleMap.BenignGrid[loc.Row][loc.Column] = skl;

                //CHECK HEIGHT CHANGE
                if (skl.Properties.Contains (@"ALONGGROUND") || skl.Properties.Contains (@"TRACK"))
                {
                    skl.CurrentHeight = battleMap.heightOf (loc);
                }
                output += string.Format (@"{0} (Benign) has successfully moved to {1} first time around." + '\n', skl.Name, skl.Location);
            }

        }

        //INTERACTIBLE IN LOCATION
        if (battleMap.isEmpty (loc)
            && !battleMap.isEmptyInteractable (loc)
            && !battleMap.interactableAt (loc).Owner.Equals (skl.Owner)
            && battleMap.interactableAt (loc).sameHitSections (skl))
        {

            output += @"OBJECT IN MOVEMENT LOCATION ";
            print (@"OBJECT IN MOVEMENT LOCATION ");
            trapInLoc = battleMap.interactableAt (loc);

            //OBJECT IN LOCATION HAS HIGHER THRESHOLD
            if ((trapInLoc.sameLevel (skl) && trapInLoc.ThresholdMeasure > skl.ThresholdMeasure)
                || trapInLoc.higherLevel (skl))
            {
                if (trapInLoc.sameLevel (skl))
                {
                    trapInLoc.ThresholdMeasure -= skl.ThresholdMeasure;
                }


                if (trapInLoc.Properties.Contains (@"REFLECT"))
                {
                    skl.Owner = trapInLoc.Owner;
                    output += " " + '\n';
                    output += string.Format (@"{0} is reflected!" + '\n', skl.Name);
                    createAnimationOnMap (@"Contact", EnvironmentChannel, getImageFromLocation (loc).transform.position, 1f, true);
                    skl.Direction = battleMap.oppositeDirection (skl.Direction);
                    output += executeSkill (skl.Owner, skl, skl.Owner.currentLocation (),
                      battleMap.oppositeDirection (skl.Direction), false, false, !skl.HasLinks, skl.Owner.CurrentProration);
                }
                else
                {
                    skl.ThresholdMeasure = 0;
                    output += string.Format (@"{0} is destroyed!" + '\n', skl.Name);
                    createAnimationOnMap (@"Contact", EnvironmentChannel, getImageFromLocation (loc).transform.position, 1f, true);
                    playAppropriateSound (skl.Owner.Vocals.ContactSound, skl);

                    if (list.Contains (skl))
                    {
                        val--;
                    }
                    battleMap.removeInteractable (skl);
                }
            }

            //NEW OBJECT HAS HIGHER THRESHOLD
            else if ((trapInLoc.sameLevel (skl) && trapInLoc.ThresholdMeasure < skl.ThresholdMeasure)
                || skl.higherLevel (trapInLoc))
            {
                output += string.Format (@"{0} is destroyed!" + '\n', trapInLoc.Name, loc);
                createAnimationOnMap ("Burn", EnvironmentChannel, getImageFromLocation (loc).transform.position, 1f, true);
                output += @" " + '\n';
                if (!skl.higherLevel (trapInLoc))
                {
                    skl.ThresholdMeasure -= trapInLoc.ThresholdMeasure;
                }
                playAppropriateSound (hitSFX, trapInLoc);

                if (list.Contains (trapInLoc))
                {
                    val--;
                }
                battleMap.removeInteractable (trapInLoc);


                skl.Location = loc;
                if (skl.TrackLocation != null)
                {
                    skl.TrackLocation = loc;
                }
                battleMap.InteractableGrid[loc.Row][loc.Column] = skl;
                skl.CurrentHeight = battleMap.heightOf (loc);
                //CHECK HEIGHT CHANGE
                if (skl.Properties.Contains (@"ALONGGROUND") || skl.Properties.Contains (@"TRACK"))
                {
                    skl.CurrentHeight = battleMap.heightOf (loc);
                }
                output += string.Format (@"{0} has successfully moved to {1}." + '\n', skl.Name, skl.Location);
            }

            //OBJECTS HAVE EQUAL THRESHOLDS
            else
            {

                output += string.Format (@"{0} is neutralised!" + '\n', trapInLoc.Name, loc);
                createAnimationOnMap ("Contact", EnvironmentChannel, getImageFromLocation (loc).transform.position, 1f, true);

                playAppropriateSound (skl.Owner.Vocals.ContactSound, skl);
                if (list.Contains (skl))
                {
                    val--;
                }

                if (list.Contains (trapInLoc))
                {
                    val--;
                }
                battleMap.removeInteractable (trapInLoc);
                battleMap.removeInteractable (skl);

            }
        }

        //PROJECTILE IN LOCATION
        if (battleMap.isEmpty (loc)
            && !battleMap.isEmptyProjectile (loc)
            && !battleMap.projectileAt (loc).Owner.Equals (skl.Owner)
            && battleMap.projectileAt (loc).sameHitSections (skl))
        {

            output += "OBJECT IN MOVEMENT LOCATION ";
            print ("OBJECT IN MOVEMENT LOCATION ");
            trapInLoc = battleMap.projectileAt (loc);

            //OBJECT IN LOCATION HAS HIGHER THRESHOLD
            if ((trapInLoc.sameLevel (skl) && trapInLoc.ThresholdMeasure > skl.ThresholdMeasure)
                || trapInLoc.higherLevel (skl))
            {
                if (trapInLoc.sameLevel (skl))
                {
                    trapInLoc.ThresholdMeasure -= skl.ThresholdMeasure;
                }


                if (trapInLoc.Properties.Contains ("REFLECT"))
                {
                    skl.Owner = trapInLoc.Owner;
                    output += " " + '\n';
                    output += string.Format ("{0} is reflected!" + '\n', skl.Name);
                    createAnimationOnMap ("Contact", EnvironmentChannel, getImageFromLocation (loc).transform.position, 1f, true);
                    skl.Direction = battleMap.oppositeDirection (skl.Direction);
                    output += executeSkill (skl.Owner, skl, skl.Owner.currentLocation (),
                      battleMap.oppositeDirection (skl.Direction), false, false, !skl.HasLinks, skl.Owner.CurrentProration);
                }
                else
                {
                    skl.ThresholdMeasure = 0;
                    output += string.Format ("{0} is destroyed!" + '\n', skl.Name);
                    createAnimationOnMap ("Contact", EnvironmentChannel, getImageFromLocation (loc).transform.position, 1f, true);
                    playAppropriateSound (skl.Owner.Vocals.ContactSound, skl);

                    if (list.Contains (skl))
                    {
                        val--;
                    }
                    battleMap.removeInteractable (skl);
                }
            }

            //NEW OBJECT HAS HIGHER THRESHOLD
            else if ((trapInLoc.sameLevel (skl) && trapInLoc.ThresholdMeasure < skl.ThresholdMeasure)
                || skl.higherLevel (trapInLoc))
            {
                output += string.Format ("{0} is destroyed!" + '\n', trapInLoc.Name, loc);
                createAnimationOnMap ("Burn", EnvironmentChannel, getImageFromLocation (loc).transform.position, 1f, true);
                output += " " + '\n';
                if (!skl.higherLevel (trapInLoc))
                {
                    skl.ThresholdMeasure -= trapInLoc.ThresholdMeasure;
                }
                playAppropriateSound (hitSFX, trapInLoc);

                if (list.Contains (trapInLoc))
                {
                    val--;
                }
                battleMap.removeInteractable (trapInLoc);


                skl.Location = loc;
                if (skl.TrackLocation != null)
                {
                    skl.TrackLocation = loc;
                }
                battleMap.ProjectileGrid[loc.Row][loc.Column] = skl;
                skl.CurrentHeight = battleMap.heightOf (loc);
                //CHECK HEIGHT CHANGE
                if (skl.Properties.Contains ("ALONGGROUND") || skl.Properties.Contains ("TRACK"))
                {
                    skl.CurrentHeight = battleMap.heightOf (loc);
                }
                output += string.Format ("{0} has successfully moved to {1}." + '\n', skl.Name, skl.Location);
            }

            //OBJECTS HAVE EQUAL THRESHOLDS
            else
            {

                output += string.Format ("{0} is neutralised!" + '\n', trapInLoc.Name, loc);
                createAnimationOnMap ("Contact", EnvironmentChannel, getImageFromLocation (loc).transform.position, 1f, true);

                playAppropriateSound (skl.Owner.Vocals.ContactSound, skl);
                if (list.Contains (skl))
                {
                    val--;
                }

                if (list.Contains (trapInLoc))
                {
                    val--;
                }
                battleMap.removeInteractable (trapInLoc);
                battleMap.removeInteractable (skl);

            }
        }


        //MAP OBJECT IN LOCATION
        else if (!battleMap.isEmpty (loc)
            && !battleMap.objectAt (loc).sentient ()
            && !skl.Owner.mapHeightDifferenceTooLarge (skl, loc))
        {

            print ("MAP OBJECT IN MOVEMENT LOCATION ");
            MapObject obj = (MapObject)battleMap.objectAt (loc);
            playAppropriateSound (skl.Owner.Vocals.ContactSound, skl);

            //SKILL HAS HIGHER THRESHOLD
            if (skl.ThresholdMeasure > obj.Strength ||
                (skl.SuperProjectile || skl.SForce))
            {

                output += string.Format ("{0} is destroyed!" + '\n', obj.Name);
                createAnimationOnMap ("Contact", EnvironmentChannel, getImageFromLocation (loc).transform.position, 1f, true);
                battleMap.removeObject (battleMap.objectAt (loc));
                if (skl.Projectile)
                {
                    skl.ThresholdMeasure -= obj.Strength;
                }

                skl.Location = loc;
                if (skl.TrackLocation != null)
                {
                    skl.TrackLocation = loc;
                }
                if (skl.Properties.Contains ("DIRECTION"))
                {
                    battleMap.ProjectileGrid[loc.Row][loc.Column] = skl;
                }
                else
                {
                    battleMap.InteractableGrid[loc.Row][loc.Column] = skl;
                }
                skl.CurrentHeight = battleMap.heightOf (loc);
                //CHECK HEIGHT CHANGE
                if (skl.Properties.Contains ("ALONGGROUND") || skl.Properties.Contains ("TRACK"))
                {
                    skl.CurrentHeight = battleMap.heightOf (loc);
                }
                output += string.Format ("{0} has successfully moved to {1}." + '\n', skl.Name, skl.Location);

                //OBJECT HAS HIGHER THRESHOLD
            }
            else if (obj.Strength > skl.ThresholdMeasure)
            {

                if (obj.Reflect)
                {

                    skl.Owner = obj.Owner;
                    output += " " + '\n';
                    output += string.Format ("{0} is reflected!" + '\n', skl.Name);
                    createAnimationOnMap ("Contact", EnvironmentChannel, getImageFromLocation (loc).transform.position, 1f, true);
                    skl.Direction = battleMap.oppositeDirection (skl.Direction);
                    output += executeSkill (skl.Owner, skl, skl.Owner.currentLocation (),
                      battleMap.oppositeDirection (skl.Direction), false, false, !skl.HasLinks, skl.Owner.CurrentProration);

                }
                else
                {
                    output += string.Format ("{0} is stopped by {1}!" + '\n', skl.Name, obj.Name);
                    createAnimationOnMap ("Contact", EnvironmentChannel, getImageFromLocation (loc).transform.position, 1f, true);
                    obj.Strength -= skl.ThresholdMeasure;

                    if (list.Contains (skl))
                    {
                        val--;
                    }
                    battleMap.removeInteractable (skl);
                }

                //EQUAL THRESHOLDS
            }
            else
            {
                output += string.Format ("{0} is neutralised by {1}!" + '\n', skl.Name, obj.Name);
                createAnimationOnMap ("Contact", EnvironmentChannel, getImageFromLocation (loc).transform.position, 1f, true);


                if (list.Contains (skl))
                {
                    val--;
                }
                battleMap.removeInteractable (skl);
                battleMap.removeObject (battleMap.objectAt (loc));
            }

        }

        //PLAYER IN LOCATION
        //else {
        else if (!battleMap.isEmpty (loc) &&
            battleMap.objectAt (loc).sentient ()
            && !skl.Owner.mapHeightDifferenceTooLarge (skl, loc)
            && skl.willConnectToTarget ((Player)battleMap.objectAt (loc)))
        {

            print ("PLAYER IN LOCATION ");
            target = (Player)battleMap.objectAt (loc);

            //output += string.Format ("Testing difference: " + (skl.CurrentHeight - battleMap.heightOf (loc)) + '\n');

            if (skl.willConnectToTarget (target)
                && !target.mapHeightDifferenceTooLarge (skl, loc)
                && skl.ThresholdMeasure > 0)
            {

                print ("PLAYER IN LOCATION ");
                output += string.Format ("{0} ({1}) is activated on contact!" + '\n', skl.Name, skl.ThresholdMeasure);
                output += executeSkill (skl.Owner, skl, loc, "", true, false, !skl.HasLinks, 1);
                output += string.Format ("{0}, {1} {2}" + '\n', skl.Name, skl.ThresholdMeasure, skl.NumUses);

                if (skl.ThresholdMeasure <= 0 || skl.NumUses == 0)
                {

                    if (list.Contains (skl))
                    {
                        val--;
                    }
                    battleMap.removeInteractable (skl);

                }
                else
                {
                    skl.Location = loc;
                    if (skl.TrackLocation != null)
                    {
                        skl.TrackLocation = loc;
                    }
                    if (skl.Properties.Contains ("DIRECTION"))
                    {
                        battleMap.ProjectileGrid[loc.Row][loc.Column] = skl;
                    }
                    else
                    {
                        battleMap.InteractableGrid[loc.Row][loc.Column] = skl;
                    }
                    skl.CurrentHeight = battleMap.heightOf (loc);
                    //CHECK HEIGHT CHANGE
                    if (skl.Properties.Contains ("ALONGGROUND") || skl.Properties.Contains ("TRACK"))
                    {
                        skl.CurrentHeight = battleMap.heightOf (loc);
                    }
                    output += string.Format ("{0} has successfully moved to {1}." + '\n', skl.Name, skl.Location);
                }
            }
            else
            {
                output += string.Format ("No contact." + '\n');
            }
        }
        else
        {
            //EMPTY LOCATION
            print (@"--------------------EMPTY");

            skl.Location = loc;
            if (skl.TrackLocation != null)
            {
                skl.TrackLocation = loc;
            }
            if (skl.Properties.Contains ("DIRECTION"))
            {
                battleMap.ProjectileGrid[loc.Row][loc.Column] = skl;
            }
            else
            {
                battleMap.InteractableGrid[loc.Row][loc.Column] = skl;
            }

            //CHECK HEIGHT CHANGE
            if (skl.Properties.Contains ("ALONGGROUND") || skl.Properties.Contains ("TRACK"))
            {
                skl.CurrentHeight = battleMap.heightOf (loc);
            }
            //output += string.Format ("{0} has successfully moved to {1} first time around." + '\n', skl.Name, skl.Location);
        }

        return output;
    }

    public void createAnimationOnMap (string path, ArrayList channel, Vector3 position, float scale, Boolean play)
    {
        if (play)
        {

            print ("CREATING ANIMATION " + path.ToUpper ());

            if (channel == null)
            {
                throw new NullReferenceException ("BALLS TO THE WALL");
            }
            for (int i = 0; i < channel.Count; i++)
            {
                if (!((AudioSource)channel[i]).isPlaying)
                {
                    print ("PLAYING " + path + i + " SOUNDS");
                    ((AudioSource)channel[i]).clip = Resources.Load<AudioClip>(@"Sounds/map/" + path);
                    ((AudioSource)channel[i]).volume = 0.7f;
                    ((AudioSource)channel[i]).Play ();
                    ((AudioSource)channel[i]).loop = false;
                    break;
                }
            }
        }

        //  active = true;
        Vector3 basePosition = new Vector3();

        basePosition = new Vector3(position.x, position.y, position.z);

        int numAnimations = 5;

        if (path.Equals ("Grapple") || path.Equals ("Projectile") || path.Equals ("Force") || path.Equals ("Hit") || path.Equals ("HitPhysical") || path.Equals ("Shock") || path.Equals ("Critical"))
        {
            numAnimations = 8;
        }
        else if (path.Equals ("HitMagic") || path.Equals ("LimitBreak"))
        {
            numAnimations = 12;
        }

        RawImage currentAnimationImage = null;

        currentAnimationImage = cloneRawImage (path + " @Map", animationTile, gameCanvas.transform);
        //currentAnimationImage.GetComponent <RectTransform> ().sizeDelta;

        Texture2D[] newAnimationBundle = new Texture2D[numAnimations];
        holderObjects.Insert (0, currentAnimationImage.gameObject);
        ((GameObject)holderObjects[0]).name = path + " @Map";
        ((GameObject)holderObjects[0]).transform.SetParent (gameCanvas.transform);
        ((GameObject)holderObjects[0]).transform.SetAsLastSibling ();
        currentAnimationImage.texture = Resources.Load<Texture2D>(@"Textures/Map/" + path + numAnimations);
        currentAnimationImage.transform.position = basePosition;
        print (currentAnimationImage.name);

        if (currentAnimationImage != null)
        {

            currentAnimationImage.GetComponent<RectTransform>().sizeDelta *= scale;
            //new Vector2 ((currentAnimationImage.texture.width / SPRITESCALERATIO) * scale, (currentAnimationImage.texture.height / SPRITESCALERATIO) * scale);

        }
        else
        {
            print ("No animation thingy");
        }
        Texture2D im;
        for (int i = 0; i < numAnimations; i++)
        {
            print ("Adding animation " + (i + 1) + " of " + path);
            im = Resources.Load<Texture2D>(@"Textures/Map/" + path + (i + 1));
            newAnimationBundle[i] = im;
        }
        mapAnimationImage.Add (currentAnimationImage);
        mapAnimationPosition.Add (basePosition);
        mapAnimationSize.Add (new Vector3(currentAnimationImage.GetComponent<RectTransform>().sizeDelta.x,
            currentAnimationImage.GetComponent<RectTransform>().sizeDelta.y, 0));

        mapAnimationIndex.Add (new DynamicInt ("", "", 0));
        mapAnimations.Add (newAnimationBundle);
        mapIndexLimits.Add (numAnimations);
        mapAnimationSpeed.Add (new DynamicFloat (POWERUPSPEED));
        //currentAnimationImage.enabled = false;
    }


    public Color appropriateColor ()
    {
        if (battleMap.Dark)
        {
            return Color.white;
        }
        if (battleMap.Light)
        {
            return Color.black;
        }
        if (battleMap.PrimaryTextColor == "blue")
        {
            return Color.blue;
        }
        if (battleMap.PrimaryTextColor == "red")
        {
            return Color.red;
        }
        if (battleMap.PrimaryTextColor == "green")
        {
            return Color.green;
        }
        return Color.black;
    }

    public void addToBattleLog (string text, Boolean reset)
    {
        //fullLog += text;
        if (reset)
        {
            //  battleLog.text = text;
        }
        else
        {
            //  battleLog.text += text;
        }
        new DataReader ().printOutputs (battleMap.Team1, battleMap.Team2, battleMap.SearchName, true, text);
    }

    public string checkContact (Player user, Player target, Skill s)
    {
        string output = @"";

        if (user != null
            && target != null
            && user != target
            && user.hasMadeContactWith (target, s)
            && user.ContactSkill.CostsAndConditionsMet)
        {
            output += "We've got a contact!" + '\n';
            user.ContactSkill.setLocations ();
            output += string.Format ("{0} makes contact with {1} and activates {2}!", target.NameAndTeam, user.FirstName, user.ContactSkill.Name);
            output += executeSkill (user, user.ContactSkill, target.currentLocation (), user.DirectionOf (target),
                true, false, true, 1.0);

            if (user.ContactSkill.NumUses == 0)
            {
                user.ContactSkill.NumUses = user.ContactSkill.MaxUses;
            }
            if (user.forget (user.ContactSkill.SearchName)) {
                addToNotificationQueue (s, user, "CONTACT!", true);
            } else {
                addToNotificationQueue (s, user, user.ContactSkill.Name.ToUpper (), true);
            }
        }
        else if (user == null)
        {
            output += "user is null!" + '\n';
        }
        else if (target == null)
        {
            output += "target is null!" + '\n';
        }
        else if (target == user)
        {
            output += "target is target!" + '\n';
        }
        else if (user.ContactSkill == null)
        {
            output += user.NameAndTeam + " contact skill is null!" + '\n';
        }
        else if (!user.ContactSkill.CostsAndConditionsMet)
        {
            if (!user.ContactSkill.CostsMet) { output += user.NameAndTeam + " " + user.ContactSkill.Name + " costs!" + '\n'; }

            if (!user.ContactSkill.LevelConditionsMet) { output += user.NameAndTeam + " " + user.ContactSkill.Name + " level conditions!" + '\n'; }
            if (!user.ContactSkill.ClassConditionsMet) { output += user.NameAndTeam + " " + user.ContactSkill.Name + " class conditions!" + '\n'; }
            if (!user.ContactSkill.AdleConditionsMet) { output += user.NameAndTeam + " " + user.ContactSkill.Name + " adle conditions!" + '\n'; }
            if (!user.ContactSkill.StatusConditionsMet) { output += user.NameAndTeam + " " + user.ContactSkill.Name + " status conditions!" + '\n'; }
            if (!user.ContactSkill.MovementConditionsMet) { output += user.NameAndTeam + " " + user.ContactSkill.Name + " movement conditions!" + '\n'; }
            if (!user.ContactSkill.PositionConditionsMet) { output += user.NameAndTeam + " " + user.ContactSkill.Name + " position conditions!" + '\n'; }
            if (!user.ContactSkill.ActionConditionsMet) { output += user.NameAndTeam + " " + user.ContactSkill.Name + " action conditions!" + '\n'; }
            if (!user.ContactSkill.LifeConditionsMet) { output += user.NameAndTeam + " " + user.ContactSkill.Name + " life conditions!" + '\n'; }
            if (!user.ContactSkill.MeterConditionsMet) { output += user.NameAndTeam + " " + user.ContactSkill.Name + " meter conditions!" + '\n'; }


            output += user.NameAndTeam + " " + user.ContactSkill.Name + " costs and conditions not met!" + '\n';
        }
        else {
            output += "Conditions not met!" + '\n';
        }

        return output;
    }

    public string recordWalk (Player pl, Location loc, Boolean reduceMovement, Boolean stepFalling, Boolean noDamageDuringFall)
    {
        string output = "";
        Location oldLoc = new Location (pl.currentLocation ().Row, pl.currentLocation ().Column, pl.currentLocation ().Height);
        int oldHeight = pl.Potency (pl.Airborne);
        Player target = battleMap.playerAt (loc);


        /**output += checkContact (pl, target, null);*/

        if (target != null)
        {
            string outp = "";
            outp += checkContact(pl, target, null);
            output += outp;

            if (outp.Contains("We've got a contact!"))
            { return output; }

            outp = checkContact(target, pl, null);
            output += outp;

            if (outp.Contains ("We've got a contact!"))
            { return output; }
        }

        if (pl.CanMove && loc != null && battleMap.isValid (loc))
        {
            print (string.Format (@"{0} attempting to walk to {1}!", pl.NameAndTeam, loc.ToString ()));

            if (pl.IsCrouching && !pl.StateActive (pl.Confuse) && !pl.Critical)
            {
                pl.IsCrouching = false;
            }
            if (battleMap.isEmpty (loc) && battleMap.canMakeMove (pl, loc) && pl.CanMove)
            {
                //walkSFX.Play ();
                print ("WALKING TO " + loc);

                output += shiftGuard (pl, -1 - Math.Abs (battleMap.heightOf (pl.currentLocation ()) - battleMap.heightOf (loc)), false, null);
                output += recordMovement (pl, null, loc, true, true, pl.Flight, false, true, true, "");

                displayMapMovement (pl, oldLoc, oldHeight, pl.currentLocation (), pl.Potency (pl.Airborne), "CrouchNeutral", 5, false, null, oldLoc.DirectionOf (loc));

                if (!firstMoveActivated && !pl.TimeStopped)
                {
                    startActiveTime ();
                }

            }

            else if (!battleMap.isEmpty (loc)
              && battleMap.objectAt (loc).sentient ()
              && (((Player)battleMap.objectAt (loc)).IsActive
                  || ((Player)battleMap.objectAt (loc)).StateActive (((Player)battleMap.objectAt (loc)).Invisible))
              && (((Player)battleMap.objectAt (loc)).sameTeam (pl)
                  || ((Player)battleMap.objectAt (loc)).StateActive (((Player)battleMap.objectAt (loc)).Invisible))
              && battleMap.canMakeMove (pl, loc))
            {
                walkSFX.Play ();
                print ("WALKING TO " + loc);

                output += shiftGuard (pl, -2 - Math.Abs (battleMap.heightOf (pl.currentLocation ()) - battleMap.heightOf (loc)), false, null);
                output += shiftGuard ((Player)battleMap.objectAt (loc), -2, false, null);

                output = switchLocations (pl, (Player)battleMap.objectAt (loc), null, true, true, false, true);

                if (!firstMoveActivated && !pl.TimeStopped)
                {
                    startActiveTime ();
                }

            }
            else if (!battleMap.isValid (loc))
            {
                output += string.Format (@"{0} is not valid.", loc);

            }
            else if (!battleMap.isEmpty (loc))
            {
                output += string.Format ("{2} is either recovering or defending and cannot move.",
                    pl.FirstName, loc, (battleMap.objectAt (loc).mapName ())) + '\n';
            }
            else
            {
                output += string.Format (@"{0} cannot make move.", pl.NameAndTeam);
            }
        }
        else
        {

        }

        updateActivePlayer ();

        updateMap (pl);
        updatePlayerInfo ();
        determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
        determineAnimation ();
        currentSkillInput.enabled = false;

        randomLocations[0] = pl.currentLocation ().North;
        randomLocations[1] = pl.currentLocation ().East;
        randomLocations[2] = pl.currentLocation ().South;
        randomLocations[3] = pl.currentLocation ().West;
        return output;
    }

    //TEST ADDED
    public void endTurn ()
    {
        /**
        for (int i = 0; i < battleMap.Roster.Count; i ++) {
            setCanvas (((Player)battleMap.Roster[i]).InfoFrame, false);
        }
        */
        activePlayer.MovesRemaining = 0;
        if (!activePlayer.InMovement)
        {
            displayMapPlayerGraphics (activePlayer, activePlayer.Row, activePlayer.Column);
        }
        activePlayer.CanAct = false;
        skillSet = new ArrayList ();
        setSkill (null, -1, null);
        skillLocation = null;

        if (activePlayer != null)
        {
            sideFrameText.text = activePlayer.BasicInfo;
        }
        currentSkillInput.enabled = false;
        fullInputPrompt.enabled = false;
        inputPrompt.enabled = false;
        if (finishTime > 0.0f || passiveTime > 0.0f)
        {
            battleMap.ActiveTime = 0.0f;
            finishTime = -0.1f;
            passiveTime = 0.0f;
            setActiveTimeMeter ();
            setFinishTimeMeter ();
            timerSFX.Stop ();
        }

        inputDelay = 1.2f;
        menuInputDelay = 1.2f;
        //battleMap.Sort ();

        sortAllObjects ();

    }

    public void setActiveTimeMeter ()
    {
        if (activePlayer.StateActive (activePlayer.Invisible) || !activePlayer.CanAct)
        {
            activeTimeMeter.GetComponent<RectTransform>().sizeDelta = new Vector2(0, sampleTimeBar.rectTransform.sizeDelta.y);
        }
        else
        {
            activeTimeMeter.color = lightGreen;
            if (((float)battleMap.ActiveTime) <= 6)
            {
                activeTimeMeter.color = darkRed;
                if (((float)battleMap.ActiveTime) <= 3)
                {
                    activeTimeMeter.color = purple;
                }
            }

            activeTimeMeter.GetComponent<RectTransform>().sizeDelta = new Vector2(sampleTimeBar.rectTransform.sizeDelta.x * ((float)battleMap.ActiveTime / (float)timeMax), sampleTimeBar.rectTransform.sizeDelta.y);

        }
    }

    public void setFinishTimeMeter ()
    {
        if (firstMoveActivated)
        {
            timeText.enabled = false;
        }

        if (activePlayer.CanAct || activePlayer.StateActive (activePlayer.Invisible))
        {

            finishTimeMeter.GetComponent<RectTransform>().sizeDelta = new Vector2(0, sampleTimeBar.rectTransform.sizeDelta.y);

        }
        else
        {

            finishTimeMeter.GetComponent<RectTransform>().sizeDelta = new Vector2(sampleTimeBar.rectTransform.sizeDelta.x * ((float)finishTime / (float)finishTimeMax), sampleTimeBar.rectTransform.sizeDelta.y);

        }
    }

    public void clearNotifications ()
    {
        skillOutputDelay = -1.0f;
        playerOutputs.Clear ();
        for (int i = 0; i < battleMap.Roster.Count; i++)
        {
            ((Player)battleMap.Roster[i]).MapOutputs.Clear ();
            ((Player)battleMap.Roster[i]).PlayerOutputIndexes.Clear ();
        }

        notificationTextTimer = -1.0f;

        for (int i = 0; i < notificationTexts.Count; i++)
        {
            Destroy (((Notification)notificationTexts[i]).Info);
        }

        notificationTexts = new ArrayList ();

        delayBetweenInputs = 0.0f;

        skillInfoDisplaying = false;

    }

    public void reduceInputDelays ()
    {
        if (inputDelay >= 0.0f)
        {
            inputDelay -= Time.deltaTime;
        }
        if (menuInputDelay >= 0.0f)
        {
            menuInputDelay -= Time.deltaTime;
        }
    }

    public void focusCamera (Player p)
    {
        if (p != null)
        {
            mainCamera.transform.SetParent (p.MapSprite.transform);
            mainCamera.transform.LookAt (p.MapSprite.transform);
        }
        else
        {
            mainCamera.transform.SetParent (gameCanvas.transform);
        }
    }

    public void updateCutsceneText (ref string text, ref Text textBox, ref int indx, ref Boolean dialoguing, ref int textCount)
    {
        if (dialoguing)
        {
            if (indx + 1 <= text.Length)
            {
                textTimer -= Time.deltaTime;
                if (textTimer < 0.0f)
                {
                    textCount++;

                    if (textCount > 20 && text[indx] == ' ')
                    {
                        textBox.text += "" + '\n';
                        textCount = 0;
                    }
                    else
                    {
                        textBox.text += text[indx];
                        textSFX.Play ();
                    }
                    textTimer = 0.05f;
                    indx++;
                }
            }
            else
            {
                textSFX.Stop ();
                dialoguing = false;
            }
        }
    }

    public Boolean MatchIsOver
    {
        get
        {
            return battleMap.Team1.IsDefeated || battleMap.Team2.IsDefeated;
        }
    }

    public void beginMatch ()
    {
        setCanvas (introCutsceneCanvas, false);
        setCanvas (outroCutsceneCanvas, false);

        p1EmoLooping = false;
        p2EmoLooping = false;
        inputDelay = 1.0f;
        menuInputDelay = 1.0f;
        readingSkillInputs = false;
        dialogueScreenActive = false;
        intro = false;
        bgm.Stop ();
        bgm.clip = battleMusic;
        playBGM();
        endTime = 5.0f;
        matchStarted = true;

        for (int i = 0; i < battleMap.Roster.Count; i++)
        {
            ((Player)battleMap.Roster[i]).MapSprite.texture = ProperOrientation ((Player)battleMap.Roster[i]);
        }

        stageWings.texture = Resources.Load<Texture2D>(@"Maps/" + battleMap.SearchName + "/Graphics/BackgroundVertical");
        announce ("playersready");
    }

    public void playBGM()
    {
        bgm.Play ();
    }

    public void announce (string tkn)
    {
        announcerSFX.clip = Resources.Load<AudioClip>(@"Sounds/announcer/" + tkn);
        announcerSFX.Play ();
    }

    public void updateIntroCutscene (Player p1, Player p2, int indx)
    {

        if (indx == 0)
        {
            if (!loadedFromDialogue)
            {
                introP1Sprite.texture = p1.SpriteAppearance;
                introP2Sprite.texture = p2.SpriteAppearance;
            }
            else
            {
                introP1Sprite.texture = p1.SpriteAppearance;
                introP2Sprite.texture = p2.SpriteAppearance;
                introP2Sprite.rectTransform.rotation = new Quaternion (0, 180, 0, 0);
            }
        }
        else
        {
            introP1Sprite.texture = p1.SpriteAppearance;
            introP2Sprite.texture = p2.SpriteAppearance;
            introP2Sprite.rectTransform.rotation = new Quaternion (0, 180, 0, 0);
        }

        introT1P1Info.color = appropriateColor ();
        introT1P2Info.color = appropriateColor ();
        introT1P3Info.color = appropriateColor ();
        introT1P4Info.color = appropriateColor ();
        introT2P1Info.color = appropriateColor ();
        introT2P2Info.color = appropriateColor ();
        introT2P3Info.color = appropriateColor ();
        introT2P4Info.color = appropriateColor ();


        introT1P1Info.text = battleMap.Team1[0].FirstName + ", " + battleMap.Team1[0].PlayStyleDisplay + ", R-" + battleMap.Team1[0].Ratio;
        adjustSpriteBasedOnTexture (introP1Sprite, p1OriginalPosition, 0.002f);

        introT2P1Info.text = battleMap.Team2[0].FirstName + ", " + battleMap.Team2[0].PlayStyleDisplay + ", R-" + battleMap.Team2[0].Ratio; ;
        adjustSpriteBasedOnTexture (introP2Sprite, p2OriginalPosition, 0.002f);

        if (battleMap.Team1.Roster.Count > 1)
        {
            introP1Sprite2.texture = battleMap.Team1[1].SpriteAppearance;
            introT1P2Info.text = battleMap.Team1[1].FirstName + ", " + battleMap.Team1[1].PlayStyleDisplay + ", R-" + battleMap.Team1[1].Ratio;
            adjustSpriteBasedOnTexture (introP1Sprite2, p1OriginalPosition, 0.002f);
        }
        else
        {
            introP1Sprite2.enabled = false;
        }
        if (battleMap.Team1.Roster.Count > 2)
        {
            introP1Sprite3.texture = battleMap.Team1[2].SpriteAppearance;
            introT1P3Info.text = battleMap.Team1[2].FirstName + ", " + battleMap.Team1[2].PlayStyleDisplay + ", R-" + battleMap.Team1[2].Ratio;
            adjustSpriteBasedOnTexture (introP1Sprite3, p1OriginalPosition, 0.002f);
        }
        else
        {
            introP1Sprite3.enabled = false;
        }
        if (battleMap.Team1.Roster.Count > 3)
        {
            introP1Sprite4.texture = battleMap.Team1[3].SpriteAppearance;
            introT1P4Info.text = battleMap.Team1[3].FirstName + ", " + battleMap.Team1[3].PlayStyleDisplay + ", R-" + battleMap.Team1[3].Ratio;
            adjustSpriteBasedOnTexture (introP1Sprite4, p1OriginalPosition, 0.002f);
        }
        else
        {
            introP1Sprite4.enabled = false;
        }

        if (battleMap.Team2.Roster.Count > 1)
        {
            introP2Sprite2.texture = battleMap.Team2[1].SpriteAppearance;
            introP2Sprite2.rectTransform.rotation = new Quaternion (0, 180, 0, 0);
            introT2P2Info.text = battleMap.Team2[1].FirstName + ", " + battleMap.Team2[1].PlayStyleDisplay + ", R-" + battleMap.Team2[1].Ratio;
            adjustSpriteBasedOnTexture (introP2Sprite2, p1OriginalPosition, 0.002f);
        }
        else
        {
            introP2Sprite2.enabled = false;
        }
        if (battleMap.Team2.Roster.Count > 2)
        {
            introP2Sprite3.texture = battleMap.Team2[2].SpriteAppearance;
            introP2Sprite3.rectTransform.rotation = new Quaternion (0, 180, 0, 0);
            introT2P3Info.text = battleMap.Team2[2].FirstName + ", " + battleMap.Team2[2].PlayStyleDisplay + ", R-" + battleMap.Team2[2].Ratio; ;
            adjustSpriteBasedOnTexture (introP2Sprite3, p2OriginalPosition, 0.002f);
        }
        else
        {
            introP2Sprite3.enabled = false;
        }
        if (battleMap.Team2.Roster.Count > 3)
        {
            introP2Sprite4.texture = battleMap.Team2[3].SpriteAppearance;
            introP2Sprite4.rectTransform.rotation = new Quaternion (0, 180, 0, 0);
            introT2P4Info.text = battleMap.Team2[3].FirstName + ", " + battleMap.Team2[3].PlayStyleDisplay + ", R-" + battleMap.Team2[3].Ratio; ;
            adjustSpriteBasedOnTexture (introP2Sprite4, p1OriginalPosition, 0.002f);
        }
        else
        {
            introP2Sprite4.enabled = false;
        }


        p1EmoReel = new ArrayList ();
        p1EmoReel.Add (fireAura1);
        p1EmoReel.Add (fireAura2);
        p1EmoReel.Add (fireAura3);
        p1EmoReel.Add (fireAura4);

        p2EmoReel = new ArrayList ();
        p2EmoReel.Add (fireAura1);
        p2EmoReel.Add (fireAura2);
        p2EmoReel.Add (fireAura3);
        p2EmoReel.Add (fireAura4);

        if (dialogue.Count > 0)
        {
            if (((string)dialogue[0]).Contains (battleMap.Team1.Representative.SearchName)
                || ((string)dialogue[0]).Contains ("mirror1:"))
            {
                introP1Portrait.color = Color.red;
                introP1Sprite.color = Color.white;
                introP2Sprite.color = Color.gray;

                introP1Portrait.texture = p1.Portrait;

                introP1Emo.enabled = true;
                introP2Emo.enabled = false;
                p1Dialoguing = true;
                p2Dialoguing = false;
                p1EmoLooping = true;
                p2EmoLooping = false;
                introP1Dialogue = ((string)dialogue[0]).Substring (((string)dialogue[0]).IndexOf (':') + 1);
                p1DialogueIndex = 0;
                p2DialogueIndex = 0;
                introPlayerText.text = p1.FirstName + ": ";

                introPlayerText.color = Color.red;
            }
            if (((string)dialogue[0]).Contains (battleMap.Team2.Representative.SearchName)
                || ((string)dialogue[0]).Contains ("mirror2:"))
            {
                introP1Sprite.color = Color.gray;
                introP2Portrait.color = Color.blue;
                introP2Sprite.color = Color.white;

                introP2Portrait.texture = p2.Portrait;

                introP2Emo.enabled = true;
                introP1Emo.enabled = false;
                p2Dialoguing = true;
                p1Dialoguing = false;
                p2EmoLooping = true;
                p1EmoLooping = false;
                introP2Dialogue = ((string)dialogue[0]).Substring (((string)dialogue[0]).IndexOf (':') + 1);
                p2DialogueIndex = 0;
                p1DialogueIndex = 0;
                introPlayerText.text = p2.FirstName + ": ";

                introPlayerText.color = Color.white;
            }
            textCount = ((string)dialogue[0]).IndexOf (':') + 1;
            dialogue.RemoveAt (0);
            textTimer = 0.2f;
            inputDelay = 1.0f;
            menuInputDelay = 1.0f;
            //textCount = 0;
        }
        else
        {
            beginMatch ();
        }
    }

    public void updateOutroCutscene ()
    {

        outroP1Sprite.texture = battleMap.Team1.Representative.SpriteAppearance;
        outroP2Sprite.texture = battleMap.Team2.Representative.SpriteAppearance;
        outroP2Sprite.rectTransform.rotation = new Quaternion (0, 180, 0, 0);


        adjustSpriteBasedOnTexture (outroP1Sprite, p1OriginalPosition, 0.002f);
        adjustSpriteBasedOnTexture (outroP2Sprite, p2OriginalPosition, 0.002f);

        if (battleMap.Team1.Roster.Count > 1)
        {
            outroP1Sprite2.texture = ((Player)battleMap.Team1.NonRepresentative[0]).SpriteAppearance;
            adjustSpriteBasedOnTexture (outroP1Sprite2, p1OriginalPosition, 0.002f);
        }
        else
        {
            outroP1Sprite2.enabled = false;
        }
        if (battleMap.Team1.Roster.Count > 3)
        {
            outroP1Sprite3.texture = ((Player)battleMap.Team1.NonRepresentative[2]).SpriteAppearance;
            adjustSpriteBasedOnTexture (outroP1Sprite3, p1OriginalPosition, 0.002f);
        }
        else
        {
            outroP1Sprite3.enabled = false;
        }
        if (battleMap.Team1.Roster.Count > 2)
        {
            outroP1Sprite4.texture = ((Player)battleMap.Team1.NonRepresentative[1]).SpriteAppearance;
            adjustSpriteBasedOnTexture (outroP1Sprite4, p1OriginalPosition, 0.002f);
        }
        else
        {
            outroP1Sprite4.enabled = false;
        }

        if (battleMap.Team2.Roster.Count > 1)
        {
            outroP2Sprite2.texture = ((Player)battleMap.Team2.NonRepresentative[0]).SpriteAppearance;
            outroP2Sprite2.rectTransform.rotation = new Quaternion (0, 180, 0, 0);
            adjustSpriteBasedOnTexture (outroP2Sprite2, p2OriginalPosition, 0.002f);
        }
        else
        {
            outroP2Sprite2.enabled = false;
        }
        if (battleMap.Team2.Roster.Count > 3)
        {
            outroP2Sprite3.texture = ((Player)battleMap.Team2.NonRepresentative[2]).SpriteAppearance;
            outroP2Sprite3.rectTransform.rotation = new Quaternion (0, 180, 0, 0);
            adjustSpriteBasedOnTexture (outroP2Sprite3, p2OriginalPosition, 0.002f);
        }
        else
        {
            outroP2Sprite3.enabled = false;
        }
        if (battleMap.Team2.Roster.Count > 2)
        {
            outroP2Sprite4.texture = ((Player)battleMap.Team2.NonRepresentative[1]).SpriteAppearance;
            outroP2Sprite4.rectTransform.rotation = new Quaternion (0, 180, 0, 0);
            adjustSpriteBasedOnTexture (outroP2Sprite4, p2OriginalPosition, 0.002f);
        }
        else
        {
            outroP2Sprite4.enabled = false;
        }

        p1EmoReel = new ArrayList ();
        p1EmoReel.Add (fireAura1);
        p1EmoReel.Add (fireAura2);
        p1EmoReel.Add (fireAura3);
        p1EmoReel.Add (fireAura4);


        p2EmoReel = new ArrayList ();
        p2EmoReel.Add (fireAura1);
        p2EmoReel.Add (fireAura2);
        p2EmoReel.Add (fireAura3);
        p2EmoReel.Add (fireAura4);

        outroP1Portrait.texture = battleMap.Team1.Representative.Portrait;
        outroP2Portrait.texture = battleMap.Team2.Representative.Portrait;
        outroP2Portrait.rectTransform.rotation = new Quaternion (0, 180, 0, 0);



        if (dialogue.Count > 0)
        {
            if (((string)dialogue[0]).Contains (battleMap.Team1.Representative.SearchName)
                || ((string)dialogue[0]).Contains ("mirror1:"))
            {
                outroP1Portrait.color = Color.red;
                outroP1Sprite.color = Color.white;
                outroP2Portrait.color = Color.gray;
                outroP2Sprite.color = Color.gray;
                outroP2Sprite2.color = Color.gray;
                outroP2Sprite3.color = Color.gray;
                outroP2Sprite4.color = Color.gray;

                outroP1Emo.enabled = true;
                outroP2Emo.enabled = false;
                p1Dialoguing = true;
                p2Dialoguing = false;
                p1EmoLooping = true;
                p2EmoLooping = false;
                outroWinnerDialogue = ((string)dialogue[0]).Substring (((string)dialogue[0]).IndexOf (':') + 1);
                p1DialogueIndex = 0;
                p2DialogueIndex = 0;
                outroWinnerText.text = battleMap.Team1.Representative.FirstName + ": ";

                outroWinnerText.color = Color.red;
            }
            if (((string)dialogue[0]).Contains (battleMap.Team2.Representative.SearchName)
                || ((string)dialogue[0]).Contains ("mirror2:"))
            {

                outroP1Portrait.color = Color.gray;
                outroP1Sprite.color = Color.gray;
                outroP1Sprite2.color = Color.gray;
                outroP1Sprite3.color = Color.gray;
                outroP1Sprite4.color = Color.gray;
                outroP2Portrait.color = Color.blue;
                outroP2Sprite.color = Color.white;
                outroP2Emo.enabled = true;
                outroP1Emo.enabled = false;
                p2Dialoguing = true;
                p1Dialoguing = false;
                p2EmoLooping = true;
                p1EmoLooping = false;
                outroWinnerDialogue = ((string)dialogue[0]).Substring (((string)dialogue[0]).IndexOf (':') + 1);
                p2DialogueIndex = 0;
                p1DialogueIndex = 0;
                outroWinnerText.text = battleMap.Team2.Representative.FirstName + ": ";

                outroWinnerText.color = Color.white;

            }
            textCount = ((string)dialogue[0]).IndexOf (':') + 1;
            dialogue.RemoveAt (0);
            textTimer = 0.2f;
            inputDelay = 1.0f;
            menuInputDelay = 1.0f;
        }
        else
        {

        }
    }

    public void adjustSpriteBasedOnTexture (RawImage img, Vector3 originalPosition, float scale)
    {
        img.GetComponent<RectTransform>().sizeDelta = new Vector2(img.texture.width / SPRITESCALERATIO, img.texture.height / SPRITESCALERATIO);
    }

    public void cycleColorAndStatus (Player p)
    {
        if (!p.StateActive (p.Invisible))
        {
            if (skill != null && skill.locationsContains (p.currentLocation ()) && skill.properHitSection (p))
            {

                if (p.IsDefending)
                {
                    p.StatusIcon.texture = textureShield;
                }
                else if (p.IsTaunting)
                {
                    p.StatusIcon.texture = textureTaunt;
                }
                else if (p.IsResting)
                {
                    p.StatusIcon.texture = textureRest;
                }
                else
                {
                    if (skill.Malicious)
                    {
                        p.StatusIcon.texture = textureMalicious;
                    }
                    else if (skill.Beneficial)
                    {
                        p.StatusIcon.texture = textureBeneficial;
                    }
                    else
                    {
                        p.StatusIcon.texture = textureNeutral;
                    }
                }

                p.StatusIconTimer -= Time.deltaTime;
                if (p.StatusIconTimer < 0)
                {
                    p.StatusIconTimer = 0.15f;
                    if (p.StatusIcon.color.Equals (teamColors (p)))
                    {
                        p.StatusIcon.color = Color.green;
                        p.TeamSprite.color = Color.green;

                    }
                    else
                    {
                        p.StatusIcon.color = teamColors (p);
                        p.TeamSprite.color = teamColors (p);
                    }
                }
            }
            else
            {
                p.StatusIcon.color = Color.clear;
            }

            if (p.KOd)
            {
                p.ColorIndex = -1;
                p.MapSprite.color = teamColors (p);
                p.ColorTimer = 0f;

            }
            else if (p.AvailableColors.Count > 0 || p.ColorsMet > 0)
            {
                p.ColorTimer -= Time.deltaTime;
                if (p.ColorTimer < 0.0f)
                {

                    p.ColorTimer = COLORCHANGESPEED;

                    if (p.ColorsMet == 0)
                    {
                        p.MapSprite.color = Color.white;
                    }

                    Color col = p.MapSprite.color;

                    //if (p.AvailableColors)
                    if (p.AvailableColors.Count > 0)
                    {
                        col = (Color)p.AvailableColors[new System.Random ().Next (p.AvailableColors.Count)];
                    }

                    if (!p.UsedColors.Contains (col))
                    {
                        p.AvailableColors.Remove (col);
                        setUnitColor (p.MapSprite, col);
                        p.UsedColors.Add (col);
                    }
                    else
                    {
                        p.RefreshColors ();
                        p.ColorTimer = 0.0f;
                        cycleColorAndStatus (p);
                        return;
                    }
                }
            }
            else if (!p.StateActive (p.Invisible))
            {
                p.MapSprite.color = Color.white;
                p.ColorIndex = -1;
            }
        }
        else
        {
            p.StatusIcon.color = Color.clear;
            setUnitColor (p.MapSprite, Color.clear);
        }
        //if (!p.ColorWillChange) {
        //  setUnitColor (p.MapSprite, Color.white);
        //}
    }

    public void setUnitColor (RawImage img, Color color)
    {
        img.color = color;
    }

    public void clearDialogues ()
    {
        for (int i = 0; i < battleMap.Roster.Count; i++)
        {
            ((Player)battleMap.Roster[i]).Vocals.Clear ();
        }
    }

    public string executeSkill (Player exec, Skill s, Location loc, string direct, Boolean readText, Boolean recoveryActivated, Boolean independent, double decay)
    {
        print (exec.FirstName + " " + loc + " executing skill " + s.Name);
        //print ("This has " + s.LinkSkills.Count + " chains");
        skillExecutor = exec;
        string output = "";
        ArrayList skillLocations = new ArrayList ();
        int numReps = 0;
        exec.ChainSkills = new ArrayList ();
        exec.BurstFollowUpSkills = new ArrayList ();

        Location startingLoc = new Location (exec.currentLocation ().Row, exec.currentLocation ().Column, exec.currentLocation ().Height);
        int startingHeight = exec.Potency (exec.Airborne);

        exec.Direction = exec.currentLocation ().DirectionOf (loc);

        targettedPlayers = new ArrayList ();

        ArrayList locCluster;
        //ArrayList outputs;
        Location addLoc;
        Location originalLoc = new Location (loc.Row, loc.Column);
        Location lineLoc = new Location (loc.Row, loc.Column);
        Location oppositeLoc = new Location (loc.Row, loc.Column);
        //Location nextLoc;
        Boolean cancelledOut = false;
        Player lastTarget = new Player (-1, "null", "", "", "", "", "", "", "", 0,
            0.0, 0.0, "", "", 0, -1, false, true);
        //Player executor = this;
        ArrayList allTargets = new ArrayList ();
        ArrayList outputs = new ArrayList ();
        Location presentLoc = null;

        if (!exec.OnField && (!s.Neutral && !s.Properties.Contains (" MAP ")))
        {
            return "";
        }

        s.SkillOutput = 0;

        if ((s.MasterSkill == null || !s.MasterSkill.Properties.Contains ("AUTOLINK ")) && !s.Properties.Contains ("CRITICAL ") && !s.Properties.Contains ("MAP") && !s.Neutral)
        {
            playAppropriateInitialAnimation (exec, s);
        }

        output += "-----" + '\n';


        if ((s.CostsMet && s.ConditionsMet) || s.Name.Equals ("Pace Cancel"))
        {

            //print ("COSTS AND CONDITIONS MET FOR " + s.Name);

            if (!s.Neutral)
            {
                exec.HurtStun = 0;
            }

            s.Used = true;
            s.CurrentHeight = exec.currentMap ().heightOf (exec.currentLocation ());

            if (readText)
            {
                if (!s.LineSkill)
                {
                    output += string.Format ("{0} is executed on {2}." + '\n', s.Name, s.SkillType, loc);
                }
                else
                {
                    output += string.Format ("{0} is executed toward {2} ({3})." + '\n', new object[] {
                        s.Name,
                        s.SkillType,
                        direct,
                        exec.currentLocation ().getNewLocationFromDirection (direct).ToString ()
                    });
                }
            }

            if (s.Properties.Contains (" COOLDOWN"))
            {
                exec.Cooldown += NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('+') + 1, 3));
            }

            if (!s.Properties.Contains (" NOGAIN ") && !s.Properties.Contains (" INVENTORY "))
            {
                output += gainProficiency (s, 50 + (int)(50 * (exec.Level / s.Mastery)));
            }

            if (s.Malicious || s.Properties.Contains ("BURST"))
            {
                addDialogue (s.AppropriatePhrase (battleMap.playerAt (loc)), exec, false, "Attack");
            }
            else
            {
                addDialogue (s.AppropriatePhrase (battleMap.playerAt (loc)), exec, false, "Neutral");
            }

            if (s.Targetless && s.Properties.Contains ("LAND "))
            {
                exec.SetHeight (0);
            }

            if (!s.Properties.Contains ("MAP ") && !s.Individual && !s.Neutral)
            {
                exec.StepTime = 0.0f;
            }

            if (!s.Properties.Contains ("MAP ") && !s.Properties.Contains ("REMAIN "))
            {
                if (exec.IsCrouching && !exec.StateActive (exec.Confuse))
                {
                    exec.IsCrouching = false;
                }
            }

            if (s.Properties.Contains ("CLRDMG"))
            {
                exec.DamageTakenTotal = 0;
                exec.DamageTakenPerRound = 0;
            }

            if (s.Properties.Contains (" CLRFAT "))
            {
                exec.SetFatigue (0);
            }


            if (s.Recovery != 0 && recoveryActivated && !s.Properties.Contains ("MAP ")
                && s.Properties.Contains ("LEAP") && !exec.StateActive (exec.Airborne))
            {

                output += string.Format ("{0} leaps into the air!", exec.FirstName) + '\n';
                s.CurrentHeight = battleMap.heightOf (exec.currentLocation ());
            }

            if (s.Properties.Contains ("SAMEDMG "))
            {
                decay = 1;
            }

            if (!s.Properties.Contains ("FOLLOWUP") || exec.BurstFollowUpSkills.Count > 0)
            {
                exec.BurstFollowUpSkills = new ArrayList ();
            }

            if (s.Recovery != 0 && recoveryActivated && !s.Grapple && !s.Properties.Contains ("MAP ") && !s.Neutral && !s.Properties.Contains (" INDEPENDENT "))
            {
                exec.AddFatigue (s.Recovery);
                output += string.Format ("{0} Recovery: {1}" + '\n', s.Name, s.Recovery);
            }

            //METER COST

            if (!s.SearchName.Equals("Cancel"))
            {
                if (s.Cost[0] != 0)
                {
                    output += shiftHealth(exec, s.Cost[0], false, null, s);
                }
                if (s.Cost[1] != 0 && !exec.StateActive(exec.Fury))
                {
                    output += shiftRush(exec, s.Cost[1], false, null);
                }
                if (s.Cost[2] != 0)
                {
                    output += shiftGuard(exec, s.Cost[2], false, null);
                }
                if (s.Cost[3] != 0)
                {
                    output += shiftVitality(exec, s.Cost[3], false, null);
                }

                if (exec != battleMap.MapOwner && exec.BloodPrice && s.Cost[0] < 0)
                {
                    createAnimationOnMap("Blood", StateChannel, exec.CentralPosition, 2f, false);
                }
            } else {
                if (Math.Abs (finishTimeMax - finishTime) <= 0.4f)
                {
                    output += shiftVitality (exec, -200, false, null);
                    announce (@"perfect");
                    addToNotificationQueue (s, exec, "PACE PERFECT CANCEL!", true);
                    createAnimationOnMap("Cancel", EnvironmentChannel, exec.CentralPosition, 3.5f, true);                }
                else
                {
                    output += shiftVitality (exec, -300, false, null);
                    addToNotificationQueue (s, exec, "PACE CANCEL!", true);
                    createAnimationOnMap("Cancel", EnvironmentChannel, exec.CentralPosition, 3f, true);                }
                }

                if ((!trainingMode || s.Properties.Contains ("CONTACT ")) && s.NumUses > 0)
            {

                s.NumUses--;
                output += string.Format ("{0} has {1} uses left." + '\n', s.Name, s.NumUses);

                if (s.NumUses == 0 && s.Properties.Contains ("REMOVE "))
                {
                    if (!s.Properties.Contains ("TEAM "))
                    {
                        s.Owner.forget (s);
                    }
                    else
                    {
                        s.Owner.MyTeam.Inventory.Remove (s);
                    }
                }
            }

            if (!s.Properties.Contains ("MAP "))
            {
                if (s.ActionChange)
                {
                    if (!s.CanAct)
                    {
                        output += exec.setAction (false);
                        exec.HasActed = true;
                    }

                    //IF TARGETLESS SKILL
                    else if (s.Targetless)
                    {
                        output += exec.setAction (true);
                        exec.HasActed = true;
                    }
                }
            }

            if (s.JumpReset)
            {
                exec.HasJumped = false;
            }

            if (s.MoveReset)
            {
                exec.MovesRemaining = exec.Movement;
            }

            if ((s.Properties.Contains ("JUMP") || s.Properties.Contains ("USEJ")) && !s.Properties.Contains ("NOJUMP"))
            {
                exec.HasJumped = true;
            }

            //EMPTYING ALL AMMO
            if (!s.NoConditions && s.Properties.Contains ("CLRAMO"))
            {
                for (int i = 0; i < exec.Inventory.Count; i++)
                {
                    Item itm = ((Item)exec.Inventory[i]);
                    if (itm.NumUses > 0)
                    {
                        if (!s.Properties.Contains ("DEPLETE "))
                        {
                            if (!s.Properties.Contains ("NOLOSS ") && !itm.SpecialConditions.Contains ("NOLOSS "))
                            {
                                addToNotificationQueue (s, exec, "DEPLETE -" + s.ItemsPerUse + " " + itm.Name, true);
                            }
                            itm.NumUses--;
                        }
                        else
                        {
                            if (!s.Properties.Contains ("NOLOSS ") && !itm.SpecialConditions.Contains ("NOLOSS "))
                            {
                                addToNotificationQueue (s, exec, "DEPLETE -" + s.ItemsPerUse + " " + itm.Name, true);
                            }
                            itm.NumUses = 0;
                        }
                    }
                }
            }

            //EXPENDABLE AMMO
            if (!s.NoConditions && !s.ExpendableAmmo.Equals ("N/A") && !s.Owner.NoConditions && !s.Properties.Contains (" AMMOEACH ")
                && exec.inventoryGet (s.ExpendableAmmo) != null)
            {
                Item i = exec.inventoryGet (s.ExpendableAmmo);

                if (i == null)
                {
                    throw new Exception (s.ExpendableAmmo);
                }

                if (!s.Properties.Contains ("DEPLETE "))
                {
                    i.NumUses -= s.ItemsPerUse;
                    if (!s.Properties.Contains ("NOLOSS ") && !i.SpecialConditions.Contains ("NOLOSS "))
                    {
                        addToNotificationQueue (s, exec, "DEPLETE -" + s.ItemsPerUse + " " + i.Name, true);
                    }
                }
                else
                {
                    i.NumUses = 0;
                    if (!s.Properties.Contains ("NOLOSS ") && !i.SpecialConditions.Contains ("NOLOSS "))
                    {
                        addToNotificationQueue (s, exec, "DEPLETE -" + i.Name, true);
                    }
                }

                if (i.NumUses > 0)
                {
                    output += string.Format ("{0} has {1} uses left." + '\n', i.Name, i.NumUses);
                }
                else
                {
                    output += string.Format ("{0} depleted." + '\n', i.Name);
                    if (s.Properties.Contains ("REMOVE"))
                    {
                        s.Owner.forget (s);
                    }
                }
            }

            if (s.Properties.Contains ("REMOVE") && s.NumUses == 0)
            {
                s.Owner.forget (s);
            }

            //RELOAD
            if (!s.ReloadAmmo.Equals ("N/A") && exec.inventoryGet (s.ReloadAmmo) != null)
            {
                if (!s.Properties.Contains ("RELOADSKILL"))
                {


                    Item it = exec.inventoryGet (s.ReloadAmmo);

                    if (it == null)
                    {
                        //exec.addItem (new Item (s.ReloadAmmo, "", ""));
                        throw new Exception (s.ReloadAmmo);
                    }

                    addToNotificationQueue (s, exec, exec.FirstName.ToUpper () + " RELOAD (" + it.Name + ")!", true);

                    if (s.Properties.Contains (" CHARGE"))
                    {
                        if (it.NumUses < it.MaxUses)
                        {
                            it.NumUses += 1;
                        }
                        output += string.Format ("{0} replenished. ({1} uses)" + '\n', it.Name, it.NumUses);
                    }
                    else
                    {
                        it.NumUses = it.MaxUses;
                        output += string.Format ("{0} uses up. ({1} uses)" + '\n', it.Name, it.NumUses);
                    }

                }
                else
                {

                    Skill skl = exec.skillGet (s.ReloadAmmo);

                    if (skl == null)
                    {
                        throw new Exception (s.ReloadAmmo);
                    }

                    if (!s.Properties.Contains ("SINGULAR"))
                    {
                        skl.NumUses = skl.MaxUses;
                        output += string.Format ("{0} replenished. ({1} uses)" + '\n', skl.Name, skl.NumUses);
                    }
                    else
                    {
                        skl.NumUses = skl.MaxUses;
                        output += string.Format ("{0} uses up. ({1} uses)" + '\n', skl.Name, skl.NumUses);
                    }
                }
            }

            if (!s.CanFreeMove && exec.MovesRemaining > 0 && !s.Properties.Contains ("MAP"))
            {
                exec.MovesRemaining = 0;
            }

            //MOVES PLAYER TO LOCATION BEFORE ACTION



            Location moveLoc = exec.openBorderOf (loc, true, s);
            if ((s.Properties.Contains (" MOVE ")) && !exec.StateActive (exec.Freeze)
                && moveLoc != null)
            {
                output += recordMovement (
                    exec, s, moveLoc, !s.Properties.Contains ("MOVEOFF "), false,
                    s.Properties.Contains ("TELEPORT") || exec.Flight || s.Properties.Contains ("LEAP "), false, true, !s.Properties.Contains ("DODGE"), "");
            }

            if (s.Properties.Contains ("TRACLR"))
            {
                for (int i = 0; i < exec.TrackSkills.Count; i++)
                {
                    battleMap.removeInteractable ((Skill)exec.TrackSkills[i]);
                    i--;
                }
            }

            if (s.Properties.Contains ("SUMMON"))
            {

                DataReader reader = new DataReader ();
                string nm = s.Properties.Substring (s.Properties.IndexOf (':') + 1);
                //print (nm);
                //Player summoned = reader.loadRandomPlayer (nm, "Player", exec.SearchName);
                Player summoned = reader.loadTeamMember (exec.MyTeam.ExtraTeam, nm, exec.PlayStyle, 1, true);

                output += string.Format ("{0} enters the battlefield", summoned.FirstName);

                if (summoned.TimeRemaining > 0)
                {
                    output += string.Format (" for {0} turns!" + '\n', summoned.TimeRemaining);
                }
                else
                {
                    output += "!" + '\n';
                }

                summoned.PlayStyle = exec.PlayStyle;
                summoned.Owner = exec;
                //summoned.Index = playerIndex;
                //playerIndex++;

                Location sLoc = exec.currentLocation ().getNewLocationFromDirection (exec.Direction);
                summoned.CurrentLocation = exec.openBorderOf (sLoc, false, s);

                exec.currentMap ().addObject (summoned);

                if (exec.MyTeam.SubTeam == null)
                {
                    exec.MyTeam.SubTeam = new Team (exec.MyTeam.Name, exec.MyTeam.Abbreviation, exec.MyTeam.MAXSIZE);
                }

                exec.MyTeam.SubTeam.addPlayer (summoned);

                if (summoned.MyTeam.SubTeam == null)
                {
                    summoned.MyTeam.SubTeam = new Team (exec.MyTeam.Name, exec.MyTeam.Abbreviation, exec.MyTeam.MAXSIZE);
                }

                if (exec.MyTeam.SubTeam.Roster.Count == 0)
                {
                    throw new NullReferenceException ("DAMN IT");
                }

                setPlayerGraphicsAndAudio (summoned, battleMap.Roster.Count - 1);

                output += recordMovement (summoned, s, summoned.currentLocation (), false, false, true, true, true, true, summoned.currentLocation ().DirectionOf (exec));

                createAnimationOnMap ("HitMagic", StateChannel, getImageFromLocation (sLoc).transform.position, 3f, true);

                displayMapPlayerGraphics (summoned, sLoc.Row, sLoc.Column);

                muteSound ();


                if (s.Properties.Contains ("SMNSKL") && s.LinkSkills.Count > 0)
                {
                    //output += "SUMMON PLAYER" + '\n';
                    output += executeSkill (summoned, (Skill)s.LinkSkills[0], summoned.currentLocation (),
                        "X", true, false, !((Skill)s.LinkSkills[0]).HasLinks, 1.0);
                }

                if (s.Properties.Contains ("HOMON"))
                {
                    summoned.Species = "Homunculus";
                }
                if (s.Properties.Contains ("SMNTM"))
                {
                    summoned.TimeRemaining = NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('%') + 1, 3));
                    output += string.Format ("{0} time remaining: {1}" + '\n', summoned.FirstName, summoned.TimeRemaining);
                }
                if (s.Properties.Contains (" NMTR "))
                {
                    summoned.NoGainForMaster = true;
                }
                if (s.Properties.Contains ("GONOW"))
                {
                    exec.CounterPlayer = summoned;
                    output += summoned.setAction (true);

                    summoned.MovesRemaining = summoned.Movement;
                }
                output += exec.currentMap ().ToString ();
            }

            ArrayList plrs = new ArrayList ();
            plrs.Add (battleMap.playerAt (exec.currentLocation ().North));
            plrs.Add (battleMap.playerAt (exec.currentLocation ().East));
            plrs.Add (battleMap.playerAt (exec.currentLocation ().South));
            plrs.Add (battleMap.playerAt (exec.currentLocation ().West));
            Player target;

            for (int j = 0; j < plrs.Count; j++)
            {
                target = (Player)plrs[j];

                //SELF SKILL LEARNING
                if (target != null && s.canBeLearnedBy (target) && target.StateActive (target.Learn) && !target.knows (s))
                {
                    if (!s.Standalone && (s.Properties.Contains (" CHILD ") || s.Properties.Contains (" MAP ")) && s.MasterSkill != null)
                    {
                        Skill skl = s.MasterSkill;

                        while (!skl.Properties.Contains ("MASTER ") && skl.MasterSkill != null)
                        {
                            print ("LEARNING " + skl.SearchName + " to master");
                            skl = skl.MasterSkill;
                        }
                        print (skl.SearchName + " is master");
                        if (!target.knows (skl) && !skl.Properties.Contains (" CHILD "))
                        {

                            string learnOutput = target.learn (skl, true, Math.Abs (target.Potency (target.Learn)) - (Math.Abs (skl.Cost[3] / 100)));
                            output += learnOutput;
                            if (target.Potency (target.Learn) > 0)
                            {
                                output += target.Learn.IncrementVariants;
                            }
                            print (learnOutput);
                            print (target.FirstName.ToUpper () + " " + string.Format ("LEARNS " + skl.Name.ToUpper () + " (" + target.Potency (target.Learn) + ")"));
                            addToNotificationQueue (s, target, target.FirstName.ToUpper () + " " + string.Format ("LEARNS " + skl.Name.ToUpper () + " (" + target.Potency (target.Learn) + ")"), true);
                            createAnimationOnMap ("Contact", StateChannel, getImageFromLocation (target.currentLocation ()).transform.position, 2f, true);
                        }
                    }
                    else if (!s.Properties.Contains (" CHILD "))
                    {

                        string learnOutput = target.learn (s, true, Math.Abs (target.Potency (target.Learn)) - (Math.Abs (s.Cost[3] / 100)));
                        output += learnOutput;
                        if (target.Potency (target.Learn) > 0)
                        {
                            output += target.Learn.IncrementVariants;
                        }
                        print (learnOutput);
                        print (target.FirstName.ToUpper () + " " + string.Format ("LEARNS " + s.Name.ToUpper () + " (" + target.Potency (target.Learn) + ")"));
                        addToNotificationQueue (s, target, target.FirstName.ToUpper () + " " + string.Format ("LEARNS " + s.Name.ToUpper () + " (" + target.Potency (target.Learn) + ")"), true);
                        createAnimationOnMap ("Contact", StateChannel, getImageFromLocation (target.currentLocation ()).transform.position, 2f, true);
                    }
                }
            }

            print ("COSTS AND CONDITIONS MET FOR " + s.Name);

            // SELF SKILL
            if (s.SelfSkill)
            {
                print ("SELF " + loc);
                //output += string.Format ("SELF SKILL" + '\n');
                outputs = executeSkillOnLocation (exec, s, loc, exec.currentLocation (), originalLoc, decay, "X", independent);
                output += (string)outputs[0];
                lastTarget = (Player)outputs[1];
                numReps++;
                //output += "Last target was " + lastTarget.FirstName + '\n';

                cancelledOut = (Boolean)outputs[2];
                //executor = (Player)outputs [3];
                if (!allTargets.Contains (lastTarget))
                {
                    allTargets.Add (lastTarget);
                }
            }


            // RADIUS SKILL
            else if (s.RadiusSkill)
            {
                print ("RADIUS " + loc);
                //output += string.Format ("RADIUS SKILL" + '\n');
                for (int i = 0; i < exec.currentMap ().MapGrid.Length && !cancelledOut; i++)
                {
                    for (int j = 0; j < exec.currentMap ().MapGrid[0].Length && !cancelledOut; j++)
                    {

                        addLoc = new Location (i, j);

                        if (exec.currentLocation ().span (addLoc) <= s.Range)
                        {
                            //output += "RADIUS " + addLoc;
                            numReps++;
                            outputs = executeSkillOnLocation (
                                exec, s, loc, addLoc, exec.currentLocation (),
                                decay, exec.currentLocation ().DirectionOf (addLoc),
                                independent);

                            output += (string)outputs[0];
                            lastTarget = (Player)outputs[1];

                            //output += "Last target was " + lastTarget.FirstName + '\n';

                            cancelledOut = (Boolean)outputs[2];
                            if (cancelledOut)
                            {
                                print ("CANCELLED OUT!");
                            }

                            //executor = (Player)outputs [3];
                            if (!allTargets.Contains (lastTarget))
                            {
                                allTargets.Add (lastTarget);
                            }
                        }
                    }
                }
            }





            // SINGLE SKILL
            else if (s.SingleSkill && (s.locationsContains (loc) || s.Auto))
            {
                print ("SINGLE " + loc);
                //output += string.Format ("SINGLE SKILL" + '\n');
                for (int i = 0; i < exec.currentMap ().MapGrid.Length && !cancelledOut; i++)
                {
                    for (int j = 0; j < exec.currentMap ().MapGrid[0].Length && !cancelledOut; j++)
                    {

                        addLoc = new Location (i, j);

                        if (originalLoc.span (addLoc) < (s.WidthOrRadius))
                        {
                            if (!s.locationsContains (loc))
                            {
                                s.setLocations ();
                            }

                            if (!s.Properties.Contains (" MOVE ") && !s.Properties.Contains (" MOVELAST "))
                            {
                                numReps++;
                                outputs = executeSkillOnLocation (
                                    exec, s, loc, addLoc, originalLoc,
                                    decay, loc.DirectionOf (addLoc), independent);
                                output += (string)outputs[0];
                                lastTarget = (Player)outputs[1];

                                cancelledOut = (Boolean)outputs[2];
                                if (!allTargets.Contains (lastTarget))
                                {
                                    allTargets.Add (lastTarget);
                                }
                            }
                            else
                            {
                                outputs = executeSkillOnLocation (
                                    exec, s, loc, addLoc, exec.currentLocation (), decay,
                                    exec.currentLocation ().DirectionOf (addLoc), independent);
                                output += (string)outputs[0];
                                lastTarget = (Player)outputs[1];

                                cancelledOut = (Boolean)outputs[2];
                                if (!allTargets.Contains (lastTarget))
                                {
                                    allTargets.Add (lastTarget);
                                }
                            }
                        }
                    }
                }
            }

            /// LINE SKILL
            // Here, I collect a line cluster of size 2x - 1 (e.g. a Line Skill with a width of 2 will have a cluster of size 3)
            // and iterate through each, then move down the line until the threshold has run out, the move has been cancelled, or
            // the maximum range is reached

            else if (s.LineSkill && (s.locationsContains (loc) || (!direct.Equals ("") && !direct.Equals ("X"))))
            {
                string direction = "", oppositeDirection = "";
                print ("LINE " + loc);
                //output += string.Format ("LINE SKILL " + direct + '\n');
                if (!direct.Equals ("") && !direct.Equals ("X"))
                {
                    direction = direct;
                    oppositeDirection = getOppositeDirection (direct);
                }
                else
                {
                    direction = exec.currentLocation ().DirectionOf (originalLoc);
                    oppositeDirection = exec.currentLocation ().OppositeDirectionOf (originalLoc);
                }

                lineLoc = exec.currentLocation ().getNewLocationFromDirection (direction);
                oppositeLoc = exec.currentLocation ().getNewLocationFromOppositeDirection (direction);
                locCluster = new ArrayList ();
                //Location lineMoveLoc = lineLoc;



                int mov = 0;
                for (int i = 0; i < s.Range && s.ThresholdMeasure > 0 && exec.InPlay && !cancelledOut; i++)
                {

                    //Boolean reflected = false;

                    if (exec.getClusterFromDirection (lineLoc, direction, s.WidthOrRadius).Count > 0)
                    {
                        locCluster = exec.getClusterFromDirection (lineLoc, direction, s.WidthOrRadius);
                    }
                    //output += (lineLoc) + " LINE";
                    for (int j = 0; (!(exec.KOd || s.Properties.Contains ("KNOCKOUT ")) || s.Properties.Contains ("POSTMORTEM ")) && j < locCluster.Count && !cancelledOut && s.ThresholdMeasure > 0; j++)
                    {



                        //EACH LINE TARGET
                        //output += ((Location)locCluster [j]).ToString () + " LINE " +  direction + " " + '\n';

                        presentLoc = (Location)locCluster[j];
                        numReps++;
                        outputs = executeSkillOnLocation (exec, s, loc, (Location)locCluster[j],
                            exec.currentLocation (), decay, direction, independent);
                        output += (string)outputs[0];
                        lastTarget = (Player)outputs[1];

                        //output += "Last target was " + lastTarget.FirstName + '\n';

                        cancelledOut = (Boolean)outputs[2];
                        if (!allTargets.Contains (lastTarget))
                        {
                            //output += lastTarget.FirstName + '\n';
                            allTargets.Add (lastTarget);
                        }
                        //output += " " + '\n';
                    }

                    if (s.MotionRange > 0 && !cancelledOut && exec.currentMap ().isValid (lineLoc)
                        && exec.currentMap ().canMakeMove (exec, lineLoc, s))
                    {
                        if (mov < s.MotionRange && !exec.StateActive (exec.Freeze) && exec.currentMap ().isValid (lineLoc)
                            && exec.currentMap ().isEmpty (lineLoc))
                        {
                            if (!output.Contains ("moves toward"))
                            {

                                string exOutput = recordMovement (
                                    exec, s, lineLoc, !s.MaintainMovements, false,
                                    s.Properties.Contains ("TELEPORT") || exec.Flight, false, true, !s.Properties.Contains ("DODGE"), "");
                                output += exOutput;


                                if (exOutput.Contains ("connects on"))
                                {
                                    cancelledOut = true;
                                }
                            }
                            mov++;
                        }
                    }
                    else if (s.MotionRange < 0 && !cancelledOut)
                    {
                        if (mov < Math.Abs (s.MotionRange) && !exec.StateActive (exec.Freeze)
                            && exec.currentMap ().isValid (oppositeLoc)
                            && exec.currentMap ().isEmpty (oppositeLoc))
                        {
                            //output += "LINE: " + FirstName + " to " + lineLoc + '\n';

                            if (!output.Contains ("moves toward"))
                            {

                                output += recordMovement (exec, s, oppositeLoc, !s.MaintainMovements, false,
                                    s.Properties.Contains ("TELEPORT") || exec.Flight, false, true, !s.Properties.Contains ("DODGE"), "");


                            }
                            mov++;
                        }
                    }
                    else if (s.MotionRange != 0 && !cancelledOut && !exec.currentMap ().canMakeMove (exec, loc, s))
                    {
                        output += string.Format ("{0} stopped because cannot make move!" + '\n', s.Name);
                        if (!s.Properties.Contains ("MVEXTRA "))
                        {
                            cancelledOut = true;
                        }
                    }

                    //if (nextLoc)
                    //nextLoc = currentLocation ().getNewLocationFromDirection (direction);

                    if (!cancelledOut)
                    {
                        if (remainsOnTarget (exec, s, lastTarget, presentLoc, direction, output))
                        {
                            //output += currentMap ().objectAt (nextLoc).mapName () + " " + currentMap ().objectAt (nextLoc.getNewLocationFromDirection (direction)).mapName ();

                        }
                        else
                        {

                            lineLoc = lineLoc.getNewLocationFromDirection (direction);
                        }
                    }
                }

                //OPPOSITE DIRECTION

                if (s.Properties.Contains ("OPPOSITE"))
                {
                    output += string.Format ("Opposite side!" + '\n');
                    s.resetThresholdMeasure ();
                    s.HitTargets.Clear ();
                    lineLoc = exec.currentLocation ().getNewLocationFromDirection (oppositeDirection);
                    //Location lineMoveLoc = lineLoc;

                    mov = 0;
                    for (int i = 0; i < s.Range && s.ThresholdMeasure > 0 && !cancelledOut; i++)
                    {

                        //Boolean reflected = false;
                        locCluster = exec.getClusterFromDirection (lineLoc, oppositeDirection, s.WidthOrRadius);
                        //output += (lineLoc) + " LINE";
                        for (int j = 0; (!exec.KOd || s.Properties.Contains ("POSTMORTEM ")) && j < locCluster.Count && !cancelledOut && s.ThresholdMeasure > 0; j++)
                        {



                            //EACH LINE TARGET


                            presentLoc = (Location)locCluster[j];
                            numReps++;
                            outputs = executeSkillOnLocation (exec, s, loc, (Location)locCluster[j],
                                exec.currentLocation (), decay, oppositeDirection, independent);
                            output += (string)outputs[0];
                            lastTarget = (Player)outputs[1];
                            cancelledOut = (Boolean)outputs[2];
                            //executor = (Player)outputs [3];
                            if (!allTargets.Contains (lastTarget))
                            {
                                allTargets.Add (lastTarget);
                            }
                            //output += " " + '\n';
                        }

                        if (mov < s.MotionRange && !exec.StateActive (exec.Freeze) && exec.currentMap ().isValid (lineLoc)
                            && exec.currentMap ().isEmpty (lineLoc))
                        {

                            if (!output.Contains ("moves toward"))
                            {

                                string exOutput = recordMovement (
                                    exec, s, lineLoc, !s.MaintainMovements, false,
                                    s.Properties.Contains ("TELEPORT") || exec.Flight, false, true, !s.Properties.Contains ("DODGE"), "");
                                output += exOutput;

                                if (exOutput.Contains ("connects on"))
                                {
                                    cancelledOut = true;
                                }
                            }
                            mov++;
                        }

                        //nextLoc = currentLocation ().getNewLocationFromDirection (oppositeDirection);

                        if (remainsOnTarget (exec, s, lastTarget, presentLoc, oppositeDirection, output))
                        {
                            //output += currentMap ().objectAt (nextLoc).mapName () + " " + currentMap ().objectAt (nextLoc.getNewLocationFromDirection (oppositeDirection)).mapName ();

                        }
                        else
                        {
                            lineLoc = lineLoc.getNewLocationFromDirection (oppositeDirection);
                        }
                    }
                }

                //LEFT
                if (s.Properties.Contains ("LEFT "))
                {
                    s.resetThresholdMeasure ();
                    s.HitTargets.Clear ();
                    string leftDirection = "";

                    if (direction.Equals ("N"))
                    {
                        leftDirection = "W";
                    }
                    else if (direction.Equals ("E"))
                    {
                        leftDirection = "N";
                    }
                    else if (direction.Equals ("S"))
                    {
                        leftDirection = "E";
                    }
                    else if (direction.Equals ("W"))
                    {
                        leftDirection = "S";
                    }

                    lineLoc = exec.currentLocation ().getNewLocationFromDirection (leftDirection);
                    //Location lineMoveLoc = lineLoc;

                    mov = 0;
                    for (int i = 0; i < s.Range && s.ThresholdMeasure > 0 && !cancelledOut; i++)
                    {

                        //Boolean reflected = false;
                        locCluster = exec.getClusterFromDirection (lineLoc, leftDirection, s.WidthOrRadius);
                        //output += (lineLoc) + " LINE";
                        for (int j = 0; (!exec.KOd || s.Properties.Contains ("POSTMORTEM ")) && j < locCluster.Count && !cancelledOut && s.ThresholdMeasure > 0; j++)
                        {



                            //EACH LINE TARGET

                            presentLoc = (Location)locCluster[j];
                            numReps++;
                            outputs = executeSkillOnLocation (exec, s, loc, (Location)locCluster[j],
                                exec.currentLocation (), decay, leftDirection, independent);
                            output += (string)outputs[0];
                            lastTarget = (Player)outputs[1];
                            cancelledOut = (Boolean)outputs[2];
                            //executor = (Player)outputs [3];
                            if (!allTargets.Contains (lastTarget))
                            {
                                allTargets.Add (lastTarget);
                            }
                            //output += " " + '\n';
                        }

                        if (mov < s.MotionRange && !exec.StateActive (exec.Freeze) && exec.currentMap ().isValid (lineLoc)
                            && exec.currentMap ().isEmpty (lineLoc))
                        {

                            if (!output.Contains ("moves toward"))
                            {

                                string exOutput = recordMovement (
                                    exec, s, lineLoc, !s.MaintainMovements, false,
                                    s.Properties.Contains ("TELEPORT") || exec.Flight, false, true, !s.Properties.Contains ("DODGE"), "");
                                output += exOutput;

                                if (exOutput.Contains ("connects on"))
                                {
                                    cancelledOut = true;
                                }
                            }
                            mov++;
                        }

                        //nextLoc = currentLocation ().getNewLocationFromDirection (leftDirection);

                        if (remainsOnTarget (exec, s, lastTarget, presentLoc, leftDirection, output))
                        {
                            //output += currentMap ().objectAt (nextLoc).mapName () + " " + currentMap ().objectAt (nextLoc.getNewLocationFromDirection (leftDirection)).mapName ();

                        }
                        else
                        {
                            lineLoc = lineLoc.getNewLocationFromDirection (leftDirection);
                        }
                    }
                }

                //RIGHT
                if (s.Properties.Contains ("RIGHT "))
                {
                    s.resetThresholdMeasure ();
                    s.HitTargets.Clear ();
                    string rightDirection = "";

                    if (direction.Equals ("N"))
                    {
                        rightDirection = "E";
                    }
                    else if (direction.Equals ("E"))
                    {
                        rightDirection = "S";
                    }
                    else if (direction.Equals ("S"))
                    {
                        rightDirection = "W";
                    }
                    else if (direction.Equals ("W"))
                    {
                        rightDirection = "N";
                    }

                    lineLoc = exec.currentLocation ().getNewLocationFromDirection (rightDirection);
                    //Location lineMoveLoc = lineLoc;

                    mov = 0;
                    for (int i = 0; i < s.Range && s.ThresholdMeasure > 0 && !cancelledOut; i++)
                    {

                        //Boolean reflected = false;
                        locCluster = exec.getClusterFromDirection (lineLoc, rightDirection, s.WidthOrRadius);
                        //output += (lineLoc) + " LINE";
                        for (int j = 0; (!exec.KOd || s.Properties.Contains ("POSTMORTEM ")) && j < locCluster.Count && !cancelledOut && s.ThresholdMeasure > 0; j++)
                        {



                            //EACH LINE TARGET

                            presentLoc = (Location)locCluster[j];
                            numReps++;
                            outputs = executeSkillOnLocation (exec, s, loc, (Location)locCluster[j],
                                exec.currentLocation (), decay, rightDirection, independent);
                            output += (string)outputs[0];
                            lastTarget = (Player)outputs[1];
                            cancelledOut = (Boolean)outputs[2];
                            //executor = (Player)outputs [3];
                            if (!allTargets.Contains (lastTarget))
                            {
                                allTargets.Add (lastTarget);
                            }
                            //output += " " + '\n';
                        }

                        if (mov < s.MotionRange && !exec.StateActive (exec.Freeze) && exec.currentMap ().isValid (lineLoc)
                            && exec.currentMap ().isEmpty (lineLoc))
                        {

                            if (!output.Contains ("moves toward"))
                            {

                                string exOutput = recordMovement (
                                    exec, s, lineLoc, !s.MaintainMovements, false,
                                    s.Properties.Contains ("TELEPORT") || exec.Flight, false, true, !s.Properties.Contains ("DODGE"), "");
                                output += exOutput;

                                if (exOutput.Contains ("connects on " + exec.FirstName))
                                {
                                    cancelledOut = true;
                                }
                            }
                            mov++;
                        }

                        //nextLoc = currentLocation ().getNewLocationFromDirection (rightDirection);

                        if (remainsOnTarget (exec, s, lastTarget, presentLoc, rightDirection, output))
                        {
                            //output += currentMap ().objectAt (nextLoc).mapName () + " " + currentMap ().objectAt (nextLoc.getNewLocationFromDirection (rightDirection)).mapName ();

                        }
                        else
                        {
                            lineLoc = lineLoc.getNewLocationFromDirection (rightDirection);
                        }
                    }
                }
            }


            //LEAP COST
            if (s.Recovery != 0 && recoveryActivated && !s.Properties.Contains ("MAP "))
            {
                if (s.Properties.Contains ("LEAP") && (!s.Grapple || !s.HasConnected) && (!s.Properties.Contains ("STAY") || !exec.StateActive (exec.Airborne)))
                {

                    if (s.Properties.Contains ("RESET "))
                    {
                        exec.SetHeight (0);
                    }

                    exec.SetHeight (exec.Potency (exec.Airborne) + (s.Recovery / 2) + 1);
                    exec.InRecovery = true;
                    exec.IsCrouching = false;
                }
                else if (!exec.Flight && !s.Properties.Contains ("FOLLOW "))
                {
                    exec.SetHeight (0);
                    exec.InRecovery = false;
                }
            }

            if (s.Properties.Contains ("NORECOVER"))
            {
                exec.InRecovery = false;
            }

            exec.CurrentHitRate = 0;

            //print ("...RIK?");

            //JUMPS PLAYER TO LOCATION AFTER ACTION
            if (!exec.KOd
                //&& !cancelledOut
                && !exec.StateActive (exec.Freeze)
                && s.Properties.Contains ("MOVELAST ")
                && exec.openBorderOf (loc, true, s) != null)
            {

                //output += "MOVELAST: " + FirstName + " to " + loc + '\n';
                output += recordMovement (exec, s, exec.openBorderOf (loc, true, s), !s.Properties.Contains ("MOVEOFF "), false,
                    s.Properties.Contains ("TELEPORT") || exec.Flight, false, true, !s.Properties.Contains ("DODGE"), "");
            }
            else
            {
                if (exec.openBorderOf (loc, true, s) == null)
                {
                    output += string.Format ("NAH" + '\n');
                }
            }


            if (!s.NoAnimation && !s.Properties.Contains ("MAP ") && s.MotionSkill && !s.Properties.Contains ("TELEPORT"))
            {
                if (s.PlayerTexture != null)
                {
                    if (s.Properties.Contains (" ARC "))
                    {
                        print ("Rising speed of " + s.Name + " is " + s.Speed + " and falling speed is " + s.Speed);
                        displayMapMovement (exec, startingLoc, startingHeight, startingLoc, exec.Potency (exec.Airborne) + s.Speed, "AirNeutral", (s.Speed + 1) * 4, false, null, startingLoc.DirectionOf (loc));
                        displayMapMovement (exec, startingLoc, exec.Potency (exec.Airborne) + 5, exec.currentLocation (), exec.Potency (exec.Airborne), "", (s.Speed + 1) * 4, true, s, startingLoc.DirectionOf (loc));
                    }
                    else
                    {
                        if (!s.Properties.Contains ("INVENTORY"))
                        {
                            displayMapMovement (exec, startingLoc, startingHeight, exec.currentLocation (), exec.Potency (exec.Airborne), "", (s.Speed + 1) * 4, false, s, startingLoc.DirectionOf (loc));
                        }
                    }
                }
            }


            //ACTIVE TIME/INPUT TIME
            if (!s.Properties.Contains ("MAP ") && (exec.Equals (activePlayer)))
            {
                if (!exec.CanAct)
                {
                    setInputTimer (2 + (float)(s.HitStun * (exec.Dexterity * 2)));
                }
                else if (!s.Properties.Contains ("AUTOLINK"))
                {
                    battleMap.ActiveTime += (float)(s.HitStun);
                    timeMax += (float)(s.HitStun);

                }
            }

            if (s.CanAct)
            {
                output += exec.setAction (true);
            }
        }
        else
        {
            if (!s.CostsMet)
            {
                output += string.Format ("{0} cannot use {1}, costs not met" + '\n', exec.FirstName, s.Name);
            }
            else if (!s.ConditionsMet)
            {
                if (!s.ClassConditionsMet)
                {
                    output += string.Format ("{0} cannot use {1}, class conditions not met" + '\n', exec.FirstName, s.Name);
                }
                else if (!s.AdleConditionsMet)
                {
                    output += string.Format ("{0} cannot use {1}, action conditions not met" + '\n', exec.FirstName, s.Name);
                }
                else if (!s.MovementConditionsMet)
                {
                    output += string.Format ("{0} cannot use {1}, movement conditions not met" + '\n', exec.FirstName, s.Name);
                }
                else
                {
                    output += string.Format ("{0} cannot use {1}, conditions not met" + '\n', exec.FirstName, s.Name);
                }
            }
        }


        if (s.Properties.Contains (" DECAY "))
        {
            exec.CurrentProration = decay * exec.Proration;
            print ("CURRENT PRORATION = " + ((int)(decay * 100)));
            //throw new NullReferenceException ("JUST GUY THINGS.");
        }

        if ((((s.HasConnected || s.WhiffSkills.Count > 0) && (s.EndLink || output.Contains ("***") || s.WhiffSkills.Count > 0))
            && !s.Properties.Contains ("NODECAY "))
            || s.Name.Equals ("Pace Cancel") && !s.Properties.Contains ("AUTOLINK"))
        {

            exec.CurrentProration = decay * exec.Proration;
            //output += string.Format ("{0} power decays to {1}%" + '\n', exec.FirstName, (int)(100 * exec.CurrentProration));
        }

        if (s.Properties.Contains ("RESETDECAY "))
        {
            exec.CurrentProration = exec.Proration;
        }


        print ("RETURNING! " + numReps);

        s.HitTargets = new ArrayList ();
        s.AllTargets = new ArrayList ();
        s.resetThresholdMeasure ();

        if (s.Properties.Contains (" FALL "))
        {
            exec.Grounded.Potency += 10;
            createAnimationOnMap ("Earth", EnvironmentChannel, getImageFromLocation (loc).transform.position, 2f, true);
        }

        //ITEM DROP
        if (s.Properties.Contains ("DROP"))
        {
            output += itemDrop (exec, s, loc);
        }

        if (!independent)
        {
            //SET TARGETLESS CHAINS

            if (cancelledOut)
            {
                print ("CANCELLED OUT!");
            }
            else
            {
                print ("NOT CANCELLED OUT!");
            }

            if (!cancelledOut
                && ((s.Targetless || s.OnWhiff || (s.EndLink && s.HasConnected) || (s.WhiffSkills.Count > 0 && !s.HasConnected)))
                && s.LinkSkills.Count > 0
                && s.Links.Length == 0
                && !output.Contains ("***"))
            {
                //) {
                output += "*** END/TGLESS LINK " + s.Name + '\n';
                print ("*** END/TGLESS LINK " + s.Name + '\n');

                //AUTOLINK TARGETLESS SKILLS
                if ((s.Properties.Contains ("AUTOLINK")) && exec.setCostsAndConditionsMet (s.LinkSkills))
                {

                    //NON RANDOMLINK TARGETLESS
                    if (!s.Properties.Contains ("RANDOMLINK"))
                    {
                        //AUTOMATICALLY LINKS TARGETLESS SKILL ON TARGET
                        if (s.Properties.Contains ("ONTARGET") && s.AllTargets.Count > 0)
                        {

                            s.HitTargets = new ArrayList ();
                            s.AllTargets = new ArrayList ();
                            s.resetThresholdMeasure ();
                            if (!exec.KOd && !exec.Name.Contains ("Owner") && !s.ObjectSkill && s.HasConnected && !s.Properties.Contains ("NOEXP "))
                            {
                                output += gainExperience (exec, Math.Abs (s.SkillOutput));
                            }

                            output += string.Format ("{0} follows up on {1}!" + '\n', exec.FirstName, ((Player)s.AllTargets[0]).FirstName);

                            if (s.WhiffSkills.Count == 0 || s.HasConnected)
                            {
                                output += executeSkill (exec, (Skill)s.LinkSkills[0],
                                    ((Player)s.AllTargets[0]).currentLocation (),
                                    exec.currentLocation ().DirectionOf ((Player)s.AllTargets[0]),
                                    true, true, independent, exec.CurrentProration);
                            }
                            else
                            {
                                output += executeSkill (exec, (Skill)s.WhiffSkills[0],
                                    ((Player)s.AllTargets[0]).currentLocation (),
                                    exec.currentLocation ().DirectionOf ((Player)s.AllTargets[0]),
                                    true, true, independent, exec.CurrentProration);
                            }
                            new DataReader ().printOutputs (battleMap.Team1, battleMap.Team2, battleMap.SearchName, true, output);
                            return output;
                            //OTHERWISE, EXECUTES AUTOLINK SKILL ON NO TARGET
                        }
                        else
                        {

                            s.HitTargets = new ArrayList ();
                            s.AllTargets = new ArrayList ();
                            s.resetThresholdMeasure ();
                            if (!exec.KOd && !exec.Name.Contains ("Owner") && !s.ObjectSkill && s.HasConnected && !s.Properties.Contains ("NOEXP "))
                            {
                                output += gainExperience (exec, Math.Abs (s.SkillOutput));
                            }

                            cancelledOut = true;
                            output += string.Format ("{0} follows up on {1}!" + '\n', exec.FirstName, s.Name);
                            if (!battleMap.isValid (exec.currentLocation ().getNewLocationFromDirection (direct)))
                            {
                                direct = "";
                            }

                            output += executeSkill (exec, (Skill)s.LinkSkills[0],
                                loc, direct, true, true, independent, exec.CurrentProration);

                            new DataReader ().printOutputs (battleMap.Team1, battleMap.Team2, battleMap.SearchName, true, output);
                            return output;
                        }
                    }

                    //OTHERWISE, RANDOMLY SELECTS ONE SKILL OUT OF S LINKSKILLS AND EXECUTES ON TARGET LOCATION
                    else
                    {
                        output += string.Format ("Random follow-up!" + '\n');
                        Skill sk = (Skill)s.LinkSkills[exec.R.Next (s.LinkSkills.Count)];
                        int i = 0;
                        while (!sk.CostsAndConditionsMet && i < s.LinkSkills.Count)
                        {
                            if (!sk.ConditionsMet && sk.Properties.Contains ("REMOVE"))
                            {
                                exec.forget (sk);
                            }
                            sk = (Skill)s.LinkSkills[exec.R.Next (s.LinkSkills.Count)];
                            i++;
                        }
                        if (sk.CostsAndConditionsMet)
                        {
                            if (!battleMap.isValid (exec.currentLocation ().getNewLocationFromDirection (direct)))
                            {
                                direct = "";
                            }

                            output += executeSkill (exec, sk, loc, direct,
                                true, true, independent, exec.CurrentProration);
                        }
                        else
                        {
                            output += string.Format ("No random follow-up." + '\n');
                        }

                    }

                }

                //MANUAL TARGETLESS SKILLS
                else
                {

                    if (!exec.setCostsAndConditionsMet (s.LinkSkills))
                    {
                        output += string.Format ("NAH!" + '\n');
                    }
                    if (!s.Properties.Contains ("AUTOLINK"))
                    {
                        output += string.Format ("MANG?" + '\n');
                    }

                    output += "*** OTHER TGLESS LINK " + s.Name + '\n';

                    //FOLLOWUP SKILLS, LINKED AFTER ANOTHER AUTO SKILL
                    if (s.Properties.Contains ("FOLLOWUP") && exec.setCostsAndConditionsMet (exec.BurstFollowUpSkills))
                    {
                        output += string.Format ("Follow-up options!" + '\n');
                        exec.BurstFollowUpSkills = s.LinkSkills;
                        exec.ChainSkills = new ArrayList ();
                    }

                    //OTHERWISE, NORMAL LINKED SKILL
                    else
                    {
                        output += string.Format ("{0}: non-autolinked follow-up options!" + '\n', s.Name);
                        if (s.WhiffSkills.Count == 0)
                        {
                            exec.ChainSkills = s.LinkSkills;
                        }
                        else if (!s.HasConnected)
                        {
                            exec.ChainSkills = s.WhiffSkills;
                        }
                        print ("Skill is linked");
                    }
                }
            }
            else if (cancelledOut || (s.LinkSkills.Count == 0 && s.WhiffSkills.Count == 0 && !s.CanAct))
            {
                if (!output.Contains ("ends!") || !output.Contains ("(for " + exec.FirstName + ")"))
                {
                    if (s.ThresholdMeasure == 0)
                    {
                        output += string.Format ("Threshold 0" + '\n');
                    }
                    if (cancelledOut)
                    {
                        output += string.Format (s.Name + " Cancelled out." + '\n');
                    }

                    output += string.Format ("{0} ends! (for {1})" + '\n', s.Name, exec.FirstName);
                }
                exec.ChainSkills = new ArrayList ();
            }
            else
            {


                if (!exec.setCostsAndConditionsMet (exec.BurstFollowUpSkills))
                {
                    exec.BurstFollowUpSkills = new ArrayList ();
                    print ("NO BURST FOLLOW UPS " + s.Name);
                }
            }
        }

        if (!exec.InPlay)
        {
            new DataReader ().printOutputs (battleMap.Team1, battleMap.Team2, battleMap.SearchName, true, output);
            return output;
        }

        if (!exec.currentMap ().Interactables.Contains (s))
        {
            s.resetThresholdMeasure ();
        }
        if (!exec.KOd && !exec.Name.Contains ("Owner") && !s.ObjectSkill && s.HasConnected && !s.Properties.Contains ("NOEXP "))
        {
            output += gainExperience (exec, Math.Abs (s.SkillOutput));
        }

        s.HitTargets.Clear ();
        s.AllTargets.Clear ();
        output += string.Format (exec.ActiveSpeed + " is the present speed" + '\n');

        if (!s.Properties.Contains ("TIMESTOP "))
        {
            //  output += IncrementSingleTurnActions (exec, allTargets, s.ObjectSkill || s.Properties.Contains ("DIRECTION"), s);
        }
        new DataReader ().printOutputs (battleMap.Team1, battleMap.Team2, battleMap.SearchName, true, output);

        updateMap ();
        return output;
    }

    private ArrayList executeSkillOnLocation (Player exec, Skill s, Location targetLoc, Location loc, Location baseLoc, double decay, string dir, Boolean independent)
    {
        string output = "";
        DataReader reader = new DataReader ();
        double chance = 0;
        double maxChance = 0;
        Boolean hitTarget = false;
        Boolean parry = false;
        Boolean cancelledOut = false;
        Boolean thresholdDown = false;
        Boolean dropped = false;
        Boolean multihitThresholdDown = false;
        Location fallLoc = null;
        Location properLoc = null;
        Player newTarget;
        s.UsedNow = false;

        Skill trap = null;
        Skill placeSkill = null;

        Player executor = exec;
        Player target = new Player (-1, "null", "", "", "", "", "", "", "", 0, 0.0, 0.0, "", "", 0, -1, false, true);


        Skill sk = null;
        int sIndex = 0;

        if (s.Properties.Contains ("RANDOMLOC"))
        {
            loc = (Location)s.Locations[exec.R.Next (s.Locations.Count)];
            targetLoc = loc;
            if (s.Properties.Contains ("RANDOMLOCEMPTY"))
            {
                while (!battleMap.isEmpty (loc) || !battleMap.isEmptyInteractable (loc) || !battleMap.isEmptyProjectile (loc))
                {
                    loc = (Location)s.Locations[exec.R.Next (s.Locations.Count)];
                    targetLoc = loc;
                }
            }
        }


        if (s.TrapSkill != null)
        {
            s.TrapSkill.Location = targetLoc;

            trap = s.TrapSkill.CloneSkill;

            if (s.TrapSkill.Owner == s.Owner)
            {
                s.Owner = exec;
                if (s.Owner == null)
                {
                    throw new NullReferenceException ("NOT THE SAME MAN");
                }
                else if (s.TrapSkill.Owner == null)
                {
                    throw new NullReferenceException ("IT'S NOT THE SAME MAN");
                }
            }
        }

        if (s.CounterSkill != null)
        {

        }

        int heightDiff = exec.currentMap ().heightDifference (exec.currentLocation (), targetLoc);
        //currentMap ().heightOf (currentLocation ()) - currentMap ().heightOf (loc);

        //ITEM DROP
        if (!s.LineSkill && s.Properties.Contains ("DROP"))
        {
            output += itemDrop (exec, s, loc);
        }

        if (s.Properties.Contains (" MOVEEACH ")
            && exec.openBorderOf (loc, true, s) != null)
        {
            //output += "MOVEEACH: " + FirstName + " to " + loc + '\n';
            output += recordMovement (exec, s, loc, !s.Properties.Contains ("MOVEOFF "), false,
                s.Properties.Contains ("TELEPORT") || exec.Flight, false, true, !s.Properties.Contains ("DODGE"), "");
        }

        if (s.Properties.Contains (" FLIP ") && s.Targetless)
        {
            output += switchPastLocation (exec, loc, s);
        }

        if (!s.SelfSkill && !exec.currentMap ().lineSkillCanReach (s, loc) && !s.Properties.Contains ("NOPUSH"))
        {
            output += string.Format ("{0} hits a wall! {1}" + '\n', s.Name, loc);

            createAnimationOnMap ("Contact", EnvironmentChannel, getImageFromLocation (loc).transform.position, 2f, true);

            //if (!s.SuperProjectile && !s.SForce && !s.Individual) {
            if (!s.Nonstop)
            {
                cancelledOut = true;
                //if (!s.Individual && !currentMap ().Interactables.Contains (s)) {
                if (!s.Individual)
                {
                    s.ThresholdMeasure = 0;
                }
                return new ArrayList () { output, target, cancelledOut, executor };
            }
        }

        if (s.LineSkill
            && (s.Projectile || s.SForce || s.SuperProjectile)
            && !s.Properties.Contains ("ALONGGROUND")
            && exec.lineHeightDifferenceTooLarge (s, heightDiff, targetLoc, loc)
            && !s.Nonstop)
        {
            //output += string.Format ("{0} not in target range" + '\n', loc);
            return new ArrayList { output, target, cancelledOut, executor };
        }

        if (exec.skillHeightCanChange (s, loc) && !s.Physical)
        {
            s.CurrentHeight = exec.currentMap ().heightOf (loc);
            if (s.LineSkill && s.MotionSkill)
            {
                exec.UnitHeight = exec.currentMap ().heightOf (loc);
            }
        }

        if (s.ObjectSkill)
        {
            properLoc = s.Owner.openInteractableOf (loc, true);
        }

        //EXPENDABLE AMMO
        Item itm = null;

        if (s.Properties.Contains (" AMMOEACH ") &&
            !s.NoConditions && !s.ExpendableAmmo.Equals ("N/A") && !s.Owner.NoConditions
            && exec.inventoryGet (s.ExpendableAmmo) != null)
        {

            itm = exec.inventoryGet (s.ExpendableAmmo);

            if (itm == null)
            {
                throw new Exception (s.ExpendableAmmo);
            }

            if (!s.Properties.Contains ("DEPLETE "))
            {
                itm.NumUses -= s.ItemsPerUse;
                addToNotificationQueue (s, exec, "DEPLETE -" + s.ItemsPerUse + " " + itm.Name, true);
            }
            else
            {
                itm.NumUses = 0;
                addToNotificationQueue (s, exec, "DEPLETE -" + itm.Name, true);
            }

            /**
            if (itm.NumUses > 0) {
                output += string.Format ("{0} has {1} uses left." + '\n', itm.Name, itm.NumUses);
            } else {
                output += string.Format ("{0} depleted." + '\n', itm.Name);
                if (s.Properties.Contains ("REMOVE")) {
                    s.Owner.forget (s);
                }
            }
            */
        }

        if (itm != null && itm.NumUses == 0)
        {
            cancelledOut = true;
        }

        //NET SKILL
        if (s.Properties.Contains (" NET "))
        {

            output += string.Format ("{0} net activated on {1}!" + '\n', s.SearchName, loc);

            if (exec.currentMap ().locationInHeightRange (loc, s)
                && s.setCostsAndConditionsMet (s.LinkSkills))
            {

                Skill skl = null;
                int indx = 0;

                if (s.Properties.Contains ("RANDOMLINK"))
                {
                    while ((skl == null || !skl.CostsAndConditionsMet) && indx < s.LinkSkills.Count)
                    {
                        if (skl != null && !skl.ConditionsMet && skl.Properties.Contains ("REMOVE"))
                        {
                            exec.forget (skl);
                        }
                        skl = (Skill)s.LinkSkills[exec.R.Next (s.LinkSkills.Count)];
                        indx++;
                    }
                }
                else
                {
                    skl = (Skill)s.LinkSkills[0];
                }

                if (skl != null)
                {
                    output += executeSkill (exec, skl, loc,
                                                       exec.DirectionOf (loc), false, true, skl.Individual, 1.0);
                }
                else
                {
                    return new ArrayList { output, target, cancelledOut, executor };
                }
            }
        }


        //SKILL: PLAYER IN LOCATION
        else if ((exec.currentMap ().locationInHeightRange (loc, s))
            && !exec.currentMap ().isEmpty (loc)
            && exec.currentMap ().objectAt (loc).sentient ()
            && !s.HitTargets.Contains ((Player)exec.currentMap ().objectAt (loc))
            && s.properAllegiance ((Player)exec.currentMap ().objectAt (loc))
            && s.ThresholdMeasure > 0)
        {

            //print (s.Name + " TESTING 3");

            if (exec.skillHeightCanChange (s, loc))
            {
                s.CurrentHeight = exec.currentMap ().heightOf (loc);
            }

            newTarget = (Player)exec.currentMap ().objectAt (loc);
            print (newTarget.FirstName + " " + loc);

            output += string.Format ("Target locked: {0}" + '\n', newTarget.FirstName);


            if (s.Grapple)
            {
                createAnimationOnMap ("Contact", ContactChannel, getImageFromLocation (loc).transform.position, 2f, false);
            }

            if (!s.AllTargets.Contains (newTarget))
            {
                s.AllTargets.Add (newTarget);
            }

            Location targetOldLoc = new Location (newTarget.currentLocation ().Row, newTarget.currentLocation ().Column, newTarget.currentLocation ().Height);
            int targetOldHeight = newTarget.Potency (newTarget.Airborne);

            //FOR EACH REP, CHECK WHETHER SKILL WILL CONNECT
            for (int i = 0; i < s.Reps && newTarget.OnField && ((!newTarget.KOd || ((s.Properties.Contains ("KOD ") || s.Properties.Contains ("ALLST ")) && newTarget.CanBeRevived)) && !cancelledOut); i++)
            {
                target = newTarget;

                exec.LastTarget = newTarget;


                if (s.Malicious && !s.NoCombo)
                {
                    exec.AttacksPerRound++;
                    exec.AttacksTotal++;
                    print (s.Name + " Combo+ " + exec.AttacksPerRound);
                }

                output += string.Format (" " + '\n');

                maxChance = s.hitChance (newTarget) + exec.CurrentHitRate;

                if (!s.Auto && !target.StateActive (target.Daze) && !target.StateActive (target.Sleep))
                {
                    chance = exec.R.NextDouble ();

                    //Higher chance of hitting
                    if (s.Cost[3] != 0)
                    {
                        maxChance += Math.Abs ((double)s.Cost[3]) / 650;
                    }

                    //Connect depends on which direction opponent is facing
                    if (!s.Properties.Contains ("MAP"))
                    {
                        if ((exec.Direction.Contains ("N") && newTarget.Direction.Contains ("N"))
                            || (exec.Direction.Contains ("S") && newTarget.Direction.Contains ("S")))
                        {

                            maxChance += 0.15;
                        }

                        if ((exec.Direction.Contains ("E") && newTarget.Direction.Contains ("E"))
                            || (exec.Direction.Contains ("W") && newTarget.Direction.Contains ("W")))
                        {

                            maxChance += 0.15;
                        }
                    }


                    if (!s.Grapple)
                    {
                        maxChance += (0.05 * newTarget.Fatigue);

                        if (s.Malicious && !s.Properties.Contains ("NOTEAM "))
                        {

                            if (exec.MyTeam != null && newTarget.sameTeam (exec) && !s.Neutral && !exec.StateActive (exec.Confuse))
                            {
                                maxChance -= (((double)exec.Teamwork) / 50) + (((double)newTarget.Teamwork) / 500);
                            }
                        }

                        if (!newTarget.StateActive (newTarget.Confuse))
                        {
                            maxChance += ((double)newTarget.Stun.MeterLevel) / 500;
                        }
                        else
                        {
                            maxChance += ((double)newTarget.Stun.MeterMax) / 500;
                        }
                    }

                    if (s.Properties.Contains ("ACC"))
                    {
                        maxChance += exec.span (newTarget) * NumberConverter.ConvertToDouble (s.Properties.Substring (s.Properties.IndexOf ('%') + 1, 6));
                    }

                    if (newTarget.StateActive (newTarget.Parry)
                        && (!s.Grapple || (target.CounterSkill != null && target.canCounter (target, s)))
                        //&& canCounter (newTarget, s)) {
                        && (target.CounterSkill == null || target.CounterSkill.canCounter (s)))
                    {

                        parry = true;
                        if (target.CounterSkill == null
                            || target.CounterSkill.canCounter (s))
                        {

                            maxChance -= (newTarget.Dexterity * newTarget.Potency (newTarget.Parry) / 2);
                        }
                    }
                }
                else
                {
                    chance = -1000;
                }

                if (maxChance > 1)
                {
                    maxChance = 1;
                }

                output += string.Format ("x{0} ({1}%)" + '\n', i + 1, (int)(maxChance * 100));

                if (s.Auto || ((s.properHitSection (newTarget) && (!s.Grapple || (target.GuardStun == 0 && target.HurtStun == 0) || s.Properties.Contains ("JUMP") || s.Properties.Contains ("LEAP") || s.Properties.Contains ("LAND "))) || hitTarget)
                    &&
                     //(newTarget.StateActive (newTarget.Daze) || newTarget.StateActive (newTarget.Sleep) || 
                     (chance < maxChance))
                {

                    print (newTarget.FirstName + " is added: " + s.Name);

                    //TURN BACK OFF

                    if (newTarget.StateActive (newTarget.Daze))
                    {
                        if (exec.Daze.NumTurns == 1)
                        {
                            output += exec.Daze.IncrementVariants + '\n';
                        }
                        else
                        {
                            string whatever = exec.Daze.IncrementVariants;
                        }
                    }

                    target = newTarget;
                    hitTarget = true;
                    s.HasConnected = true;
                    s.UsedNow = true;

                    if (target.StateActive (target.Confuse) && target.IsGuarding)
                    {
                        if (target.R.NextDouble () < ((double)target.Potency (target.Confuse)) / 5)
                        {
                            target.IsGuarding = false;
                        }
                    }

                    if ((!s.Multihit || (s.Properties.Contains ("AIRMULTI") && !target.StateActive (target.Airborne))) && !s.HitTargets.Contains (target))
                    {
                        s.HitTargets.Add (target);
                        if (!s.Individual && !s.SelfSkill && !multihitThresholdDown)
                        {
                            thresholdDown = true;
                            s.ThresholdMeasure--;
                            output += string.Format ("Threshold Down! (A)" + '\n');
                        }
                        else
                        {
                            thresholdDown = false;
                        }
                    }

                    if (s.Multihit && !s.Individual && !s.SelfSkill)
                    {
                        thresholdDown = true;
                        output += string.Format ("Threshold Down! (B)" + '\n');
                        s.ThresholdMeasure--;
                    }

                    if (!independent)
                    {
                        print ("CHECKING CHAIN");
                        if (!s.Targetless && !s.EndLink
                            && (s.Links.Length > 0 && s.Links[i])
                            && (!s.Properties.Contains ("BORDERONLY") || newTarget.OnBorder)
                            && (!s.Properties.Contains ("AIRONLY") || newTarget.StateActive (newTarget.Airborne) && !newTarget.AirOff)
                            && (!s.Properties.Contains ("GROUNDONLY") || newTarget.StateActive (newTarget.Grounded))
                            && (!s.Properties.Contains ("STANDONLY") || (!newTarget.StateActive (newTarget.Airborne)))
                            && (!s.Properties.Contains ("CTRONLY") || newTarget.ResidualFatigue > 0 || newTarget.Fatigue > 0)
                            && s.setCostsAndConditionsMet (s.LinkSkills)
                            //&& (s.EndLink || s.Links [i])
                            && !output.Contains ("***"))
                        {

                            output += "*** HIT LINK " + s.Name + " " + s.ThresholdMeasure + '\n';
                        }
                    }

                    //ITEM DROP
                    if (s.LineSkill && s.Properties.Contains ("DROP") && !dropped)
                    {
                        output += itemDrop (exec, s, loc);
                    }

                    if (!s.Malicious)
                    {
                        output += string.Format ("{0} is activated for {1}!" + '\n', s.Name, target.FirstName);
                    }

                    if (s.Malicious)
                    {
                        if (target.Fatigue > 0 && target != exec && (s.MasterSkill == null || !s.MasterSkill.Properties.Contains ("AUTOLINK")))
                        {
                            exec.LongestCombo.Add ("*COUNTER*");
                            announce ("counter");

                        }

                        target.WasHit = true;
                        if (target.HurtStun > 0)
                        {
                            s.Combo = true;
                        }
                        else
                        {
                            s.Combo = false;
                        }

                        if (s.Reps > 1)
                        {
                            multihitThresholdDown = true;
                        }

                        if (s.Grapple)
                        {
                            exec.SetFatigue (0);
                        }

                        if (s.Properties.Contains ("LAND ") || s.Properties.Contains ("LANDONHIT "))
                        {
                            exec.SetHeight (0);
                        }

                        if (s.Properties.Contains ("FOLLOW "))
                        {
                            exec.SetHeight (target.Potency (target.Airborne));
                        }

                        if (s.Malicious && target.Equals (activePlayer))
                        {
                            skill = null;
                            setSkill (null, -1, null);
                            updateActivePlayer ();
                            updatePlayerInfo ();
                        }

                        if (!s.Grapple)
                        {
                            output += string.Format ("{0} connects on {1}!" + '\n', s.Name, target.FirstName);

                        }
                        else
                        {
                            output += string.Format ("{0} grabs {1}!" + '\n', exec.FirstName, target.FirstName);
                        }

                        if (maxChance != 1 && chance >= 0)
                        {
                            output += string.Format (" ({0}% of {1}%)", (int)(100 * chance), (int)(100 * maxChance));
                        }
                        if (thresholdDown)
                        {
                            output += string.Format (" [Threshold: {0}] ", s.ThresholdMeasure + 1);
                        }

                        if (exec.AttacksPerRound > 0)
                        {
                            output += string.Format (" [Combo: {0}/{1}] ", exec.ConnectsPerRound, exec.AttacksPerRound);
                        }

                        if (s.Malicious)
                        {
                            target.Direction = getOppositeDirection (exec.Direction);
                        }

                        output += string.Format (" " + '\n' + '\n');

                        if (target.StateActive (target.Invisible))
                        {
                            double invChance = exec.R.NextDouble ();
                            if (invChance > ((double)target.Potency (target.Invisible)) / 10)
                            {
                                output += target.Invisible.ClearStates + '\n';
                            }
                        }
                        if (!s.Properties.Contains ("MAP "))
                        {
                            if (s.CanAct && !s.Targetless)
                            {
                                output += exec.setAction (true);
                                exec.HasActed = true;
                            }
                        }
                    }

                    if (s.Beneficial && !s.SelfSkill)
                    {
                        output += string.Format ("{0} activates on {1}!", s.Name, target.FirstName);

                        if (maxChance != 1 && chance >= 0)
                        {
                            output += string.Format (" ({0}% of {1}%)", (int)(100 * chance), (int)(100 * maxChance));
                        }

                        if (thresholdDown)
                        {
                            output += string.Format (" [Threshold: {0}] ", s.ThresholdMeasure + 1);
                        }

                        output += string.Format (" " + '\n');
                    }

                    if (s.Properties.Contains ("STAYON"))
                    {
                        exec.LockedOnTarget = target;
                    }
                    else
                    {
                        exec.LockedOnTarget = null;
                    }

                    //CLEAR TIMED SKILL
                    if (s.Properties.Contains ("CLRTM"))
                    {
                        string forgottenSkill = s.Properties.Substring (s.Properties.IndexOf (':') + 1);
                        for (int ind = 0; ind < target.TimeActivatedSkills.Count; ind++)
                        {
                            if (forgottenSkill.Contains (((Skill)target.TimeActivatedSkills[ind]).SearchName))
                            {
                                target.TimeActivatedSkills.RemoveAt (ind);
                            }
                        }
                    }

                    //END STATES
                    output += execEndStates (exec, s, target);
                    output += execSetResistances (s, target);

                    if (s.Properties.Contains (" FLIP ") && !s.Targetless)
                    {
                        output += switchPastLocation (exec, loc, s);
                    }

                    if (!target.StateActive (target.Invulnerable))
                    {
                        if (s.Properties.Contains ("TOSS "))
                        {
                            output += flipTarget (exec, target, s);
                        }

                        if (s.Properties.Contains ("PULL "))
                        {
                            output += pullTarget (exec, target, s);
                        }
                    }

                    if (s.Properties.Contains ("ENDTIMESKILL"))
                    {
                        string skillName = s.Properties.Substring (s.Properties.IndexOf (':') + 1);
                        for (int j = 0; j < exec.TimeActivatedSkills.Count; j++)
                        {
                            if (((Skill)exec.TimeActivatedSkills[j]).SearchName.Equals (skillName))
                            {
                                exec.TimeActivatedSkills.Remove (exec.TimeActivatedSkills[j]);
                                break;
                            }
                        }
                    }

                    //UNGUARD ON CERTAIN CONDITIONS
                    if (target.IsGuarding &&
                        (!target.AutoGuard && ((s.Overhead && target.IsCrouching)
                            || (s.Low && target.IsStanding)))
                        || (s.Grapple)
                        || s.Properties.Contains ("UNBLOCKABLE"))
                    {
                        output += target.Unguard;
                    }

                    if (s.Malicious && !target.IsGuarding)
                    {
                        target.HurtStun = s.HitStun + 1;
                        if (s.HitStun > 0)
                        {
                            target.Staggered = false;
                            target.StaggerDirection = "";
                            target.StaggerTime = -1;
                        }

                        if (target.Vocals.Speech == null)
                        {
                            throw new NullReferenceException ("VOICE SAMPLE IS MISSING");
                        }
                    }

                    if (s.Malicious && !s.NoCombo && (!target.IsGuarding || s.Grapple))
                    {
                        exec.ConnectsPerRound++;
                        exec.ConnectsTotal++;
                    }

                    if (s.Malicious && target.IsGuarding && !s.Grapple && !s.Properties.Contains ("UNBLOCKABLE"))
                    {
                        exec.AttacksTotal--;
                        exec.AttacksPerRound--;
                    }

                    //METERS, FORCE, STATS, AND STATES
                    if (!s.Properties.Contains ("NOMETER ")
                        && (s.Change[0] != 0 || s.Change[1] != 0 || s.Change[2] != 0 || s.Change[3] != 0))
                    {
                        output += meterChange (exec, s, target, cancelledOut, decay);
                    }

                    if (s.Properties.Contains ("MUSICCHANGE:"))
                    {
                        bgm.clip = Resources.Load<AudioClip>(@"Music/" + s.Properties.Substring (s.Properties.IndexOf (':') + 1));
                        playBGM();
                    }

                    if (!target.KOd)
                    {
                        if (!s.Malicious || !target.IsGuarding)
                        {
                            output += statAugments (exec, s, target, decay);
                            output += stateAugments (exec, s, target, decay);
                        }
                        else if (s.Malicious && target.IsGuarding && s.StateAlterations[0].Potency > 0)
                        {
                            if (s.HitStun <= 1)
                            {
                                target.GuardStun = 1;
                            }
                            else
                            {
                                target.GuardStun = (int)(s.HitStun * decay) / 2;
                            }
                            output += string.Format ("{0} Guard Stun {1}" + '\n', target.FirstName, target.GuardStun);
                        }
                        output += elements (exec, s, target, decay);

                        //TRANSFORMATION
                        if (s.Properties.Contains ("FUSION"))
                        {
                            Boolean criticalActive = target.CriticalActive;
                            print (s.Conditions[0].Substring (s.Conditions[0].IndexOf (':') + 1));
                            target.AbsorbedPlayer = target.pairedCharacter (s.Conditions[0].Substring (s.Conditions[0].IndexOf (':') + 1));
                            battleMap.removeObject (target.AbsorbedPlayer);
                        }
                        if (s.Properties.Contains ("REVERT") && target.StoredPlayer != null)
                        {
                            target.transform (target.StoredPlayer, false, target.CriticalActive, !s.Properties.Contains ("METERS "), -1);
                        }
                        else if (s.Properties.Contains ("TRANSFORM"))
                        {
                            int transTime = NumberConverter.ConvertToInt(s.Properties.Substring(s.Properties.IndexOf ('&') + 1, 3));
                            DataReader newReader = new DataReader ();
                            Player trans = newReader.loadPlayer (s.Properties.Substring (s.Properties.IndexOf (':') + 1), "Player", true, true, true);
                            trans.PlayStyle = target.PlayStyle;
                            trans.CurrentMap = battleMap;
                            output += target.transform (trans, true, target.CriticalActive, !s.Properties.Contains ("METERS "), transTime);
                        }
                        else if (s.Properties.Contains ("CHANGE"))
                        {
                            int transTime = NumberConverter.ConvertToInt(s.Properties.Substring(s.Properties.IndexOf('&') + 1, 3));
                            DataReader newReader = new DataReader ();
                            Player trans = newReader.loadPlayer (s.Properties.Substring (s.Properties.IndexOf (':') + 1), "Player", true, true, true);
                            trans.PlayStyle = target.PlayStyle;
                            trans.CurrentMap = battleMap;
                            output += target.transform (trans, false, target.CriticalActive, !s.Properties.Contains ("METERS "), -1);
                        }

                        //pentagon.hack (EVERYTHING EVER);

                        muteSound ();

                        if (s.Properties.Contains ("FULLHEAL"))
                        {
                            output += shiftHealth (target, target.Health.MeterMax, true, target, s);
                        }

                        if (s.Properties.Contains (" LRNALL "))
                        {

                            print (target.FirstName.ToUpper () + string.Format (" LEARNS " + target.FirstName.ToUpper ()));
                            addToNotificationQueue (s, exec, exec.FirstName.ToUpper () + string.Format (" LEARNS " + target.FirstName.ToUpper ()), true);
                            exec.AssimilatedClass = target.PlayerClass;
                            exec.AssimilatedTime = s.Speed;//Math.Abs (exec.Potency (exec.Learn));

                            for (int j = 0; j < target.AllSkills.Count; j++)
                            {
                                if (((Skill)target.AllSkills[j]).CanBeLearned)
                                {

                                    if (exec.StateActive (exec.Learn))
                                    {
                                        output += exec.learn ((Skill)target.AllSkills[j], true, Math.Abs (exec.Potency (exec.Learn)));
                                    }
                                    else
                                    {
                                        output += exec.learn ((Skill)target.AllSkills[j], true, Math.Abs (((Skill)target.AllSkills[j]).PowerIndex));
                                    }
                                }
                            }
                        }

                        //LEARNING SKILLS
                        if (s.LearnSkills.Count > 0)
                        {
                            int allSkl = exec.AllSkills.Count;
                            for (int j = 0; j < s.LearnSkills.Count; j++)
                            {
                                output += target.learn ((Skill)s.LearnSkills[j], true, ((Skill)s.LearnSkills[j]).TurnsRemaining);
                            }
                            if (allSkl != exec.AllSkills.Count)
                            {
                                addToNotificationQueue(s, exec, exec.FirstName.ToUpper() + string.Format(" LEARN!"), true);
                            }
                        }

                        //FORGET SKILLS
                        if (s.ForgetSkills.Count > 0)
                        {
                            for (int j = 0; j < s.ForgetSkills.Count; j++)
                            {
                                target.forget ((string)s.ForgetSkills[j]);
                            }
                        }

                        if (s.Properties.Contains ("FORGLRN "))
                        {
                            Skill forgSkl;
                            int ln1 = target.AllSkills.Count;

                            for (int j = 0; j < target.AllSkills.Count; j++)
                            {

                                ln1 = target.AllSkills.Count;

                                forgSkl = (Skill)target.AllSkills[j];
                                if (forgSkl.LearnedInField)
                                {
                                    output += target.forget (forgSkl);
                                }
                                if (ln1 > target.AllSkills.Count)
                                {
                                    j--;
                                }
                            }
                        }

                        if (s.Properties.Contains ("PRG-"))
                        {
                            if (s.Properties.Contains ("PRG-NRM "))
                            {
                                for (int j = 0; j < target.AllSkills.Count; j++)
                                {
                                    sk = (Skill)target.AllSkills[j];
                                    if (sk.Properties.Contains ("NORMAL ") && !sk.OriginalOwner.Equals (target))
                                    {

                                        output += target.forget (sk);

                                        if (!target.knows (sk))
                                        { j--; }
                                    }
                                }
                            }

                            if (s.Properties.Contains ("PRG-SPC "))
                            {
                                for (int j = 0; j < target.AllSkills.Count; j++)
                                {
                                    sk = (Skill)target.AllSkills[j];
                                    if (sk.Properties.Contains ("SPECIAL ") && !sk.OriginalOwner.Equals (target))
                                    {

                                        output += target.forget (sk);

                                        if (!target.knows (sk))
                                        { j--; }
                                    }
                                }
                            }

                            if (s.Properties.Contains ("PRG-VTA "))
                            {
                                for (int j = 0; j < target.AllSkills.Count; j++)
                                {
                                    sk = (Skill)target.AllSkills[j];
                                    if (sk.Properties.Contains ("VITALITY ") && !sk.OriginalOwner.Equals (target))
                                    {

                                        output += target.forget (sk);

                                        if (!target.knows (sk))
                                        { j--; }
                                    }
                                }
                            }

                            if (s.Properties.Contains ("PRG-BST "))
                            {
                                for (int j = 0; j < target.AllSkills.Count; j++)
                                {
                                    sk = (Skill)target.AllSkills[j];
                                    if (sk.Properties.Contains ("BURST ") && !sk.OriginalOwner.Equals (target))
                                    {

                                        output += target.forget (sk);

                                        if (!target.knows (sk))
                                        { j--; }
                                    }
                                }
                            }



                        }

                        //TIME ACTIVATED SKILLS
                        if (s.TimerSkill != null)
                        {
                            if (s.Neutral)
                            {
                                s.Owner = exec.currentMap ().MapOwner;
                                exec.currentMap ().MapOwner.learn (s, false, -30);
                            }
                            Skill timerSkill = s.TimerSkill.CloneSkill;
                            output += string.Format ("{0} is planted!" + '\n', timerSkill.Name);
                            timerSkill.Timer = s.Timer;
                            target.TimeActivatedSkills.Add (timerSkill);
                        }

                        //CAN REST
                        if (s.Properties.Contains ("NOREST "))
                        {
                            target.CanRest = false;
                        }
                    }

                    //CHECK LEARNING
                    if (s.canBeLearnedBy (target) && target.StateActive (target.Learn) && !target.knows (s))
                    {
                        if (!s.Standalone && (s.Properties.Contains (" CHILD ") || s.Properties.Contains (" MAP ")) && s.MasterSkill != null)
                        {
                            Skill skl = s.MasterSkill;
                            if (skl != null)
                            {
                                while (!skl.Properties.Contains ("MASTER ") && skl.MasterSkill != null)
                                {
                                    print (skl.SearchName + " to master");
                                    skl = skl.MasterSkill;
                                }
                                print (skl.SearchName + " is master");
                                if (!target.knows (skl) && !skl.Properties.Contains (" CHILD "))
                                {

                                    string learnOutput = target.learn (skl, true, Math.Abs (target.Potency (target.Learn) - (Math.Abs (skl.Cost[3] / 100))));
                                    output += learnOutput;
                                    if (target.Potency (target.Learn) > 0)
                                    {
                                        output += target.Learn.IncrementVariants;
                                    }
                                    print (learnOutput);
                                    //if (newTarget.getSkill (skl.SearchName) != null) {
                                    print (newTarget.FirstName.ToUpper () + " " + string.Format ("LEARNS " + skl.Name.ToUpper () + " (" + newTarget.Potency (newTarget.Learn) + ")"));
                                    addToNotificationQueue (s, newTarget, newTarget.FirstName.ToUpper () + " " + string.Format ("LEARNS " + skl.Name.ToUpper () + " (" + target.Learn.Potency + ")"), true);
                                    createAnimationOnMap ("Contact", ContactChannel, getImageFromLocation (newTarget.currentLocation ()).transform.position, 2f, true);
                                    //}
                                }
                            }
                        }
                        else if (!s.Properties.Contains (" CHILD "))
                        {

                            string learnOutput = target.learn (s, true, Math.Abs (target.Potency (target.Learn) - (Math.Abs (s.Cost[3] / 100))));
                            output += learnOutput;
                            if (target.Potency (target.Learn) > 0)
                            {
                                output += target.Learn.IncrementVariants;
                            }
                            print (learnOutput);
                            //if (newTarget.getSkill (s.SearchName) != null) {
                            print (newTarget.FirstName.ToUpper () + " " + string.Format ("LEARNS " + s.Name.ToUpper () + " (" + newTarget.Potency (newTarget.Learn) + ")"));
                            addToNotificationQueue (s, newTarget, newTarget.FirstName.ToUpper () + " " + string.Format ("LEARNS " + s.Name.ToUpper () + " (" + target.Potency (target.Learn) + ")"), true);
                            createAnimationOnMap ("Contact", ContactChannel, getImageFromLocation (newTarget.currentLocation ()).transform.position, 2f, true);
                            //}
                        }
                    }

                    //CHECK COUNTER
                    if (exec.canCounter (target, s))
                    {

                        double counterProb = exec.R.NextDouble ();

                        if (counterProb < ((double)target.Potency (target.Counter)) / 10)
                        {
                            output += string.Format ("{0} counters!" + '\n', target.FirstName);

                            if (s.Properties.Contains ("REFLECT "))
                            {

                                s.Owner = target;
                                s.setLocations ();
                                output += string.Format ("{0} is reflected!" + '\n', s.Name);

                                output += executeSkill (target, s, exec.currentLocation (),
                                    target.currentLocation ().DirectionOf (exec), false, true, independent, 1.0);

                            }
                            else
                            {


                                output += executeSkill (target, target.CounterSkill, exec.currentLocation (),
                                    target.currentLocation ().DirectionOf (exec), false, true, independent, 1.0);
                            }

                            exec.CounterPlayer = target;
                            if (target.CounterSkill.NumUses == 0)
                            {
                                target.Parry.Clear ();
                                target.Counter.Clear ();
                                target.Invulnerable.Clear ();
                                target.CounterSkill.NumUses = target.CounterSkill.MaxUses;
                                target.forget (target.CounterSkill);
                                if (target.IsCrouching)
                                {
                                    target.IsCrouching = false;
                                }
                            }
                            if (!s.Individual)
                            {
                                output += string.Format ("{0} stopped by counter!" + '\n', s.Name);
                                cancelledOut = true;
                            }
                        }
                        else
                        {
                            output += string.Format ("{0} fails to counter! ({1}% of {2}%)" + '\n',
                                                     target.FirstName, (int)counterProb * 100, target.Potency (target.Counter) * 10);
                        }
                    }
                    else
                    {
                        if (target.CounterSkill != null)
                        {

                        }
                        if (s.Grapple && !s.Properties.Contains ("NORMAL"))
                        {
                            target.Counter.Clear ();
                            target.Parry.Clear ();
                            target.Invulnerable.Clear ();
                            if (target.CounterSkill != null)
                            {
                                target.forget (target.CounterSkill);
                            }
                        }
                    }

                    output += checkContact (exec, target, s);
                    if (s.Physical || s.Grapple)
                    {
                        output += checkContact(target, exec, s);
                    }

                    /**
                    //CHECK CONTACT SKILLS
                    if (target.hasMadeContactWith (exec, s))
                    {
                        print ("WE'VE GOT A CONTACT!");

                        output += string.Format ("{0} makes contact with {1} and activates {2}!", target.FirstName, exec.FirstName, target.ContactSkill);
                            output += executeSkill (target, target.ContactSkill, exec.currentLocation (),
                                target.currentLocation ().DirectionOf (exec), false, true, independent, 1.0);

                            if (target.ContactSkill.NumUses == 0)
                            {
                                target.ContactSkill.NumUses = target.ContactSkill.MaxUses;
                                target.forget (target.ContactSkill);
                            }


                            if (exec.HurtStun > 1)
                            {
                                output += string.Format ("{0} is stopped!", exec.FirstName);
                                cancelledOut = true;
                            }

                        }

                        if (exec.hasMadeContactWith (target, s))
                        {
                        print ("WE'VE GOT A CONTACT!");

                        output += string.Format ("{0} makes contact with {1} and activates {2}!", exec.FirstName, target.FirstName, exec.ContactSkill);
                            output += executeSkill (exec, exec.ContactSkill, target.currentLocation (),
                                exec.currentLocation ().DirectionOf (target), false, true, independent, 1.0);

                            if (exec.ContactSkill.NumUses == 0)
                            {
                                exec.ContactSkill.NumUses = target.ContactSkill.MaxUses;
                                exec.forget (target.ContactSkill);
                            }

                    }
                    */


                    //CANCEL OUT TARGET FOLLOW UP SKILLS
                    if (s.Properties.Contains ("MAP "))
                    {
                        target.ChainSkills = new ArrayList ();
                        target.BurstFollowUpSkills = new ArrayList ();
                    }

                    if (!target.KOd && target.TimeRemaining != 0)
                    {
                        if (!target.InPlay || !target.OnField)
                        {
                            exec.Saves++;
                            target.InPlay = true;
                            target.OnField = true;
                        }
                    }

                    if (!cancelledOut && !target.StateActive (target.Invulnerable) && !s.Properties.Contains (" STAGGER") && (!s.Properties.Contains ("CTRSTAGGER") || target.ResidualFatigue == 0))
                    {
                        if (!s.Properties.Contains ("FLIP") && !s.Properties.Contains ("TOSS"))
                        {
                            //print ("FOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOORCE!!!!");

                            if (!s.Properties.Contains ("MAP "))
                            {
                                output += force (exec, s, target, baseLoc, cancelledOut, dir);
                                target.Direction = getOppositeDirection (exec.Direction);

                            }
                            else
                            {
                                output += force (exec, s, target, baseLoc, cancelledOut, s.Direction);
                                target.Direction = getOppositeDirection (s.Direction);

                            }
                        }
                        else
                        {
                            output += force (exec, s, target, baseLoc, cancelledOut, exec.currentLocation ().DirectionOf (target));
                        }
                        if (!exec.KOd && !target.KOd && s.Properties.Contains ("ENGAGE"))
                        {
                            output += string.Format ("{0} engages {1}!" + '\n', exec.FirstName, target.FirstName);
                        }
                    }
                    else if (target.StateActive (target.Invulnerable))
                    {
                        //print ("NOOOOOOOO        FOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOORCE!!!! " +  target.Potency (target.Invulnerable));

                    }

                    if (s.Properties.Contains (" TAUNT "))
                    {
                        target.IsTaunting = true;
                        createAnimationOnMap ("Taunt", StateChannel, target.CentralPosition, 3f, false);

                    }

                    if (s.Properties.Contains (" REST "))
                    {
                        target.IsResting = true;
                        createAnimationOnMap ("Rest", StateChannel, target.CentralPosition, 3f, false);
                    }


                    if (s.Properties.Contains ("LOCKON "))
                    {
                        if (exec.openBorderOf (target.currentLocation (), true, s) != null)
                        {
                            //&& currentMap ().canMakeMove (this, openBorderOf (target.currentLocation (), true, s), s)) {
                            output += string.Format ("{0} moves toward {1}!" + '\n', exec.FirstName, target.FirstName);
                            output += recordMovement (exec, s, exec.openBorderOf (target.currentLocation (), true, s), false, false,
                                s.Properties.Contains ("TELEPORT") || exec.Flight || s.Properties.Contains ("LEAP ")
                                || (exec.StateActive (exec.Airborne) && s.Properties.Contains ("STAY ")), false, true, !s.Properties.Contains ("DODGE"), "");
                        }
                    }

                    if (target.ResidualFatigue > 0 && !s.Properties.Contains ("NOCNTR "))
                    {
                        target.ResidualFatigue = 0;
                    }


                    if (!cancelledOut
                        && ((!s.EndLink && output.Contains ("***"))))
                    {

                        if (s.Properties.Contains ("AUTOLINK ")
                            && exec.setCostsAndConditionsMet (s.LinkSkills)
                            && (!s.Properties.Contains ("ONHIT ") || !target.IsGuarding))
                        {
                            output += string.Format ("{0} follows up! {1}" + '\n', exec.FirstName, s.Threshold);

                            if (!s.Properties.Contains ("RANDOMLINK"))
                            {

                                if (!battleMap.isValid (exec.currentLocation ().getNewLocationFromDirection (dir)))
                                {
                                    dir = "";
                                }

                                if (s.Force.Potency != 0 && !s.Properties.Contains (" NOHT "))
                                {
                                    if (s.HitTargets.Contains (newTarget))
                                    {
                                        displayMapMovement (newTarget, targetOldLoc, targetOldHeight, newTarget.currentLocation (), newTarget.Potency (newTarget.Airborne), "AirDamage", 2, false, s, newTarget.currentLocation ().DirectionOf (targetLoc));//(s.Speed + 1) * 4);
                                    }
                                    else
                                    {
                                        displayMapMovement (newTarget, targetOldLoc, targetOldHeight, newTarget.currentLocation (), newTarget.Potency (newTarget.Airborne), "AirNeutral", 2, false, s, newTarget.currentLocation ().DirectionOf (targetLoc));//(s.Speed + 1) * 4);
                                    }
                                }

                                output += executeSkill (exec, ((Skill)s.LinkSkills[0]), target.currentLocation (),
                                    dir, true, true, false, exec.CurrentProration);
                                if (!s.Nonstop)
                                {
                                    return new ArrayList { output, target, cancelledOut, executor };
                                }

                            }
                            else
                            {
                                sk = (Skill)s.LinkSkills[exec.R.Next (s.LinkSkills.Count)];
                                output += string.Format ("{0} random follow-up!" + '\n', s.Name);
                                sIndex = 0;

                                while (!sk.CostsAndConditionsMet && sIndex < s.LinkSkills.Count)
                                {
                                    if (!sk.ConditionsMet && sk.Properties.Contains ("REMOVE"))
                                    {
                                        exec.forget (sk);
                                    }
                                    sk = (Skill)s.LinkSkills[exec.R.Next (s.LinkSkills.Count)];
                                    sIndex++;
                                }

                                if (sk.CostsAndConditionsMet)
                                {
                                    if (!s.Nonstop)
                                    {
                                        cancelledOut = true;
                                    }

                                    s.HitTargets = new ArrayList ();
                                    s.AllTargets = new ArrayList ();
                                    s.resetThresholdMeasure ();
                                    if (!exec.KOd && !exec.Name.Contains ("Owner") && !s.ObjectSkill && s.HasConnected && !s.Properties.Contains ("NOEXP "))
                                    {
                                        output += gainExperience (exec, Math.Abs (s.SkillOutput));
                                    }

                                    if (!battleMap.isValid (exec.currentLocation ().getNewLocationFromDirection (dir)))
                                    {
                                        dir = "";
                                    }

                                    //if (!s.Properties.Contains ("MAP ")) {
                                    if (s.Force.Potency != 0)
                                    {
                                        displayMapMovement (target, targetOldLoc, targetOldHeight, target.currentLocation (), target.Potency (target.Airborne), "AirNeutral", 2, false, s, target.currentLocation ().DirectionOf (targetLoc));
                                    }
                                    //}

                                    output += executeSkill (exec, sk, loc,
                                        dir, true, true, false, exec.CurrentProration);
                                    if (!s.Targetless)
                                    {
                                        return new ArrayList { output, target, cancelledOut, executor };
                                    }
                                }
                                else
                                {
                                    string.Format ("No random follow-up." + '\n');
                                }
                            }

                            if (!s.Nonstop && s.WhiffSkills.Count == 0)
                            {
                                cancelledOut = true;
                                output += string.Format ("{0} Link Skills cancelled out!" + '\n', s.Name);
                            }


                        }
                        else if (!s.Properties.Contains ("AUTOLINK "))
                        {
                            if (s.Properties.Contains ("FOLLOWUP"))
                            {
                                output += string.Format ("{0}: extra follow-up options!" + '\n', s.Name);
                                exec.BurstFollowUpSkills = s.LinkSkills;
                                exec.ChainSkills = new ArrayList ();
                            }
                            else
                            {
                                exec.ChainSkills = s.LinkSkills;
                                print ("Skill is linked");
                            }
                        }
                        else
                        {
                            //output += string.Format ("No more chains, no autolink! " + s.Name);
                            exec.ChainSkills = new ArrayList ();
                        }

                    }

                }
                else
                {

                    s.HasConnected = false;

                    if (s.Continuous && !exec.currentMap ().isValid (loc.getNewLocationFromDirection (
                        exec.currentLocation ().DirectionOf (loc))))
                    {
                        //if (!s.Individual && !currentMap ().Interactables.Contains (s)) {
                        if (!s.Individual)
                        {
                            s.ThresholdMeasure = 0;
                            //print ();
                        }
                    }

                    if (s.LineSkill && !s.Continuous && s.willConnectToTarget (target))
                    {
                        //if (!s.Individual && !currentMap ().Interactables.Contains (s)) {
                        if (!s.Individual)
                        {
                            if (!multihitThresholdDown)
                            {
                                if (!s.Malicious || !newTarget.MyTeam.Equals (exec.MyTeam))
                                {
                                    s.ThresholdMeasure--;
                                }
                            }
                            if (s.ThresholdMeasure == 0 && !(s.Targetless || s.OnWhiff) && !output.Contains ("***") && s.WhiffSkills.Count == 0)
                            {
                                output += string.Format ("{0} finished!" + '\n', s.Name);
                                cancelledOut = true;
                            }
                        }
                    }

                    if (s.Grapple)
                    {
                        exec.AddFatigue (s.Recovery);

                        if (s.Properties.Contains ("LEAP"))
                        {
                            exec.SetHeight (exec.Potency (exec.Airborne) + s.Recovery);
                            exec.InRecovery = true;
                            exec.IsCrouching = false;
                        }
                        else
                        {
                            exec.SetHeight (0);
                            exec.InRecovery = false;
                        }
                    }

                    //ITEM DROP
                    if (s.LineSkill && s.Properties.Contains ("DROP") && !s.Continuous && !dropped)
                    {
                        output += itemDrop (exec, s, loc);
                    }

                    //HITS REMOVED
                    if (s.Malicious && !s.NoCombo && ((!s.properHitSection (newTarget)) || s.Owner.sameTeam (newTarget)))
                    {
                        //print (s.Name + " Combo-");
                        exec.AttacksPerRound--;
                        exec.AttacksTotal--;
                    }

                    //WHIFF
                    if (!parry && (s.willConnectToTarget (newTarget) || hitTarget))
                    {

                        if (s.Malicious && newTarget.MyTeam.Equals (exec.MyTeam))
                        {

                            output += string.Format ("{0} dodges! ({1}%)" + '\n',
                                newTarget.FirstName, (int)(100 * chance), (int)(100 * maxChance));
                            addToNotificationQueue (s, newTarget, newTarget.FirstName.ToUpper () + " " + string.Format ("DODGE! ({1}%)", (int)(100 * chance), (int)(100 * maxChance)), true);
                            createAnimationOnMap ("Whiff", WhiffChannel, getImageFromLocation (newTarget.currentLocation ()).transform.position, 2f, true);
                            if (!newTarget.StateActive (newTarget.Airborne))
                            {
                                createAnimationOnMap ("Whiff", WhiffChannel, getImageFromLocation (newTarget.currentLocation ()).transform.position, 2f, true);
                            }

                        }
                        else
                        {

                            if (s.Grapple && (newTarget.HurtStun > 0 || newTarget.GuardStun > 0))
                            {
                                output += string.Format ("{0} whiffs {1}. ({2}% of {3}%) [Combo: {4}/{5}]" + '\n',
                                    s.Name, newTarget.FirstName, (int)(100 * chance), (int)(100 * maxChance), exec.ConnectsPerRound, exec.AttacksPerRound);

                                addToNotificationQueue (s, newTarget, newTarget.FirstName.ToUpper () + " " + string.Format ("STUNNED! ({1}%)", (int)(100 * chance), (int)(100 * maxChance)), true);
                                createAnimationOnMap ("Whiff", WhiffChannel, getImageFromLocation (loc).transform.position, 2f, true);
                                if (!newTarget.StateActive (newTarget.Airborne))
                                {
                                    createAnimationOnMap ("Whiff", WhiffChannel, getImageFromLocation (newTarget.currentLocation ()).transform.position, 2f, true);
                                }

                            }
                            else
                            {
                                output += string.Format ("{0} whiffs {1}. ({2}% of {3}%) [Combo: {4}/{5}]" + '\n',
                                    s.Name, newTarget.FirstName, (int)(100 * chance), (int)(100 * maxChance), exec.ConnectsPerRound, exec.AttacksPerRound);

                                addToNotificationQueue (s, newTarget, newTarget.FirstName.ToUpper () + " " + string.Format ("WHIFF! ({1}%)", (int)(100 * chance), (int)(100 * maxChance)), true);
                                createAnimationOnMap ("Whiff", WhiffChannel, getImageFromLocation (loc).transform.position, 2f, true);
                                if (!newTarget.StateActive (newTarget.Airborne))
                                {
                                    createAnimationOnMap ("Whiff", WhiffChannel, getImageFromLocation (newTarget.currentLocation ()).transform.position, 2f, true);
                                }
                            }

                            if (s.Properties.Contains ("MAP ") && s.Continuous)
                            {
                                //s.ThresholdMeasure++;
                            }

                            if (!s.Targetless)
                            {
                                if (target.Vocals.ContactSound.volume > 0.0f)
                                {
                                    target.Vocals.ContactSound.volume = 0.7f;
                                }

                                if (!exec.Equals (activePlayer))
                                {
                                    exec.Vocals.ContactSound.Stop ();
                                    target.Vocals.ContactSound.clip = whiffSound;
                                    target.Vocals.ContactSound.Play ();
                                }
                            }
                        }
                    }

                    //PARRY
                    else if (s.willConnectToTarget (newTarget) && target.StateActive (target.Parry)
                        && (exec.CounterSkill == null || exec.canCounter (target, s)))
                    {

                        output += string.Format ("{0} parries! {1}%" + '\n',
                            newTarget.FirstName, (int)(chance * 100));

                        createAnimationOnMap ("Parry", ContactChannel, target.CentralPosition, 2f, true);

                        if (target.Vocals.ContactSound.volume > 0.0f)
                        {
                            target.Vocals.ContactSound.volume = 0.7f;
                        }
                        target.Vocals.ContactSound.clip = parrySound;
                        target.Vocals.ContactSound.Play ();

                        addToNotificationQueue (s, newTarget, newTarget.FirstName.ToUpper () + " " +
                                               string.Format ("PARRIES! (" + ((Math.Abs (s.Change[0]) + Math.Abs (s.Change[1])
                                                                             + Math.Abs (s.Change[2]) + Math.Abs (s.Change[3])) / 10)
                                                             + " (" + target.Potency (target.Learn) + ")"), true);

                        output += shiftVitality (newTarget,
                            (Math.Abs (s.Change[0]) + Math.Abs (s.Change[1])
                                + Math.Abs (s.Change[2]) + Math.Abs (s.Change[3])) / 10, false, exec);
                        output += string.Format ("{0} {1}" + '\n',
                            newTarget.FirstName, newTarget.Vitality.CurrentState);

                        if (newTarget.StateActive (newTarget.Regen))
                        {
                            output += shiftHealth (newTarget,
                                ((Math.Abs (s.Change[0]) + Math.Abs (s.Change[1])
                                  + Math.Abs (s.Change[2]) + Math.Abs (s.Change[3])) / 10) * newTarget.Potency (newTarget.Regen), true, exec,
                                null);
                        }

                        if (s.Continuous)
                        {
                            //if (!s.Individual && !currentMap ().Interactables.Contains (s)) {
                            if (!s.Individual)
                            {
                                s.ThresholdMeasure--;
                            }
                        }
                    }

                    //CHECK COUNTER
                    if (exec.canCounter (newTarget, s))
                    {

                        double counterProb = exec.R.NextDouble ();

                        if (counterProb < ((double)target.Potency (target.Counter)) / 10)
                        {

                            output += string.Format ("{0} counters!" + '\n', newTarget.FirstName);
                            exec.CounterPlayer = target;

                            if (s.Properties.Contains ("REFLECT "))
                            {

                                s.Owner = target;
                                s.setLocations ();
                                output += string.Format ("{0} is reflected!" + '\n', s.Name);

                                output += executeSkill (target, s, exec.currentLocation (),
                                    target.currentLocation ().DirectionOf (exec), false, true, independent, 1.0);

                            }
                            else
                            {
                                output += executeSkill (target, target.CounterSkill, exec.currentLocation (),
                                    target.currentLocation ().DirectionOf (exec), false, true, independent, 1.0);
                            }

                            if (newTarget.CounterSkill.NumUses == 0)
                            {
                                newTarget.Parry.Clear ();
                                newTarget.Counter.Clear ();
                                newTarget.CounterSkill.NumUses = newTarget.CounterSkill.MaxUses;
                                newTarget.forget (newTarget.CounterSkill);
                                if (target.IsCrouching)
                                {
                                    target.IsCrouching = false;
                                }

                            }
                            output += string.Format ("{0} stopped by counter!" + '\n', s.Name);
                            if (!s.Nonstop)
                            {
                                cancelledOut = true;
                            }


                        }
                        else
                        {
                            output += string.Format ("{0} fails to counter! ({1}% of {2}%)" + '\n',
                                                     target.FirstName, (int)counterProb * 100, target.Potency (target.Counter) * 10);
                        }
                    }
                    else
                    {
                        if (newTarget.CounterSkill != null)
                        {
                            output += string.Format ("{0} fails to counter!" + '\n', target.FirstName);
                        }
                    }
                }
            }

            displayMapMovement (newTarget, targetOldLoc, targetOldHeight, newTarget.currentLocation (), newTarget.Potency (newTarget.Airborne), "AirNeutral", (s.Speed + 1) * 4, false, s, newTarget.currentLocation ().DirectionOf (targetLoc));


            output += " " + '\n';
        }

        //SKILL: MAP OBJECT IN LOCATION
        if (battleMap.locationInHeightRange (loc, s)
            && !s.Properties.Contains (" NOINT ")
            && !s.Properties.Contains (" NET ")
            && !s.UsedNow
            && ((s.LineSkill && !s.Permeate) || s.Properties.Contains ("MAPINT "))
            && !battleMap.isEmpty (loc) && !battleMap.objectAt (loc).sentient ())
        {

            s.UsedNow = true;

            if (exec.skillHeightCanChange (s, loc))
            {
                s.CurrentHeight = battleMap.heightOf (loc);
            }

            if (s.Grapple)
            {
                exec.AddFatigue (s.Recovery);
                if (s.Properties.Contains ("LEAP"))
                {
                    exec.SetHeight (exec.Potency (exec.Airborne) + s.Recovery);
                    exec.InRecovery = true;
                    exec.IsCrouching = false;
                }
                else
                {
                    exec.SetHeight (0);
                    exec.InRecovery = false;
                }
            }

            if (s.Properties.Contains ("ONCONTACT"))
            {
                output += executeSkill (exec, (Skill)s.LinkSkills[0], loc, dir,
                    true, s.Properties.Contains ("MAP"), s.Individual, decay);
            }

            MapObject ob = (MapObject)battleMap.objectAt (loc);
            if (s.Properties.Contains ("DESTROY "))
            {

                output += string.Format ("{0} is destroyed!" + '\n', ob.Name);
                createAnimationOnMap ("Burn", EnvironmentChannel, getImageFromLocation (ob.currentLocation ()).transform.position, 1f, true);
                battleMap.removeObject (ob);
            }

            if (s.Properties.Contains ("CREATE"))
            {

            }
            else if (s.Physical)
            {


                //ITEM DROP
                if (s.LineSkill && s.Properties.Contains ("DROP"))
                {
                    output += itemDrop (exec, s, loc);
                }

                //output += "LET'S GET PHYSICAL";
                ob.Strength -= s.ThresholdMeasure;
                if (ob.Strength <= 0)
                {
                    output += string.Format ("{0} is destroyed by {1}!" + '\n', ob.Name, s.Name);
                    battleMap.removeObject (ob);
                }
                //if (!s.Individual && !currentMap ().Interactables.Contains (s)) {
                if (!s.Individual)
                {
                    s.ThresholdMeasure--;
                    if (((s.LineSkill && !s.SForce) || s.ThresholdMeasure == 0) && !s.Targetless)
                    {
                        output += string.Format ("{0} stopped by object!" + '\n', s.Name);
                        if (!s.Nonstop)
                        {
                            cancelledOut = true;
                        }

                    }
                }

            }
            else if (s.Projectile)
            {
                int diff = ob.Strength - s.ThresholdMeasure;

                //ITEM DROP
                if (s.LineSkill && s.Properties.Contains ("DROP"))
                {
                    output += itemDrop (exec, s, loc);
                }

                if (!s.Individual && !s.ObjectSkill)
                {
                    s.ThresholdMeasure -= ob.Strength;

                    if (diff >= 0)
                    {
                        if (ob.Reflect)
                        {
                            createAnimationOnMap ("Contact", ContactChannel, getImageFromLocation (loc).transform.position, 2f, true);

                            output += string.Format ("{0} is reflected by {1}! ({2} to {3})" + '\n',
                                s.Name, ob.Name, dir, battleMap.oppositeDirection (dir));
                            s.Owner = ob.Owner;
                            dir = battleMap.oppositeDirection (dir);
                            output += " " + '\n';

                        }
                        else
                        {
                            output += string.Format ("{0} stops!" + '\n', s.Name);
                            if (!s.Nonstop)
                            {
                                s.ThresholdMeasure = 0;
                                if (!s.Nonstop)
                                {
                                    cancelledOut = true;
                                }

                            }
                        }
                    }
                    if (diff <= 0)
                    {
                        output += string.Format ("{0} is destroyed by projectile!" + '\n', ob.Name);
                        createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);
                        battleMap.removeObject (ob);
                    }
                }
            }
            else if (s.SForce)
            {

                //ITEM DROP
                if (s.LineSkill && s.Properties.Contains ("DROP"))
                {
                    output += itemDrop (exec, s, loc);
                }

                output += string.Format ("{0} is destroyed by force!" + '\n', ob.Name);
                battleMap.removeObject (ob);
            }

        }

        //

        //SKILL: BENIGN
        if (
            s.ObjectSkill
            && !s.Properties.Contains (" NET ")
            && s.Benign
            && !s.UsedNow
            && battleMap.locationInHeightRange (properLoc, s))
        {

            s.UsedNow = true;

            //SKILL: EMPTY, BENIGN SKILL, OR DIFFERENT HITBOX
            if ((battleMap.isEmptyInteractable (loc)
                 || !battleMap.interactableAt (loc).sameHitSections (trap)) &&
                (battleMap.isEmptyProjectile (loc) || !battleMap.projectileAt (loc).sameHitSections (trap)))
            {
                trap.Timer = s.Timer;
                output += string.Format ("{0} (Benign) is set in {1}." + '\n', trap.Name, properLoc);
                createAnimationOnMap ("Dust", EnvironmentChannel, getImageFromLocation (loc).transform.position, 2f, false);


                if (trap.Properties.Contains ("TRACE"))
                {

                    trap.Location = properLoc;
                    trap.TrackLocation = properLoc;
                    exec.TrackSkills.Add (trap);
                    trap.RowDifference = properLoc.Row - exec.Row;
                    trap.ColumnDifference = properLoc.Column - exec.Column;
                }

                output += " " + '\n';
                trap.Index = exec.ObjectIndex;
                exec.ObjectIndex++;
                trap.StepTime = 0.0f;
                exec.currentMap ().addInteractable (trap, properLoc);
                trap.Location = properLoc;
                if (trap.Properties.Contains ("ALONGGROUND"))
                {
                    trap.CurrentHeight = battleMap.heightOf (properLoc);
                }
                else
                {
                    trap.CurrentHeight = exec.currentHeight ();
                }

                //ITEM DROP
                if (s.LineSkill && s.Properties.Contains ("DROP"))
                {
                    output += itemDrop (exec, s, properLoc);
                }
            }
            else if (battleMap.isEmptyProjectile (loc)
                     || !battleMap.projectileAt (loc).sameHitSections (trap))
            {
                trap.Timer = s.Timer;
                output += string.Format ("{0} (Benign) is set in {1}." + '\n', trap.Name, properLoc);
                createAnimationOnMap ("Dust", EnvironmentChannel, getImageFromLocation (loc).transform.position, 2f, false);


                if (trap.Properties.Contains ("TRACE"))
                {

                    trap.Location = properLoc;
                    trap.TrackLocation = properLoc;
                    exec.TrackSkills.Add (trap);
                    trap.RowDifference = properLoc.Row - exec.Row;
                    trap.ColumnDifference = properLoc.Column - exec.Column;
                }

                output += " " + '\n';
                trap.Index = exec.ObjectIndex;
                exec.ObjectIndex++;
                trap.StepTime = 0.0f;
                exec.currentMap ().addInteractable (trap, properLoc);
                trap.Location = properLoc;
                if (trap.Properties.Contains ("ALONGGROUND"))
                {
                    trap.CurrentHeight = battleMap.heightOf (properLoc);
                }
                else
                {
                    trap.CurrentHeight = exec.currentHeight ();
                }

                //ITEM DROP
                if (s.LineSkill && s.Properties.Contains ("DROP"))
                {
                    output += itemDrop (exec, s, properLoc);
                }
            }
            else
            {
                trap.setLocations ();
                output += string.Format ("{0} (Benign) activates on {1}!" + '\n', trap.Name, target.FirstName);
                if (!s.Individual)
                {
                    s.ThresholdMeasure--;
                }
                if (!battleMap.isValid (trap.Owner.currentLocation ().getNewLocationFromDirection (dir)))
                {
                    dir = "";
                }
                output += executeSkill (trap.Owner, trap, properLoc, dir, false, false, !trap.HasLinks, decay);
            }

        }

        //SKILL: TRAP/OBJECT
        if (s.ObjectSkill
            && !s.Properties.Contains (" NET ")
            && !s.Benign
            && !s.UsedNow
            && exec.currentMap ().locationInHeightRange (loc, s)
            && !s.Permeate)
        {

            s.UsedNow = true;

            Skill trapInLoc;
            if (s.Properties.Contains ("MAXRNG"))
            {
                trap.CurrentRange = 0;
                trap.MaxRange = NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ("#") + 1, 3));
            }
            if (s.Properties.Contains ("DIRECTION"))
            {
                trap.Direction = dir;
            }



            //SKILL: PLAYER IN LOCATION
            if (!exec.currentMap ().isEmpty (loc)
                && exec.currentMap ().objectAt (loc).sentient ()
                && trap.willConnectToTarget (((Player)exec.currentMap ().objectAt (loc)))
                && !s.Benign)
            {

                //ITEM DROP
                if (s.LineSkill && s.Properties.Contains ("DROP"))
                {
                    output += itemDrop (exec, s, loc);
                }

                if (exec.currentMap ().objectAt (loc).sentient ())
                {
                    target = (Player)exec.currentMap ().objectAt (loc);
                    if (trap.willConnectToTarget (target))
                    {
                        trap.setLocations ();
                        output += string.Format ("{0} activates on {1}!" + '\n', trap.Name, target.FirstName);
                        if (!s.Individual)
                        {
                            s.ThresholdMeasure--;
                        }
                        if (!battleMap.isValid (trap.Owner.currentLocation ().getNewLocationFromDirection (dir)))
                        {
                            dir = "";
                        }
                        output += executeSkill (trap.Owner, trap, loc, dir, false, false, !trap.HasLinks, decay);
                    }
                }
                else
                {
                    output += string.Format ("{0} does not activate." + '\n', trap.Name);
                }
            }
            //SKILL: EMPTY LOCATION OR OBJECT NOT IN PROPER HIT SECTION
            else if (((exec.currentMap ().playerAt (loc) == null
                       || !trap.willConnectToTarget ((Player)exec.currentMap ().objectAt (loc)))
                &&
                      exec.currentMap ().isEmptyInteractable (loc) && exec.currentMap ().isEmptyProjectile (loc))
                || trap.Properties.Contains ("BENIGN"))
            {
                //print ("TRAP/OBJECT EMPTY LOCATION");

                trap.Timer = s.Timer;
                output += string.Format ("{0} (Skl) is set in {1}." + '\n', trap.Name, loc);
                if (battleMap.isValid (loc))
                {
                    createAnimationOnMap ("Dust", EnvironmentChannel, getImageFromLocation (loc).transform.position, 2f, false);
                }

                if (trap.Properties.Contains ("TRACE"))
                {

                    trap.Location = loc;
                    trap.TrackLocation = loc;
                    exec.TrackSkills.Add (trap);
                    trap.RowDifference = loc.Row - exec.currentLocation ().Row;
                    trap.ColumnDifference = loc.Column - exec.currentLocation ().Column;
                }


                output += " " + '\n';
                trap.Index = exec.ObjectIndex;
                exec.ObjectIndex++;
                trap.StepTime = 0.0f;
                exec.currentMap ().addInteractable (trap, loc);
                trap.Location = loc;
                if (trap.Properties.Contains ("ALONGGROUND"))
                {
                    trap.CurrentHeight = battleMap.heightOf (loc);
                }
                else
                {
                    trap.CurrentHeight = exec.currentHeight ();
                }
                //print (trap.CurrentHeight + " is height of obj");

                //ITEM DROP
                if (s.LineSkill && s.Properties.Contains ("DROP"))
                {
                    output += itemDrop (exec, s, loc);
                }
            }

            //INTERACTIBLE IN LOCATION
            else if (
                //exec.currentMap ().isEmpty (loc) &&
                !exec.currentMap ().isEmptyInteractable (loc)
                && exec.currentMap ().interactableAt (loc).sameHitSections (s)
                && (s.Projectile || s.SuperProjectile))
            {

                trapInLoc = exec.currentMap ().interactableAt (loc);

                //print ("TRAP/OBJECT OBJECT IN LOCATION " + trapInLoc.Name);


                //OBJECT IN LOCATION HAS HIGHER THRESHOLD
                if (trapInLoc.ThresholdMeasure > trap.ThresholdMeasure)
                {
                    trapInLoc.ThresholdMeasure -= trap.ThresholdMeasure;

                    output += string.Format ("{0} stopped by {1}!" + '\n', s.Name, trap.Name);
                    createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);
                    if (!s.Nonstop)
                    {
                        cancelledOut = true;
                    }


                    //ITEM DROP
                    if (s.LineSkill && s.Properties.Contains ("DROP"))
                    {
                        output += itemDrop (exec, s, loc);
                    }
                }

                //NEW OBJECT HAS HIGHER THRESHOLD
                else if (trapInLoc.ThresholdMeasure < trap.ThresholdMeasure)
                {
                    output += string.Format ("{0} is set in {1}" + '\n', trap.Name, loc);
                    createAnimationOnMap ("Dust", EnvironmentChannel, getImageFromLocation (loc).transform.position, 2f, false);

                    output += " " + '\n';

                    if (trap.Properties.Contains ("TRACE"))
                    {

                        trap.Location = loc;
                        trap.TrackLocation = loc;
                        exec.TrackSkills.Add (trap);
                        trap.RowDifference = loc.Row - exec.currentLocation ().Row;
                        trap.ColumnDifference = loc.Column - exec.currentLocation ().Column;
                    }

                    if (!s.Individual)
                    {
                        trap.ThresholdMeasure -= trapInLoc.ThresholdMeasure;
                    }
                    exec.currentMap ().removeInteractable (trapInLoc);
                    trap.Index = exec.ObjectIndex;
                    exec.ObjectIndex++;
                    trap.StepTime = 0.0f;
                    exec.currentMap ().addInteractable (trap, loc);
                    trap.Location = loc;

                    if (trap.Properties.Contains ("ALONGGROUND"))
                    {
                        trap.CurrentHeight = battleMap.heightOf (loc);
                    }
                    else
                    {
                        trap.CurrentHeight = exec.currentHeight ();
                    }

                    //print (trap.CurrentHeight + " is height of obj");

                    //ITEM DROP
                    if (s.LineSkill && s.Properties.Contains ("DROP"))
                    {
                        output += itemDrop (exec, s, loc);
                    }
                }

                //OBJECTS HAVE EQUAL THRESHOLDS
                else
                {
                    exec.currentMap ().removeInteractable (trapInLoc);
                    output += string.Format ("{0} stopped by object!" + '\n', s.Name);
                    createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);
                    if (!s.Nonstop)
                    {
                        cancelledOut = true;
                    }



                    //ITEM DROP
                    if (s.LineSkill && s.Properties.Contains ("DROP"))
                    {
                        output += itemDrop (exec, s, loc);
                    }
                }
            }
            //INTERACTIBLE IN LOCATION
            else if (
                //exec.currentMap ().isEmpty (loc) &&
                !exec.currentMap ().isEmptyProjectile (loc)
                && exec.currentMap ().projectileAt (loc).sameHitSections (s)
                && (s.Projectile || s.SuperProjectile))
            {

                trapInLoc = exec.currentMap ().projectileAt (loc);

                //print ("TRAP/OBJECT OBJECT IN LOCATION " + trapInLoc.Name);


                //OBJECT IN LOCATION HAS HIGHER THRESHOLD
                if (trapInLoc.ThresholdMeasure > trap.ThresholdMeasure)
                {
                    trapInLoc.ThresholdMeasure -= trap.ThresholdMeasure;

                    output += string.Format ("{0} stopped by {1}!" + '\n', s.Name, trap.Name);
                    createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);
                    if (!s.Nonstop)
                    {
                        cancelledOut = true;
                    }


                    //ITEM DROP
                    if (s.LineSkill && s.Properties.Contains ("DROP"))
                    {
                        output += itemDrop (exec, s, loc);
                    }
                }

                //NEW OBJECT HAS HIGHER THRESHOLD
                else if (trapInLoc.ThresholdMeasure < trap.ThresholdMeasure)
                {
                    output += string.Format ("{0} is set in {1}" + '\n', trap.Name, loc);
                    createAnimationOnMap ("Dust", EnvironmentChannel, getImageFromLocation (loc).transform.position, 2f, false);

                    output += " " + '\n';

                    if (trap.Properties.Contains ("TRACE"))
                    {

                        trap.Location = loc;
                        trap.TrackLocation = loc;
                        exec.TrackSkills.Add (trap);
                        trap.RowDifference = loc.Row - exec.currentLocation ().Row;
                        trap.ColumnDifference = loc.Column - exec.currentLocation ().Column;
                    }

                    if (!s.Individual)
                    {
                        trap.ThresholdMeasure -= trapInLoc.ThresholdMeasure;
                    }
                    exec.currentMap ().removeInteractable (trapInLoc);
                    trap.Index = exec.ObjectIndex;
                    exec.ObjectIndex++;
                    trap.StepTime = 0.0f;
                    exec.currentMap ().addInteractable (trap, loc);
                    trap.Location = loc;

                    if (trap.Properties.Contains ("ALONGGROUND"))
                    {
                        trap.CurrentHeight = battleMap.heightOf (loc);
                    }
                    else
                    {
                        trap.CurrentHeight = exec.currentHeight ();
                    }

                    //print (trap.CurrentHeight + " is height of obj");

                    //ITEM DROP
                    if (s.LineSkill && s.Properties.Contains ("DROP"))
                    {
                        output += itemDrop (exec, s, loc);
                    }
                }

                //OBJECTS HAVE EQUAL THRESHOLDS
                else
                {
                    exec.currentMap ().removeInteractable (trapInLoc);
                    output += string.Format ("{0} stopped by object!" + '\n', s.Name);
                    createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);
                    if (!s.Nonstop)
                    {
                        cancelledOut = true;
                    }



                    //ITEM DROP
                    if (s.LineSkill && s.Properties.Contains ("DROP"))
                    {
                        output += itemDrop (exec, s, loc);
                    }
                }
            }


        }

        //INTERACTIBLE IN LOCATION
        if (battleMap.isEmpty (loc)
            && !s.Properties.Contains (" NET ")
            && (!s.UsedNow || s.RadiusSkill)
            && !battleMap.isEmptyInteractable (loc)
            && battleMap.locationInHeightRange (loc, s)
            && battleMap.interactableAt (loc).sameHitSections (s)
            && !battleMap.interactableAt (loc).Owner.Equals (s.Owner)
            && !s.Properties.Contains (" NOINT ")
            && !s.Permeate)
        {

            //print ("OBJECT IN LOCATION");

            s.UsedNow = true;

            if (s.Grapple && s.Recovery != 0)
            {
                exec.AddFatigue (s.Recovery);
                if (s.Properties.Contains ("LEAP"))
                {
                    exec.SetHeight (exec.Potency (exec.Airborne) + s.Recovery);
                    exec.InRecovery = true;
                    exec.IsCrouching = false;
                }
                else if (!exec.Flight)
                {
                    exec.SetHeight (0);
                    exec.InRecovery = false;
                }
            }

            if (exec.skillHeightCanChange (s, loc))
            {
                s.CurrentHeight = exec.currentMap ().heightOf (loc);
            }

            trap = exec.currentMap ().interactableAt (loc);

            //SKILL STOPPED
            if (((trap.SForce && (s.Projectile || s.SuperProjectile))))
            {
                if (!s.Individual)
                {
                    output += string.Format ("{0} crushed by {1}!" + '\n', s.Name, trap.Name);
                    createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);
                    if (!s.Nonstop)
                    {
                        cancelledOut = true;
                    }

                    //ITEM DROP
                    if (s.LineSkill && s.Properties.Contains ("DROP"))
                    {
                        output += itemDrop (exec, s, loc);
                    }
                }
                if (trap.Properties.Contains ("REFLECT"))
                {
                    s.Owner = trap.Owner;
                    output += " " + '\n';
                    output += string.Format ("{0} is reflected!" + '\n', s.Name);
                    createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);
                    output += executeSkill (exec, s, exec.currentLocation (),
                        battleMap.oppositeDirection (dir), false, false, !s.HasLinks, decay);
                }
                else if (trap.Properties.Contains ("DEFLECT"))
                {
                    s.Owner = trap.Owner;
                    int row = exec.R.Next (
                        exec.currentMap ().Rows),
                    column = exec.R.Next (exec.currentMap ().Columns);
                    output += " " + '\n';
                    output += string.Format ("{0} is deflected!" + '\n', s.Name);
                    createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);
                    output += executeSkill (exec, s, new Location (row, column),
                        battleMap.oppositeDirection (dir), false, false, !s.HasLinks, decay);
                }
            }

            //OBJECT STOPPED
            else if ((s.SForce && (trap.Projectile || trap.SuperProjectile)))
            {

                //if (!trap.Individual) {
                output += string.Format ("{0} is crushed by {1}!" + '\n', trap.Name, s.Name);
                createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);

                //ITEM DROP
                if (s.LineSkill && s.Properties.Contains ("DROP"))
                {
                    output += itemDrop (exec, s, loc);
                }
                if (!trap.Properties.Contains ("TRACE"))
                {
                    if (s.Properties.Contains ("REFLECT"))
                    {

                        trap.Owner = s.Owner;
                        trap.Direction = getOppositeDirection (trap.Direction);

                        output += " " + '\n';

                        output += string.Format ("{0} is reflected!" + '\n', trap.Name);
                        createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);

                    }
                    else if (s.Properties.Contains ("DEFLECT"))
                    {
                        trap.Owner = s.Owner;

                        string[] directions = new string[] { "N", "E", "S", "W", "NE", "SE", "NW", "SW" };
                        trap.Direction = directions[exec.R.Next (directions.Length)];

                        output += " " + '\n';
                        output += string.Format ("{0} is deflected!" + '\n', trap.Name);
                        createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);

                    }
                }
                else
                {
                    battleMap.removeInteractable (trap);
                }
            }
            else if ((s.Projectile && trap.Projectile)
              || (s.SuperProjectile && trap.SuperProjectile)
              || (s.SForce && trap.SForce))
            {
                //print ("SAME LEVEL");
                if (s.ThresholdMeasure > trap.ThresholdMeasure)
                {

                    s.ThresholdMeasure -= trap.ThresholdMeasure;
                    output += string.Format ("{0} is cancelled out!" + '\n', trap.Name);
                    createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);
                    battleMap.removeInteractable (trap);

                }
                else if (s.ThresholdMeasure < trap.ThresholdMeasure)
                {

                    trap.ThresholdMeasure -= s.ThresholdMeasure;
                    s.ThresholdMeasure = 0;
                    if (!s.Nonstop)
                    {
                        cancelledOut = true;
                    }

                }
                else
                {

                    s.ThresholdMeasure = 0;
                    trap.ThresholdMeasure = 0;
                    if (!s.Nonstop)
                    {
                        cancelledOut = true;
                    }

                    battleMap.removeInteractable (trap);
                    output += string.Format ("{0} is cancelled out!" + '\n', trap.Name);
                    createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);

                }
            }
        }

        //INTERACTIBLE IN LOCATION
        if (battleMap.isEmpty (loc)
            && !s.Properties.Contains (" NET ")
            && (!s.UsedNow || s.RadiusSkill)
            && !battleMap.isEmptyProjectile (loc)
            && battleMap.locationInHeightRange (loc, s)
            && battleMap.projectileAt (loc).sameHitSections (s)
            && !battleMap.projectileAt (loc).Owner.Equals (s.Owner)
            && !s.Properties.Contains (" NOINT ")
            && !s.Permeate)
        {

            //print ("OBJECT IN LOCATION");

            s.UsedNow = true;

            if (s.Grapple && s.Recovery != 0)
            {
                exec.AddFatigue (s.Recovery);
                if (s.Properties.Contains ("LEAP"))
                {
                    exec.SetHeight (exec.Potency (exec.Airborne) + s.Recovery);
                    exec.InRecovery = true;
                    exec.IsCrouching = false;
                }
                else if (!exec.Flight)
                {
                    exec.SetHeight (0);
                    exec.InRecovery = false;
                }
            }

            if (exec.skillHeightCanChange (s, loc))
            {
                s.CurrentHeight = exec.currentMap ().heightOf (loc);
            }

            trap = exec.currentMap ().projectileAt (loc);

            //SKILL STOPPED
            if (((trap.SForce && (s.Projectile || s.SuperProjectile))))
            {
                if (!s.Individual)
                {
                    output += string.Format ("{0} crushed by {1}!" + '\n', s.Name, trap.Name);
                    createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);
                    if (!s.Nonstop)
                    {
                        cancelledOut = true;
                    }

                    //ITEM DROP
                    if (s.LineSkill && s.Properties.Contains ("DROP"))
                    {
                        output += itemDrop (exec, s, loc);
                    }
                }
                if (trap.Properties.Contains ("REFLECT"))
                {
                    s.Owner = trap.Owner;
                    output += " " + '\n';
                    output += string.Format ("{0} is reflected!" + '\n', s.Name);
                    createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);
                    output += executeSkill (exec, s, exec.currentLocation (),
                        battleMap.oppositeDirection (dir), false, false, !s.HasLinks, decay);
                }
                else if (trap.Properties.Contains ("DEFLECT"))
                {
                    s.Owner = trap.Owner;
                    int row = exec.R.Next (
                        exec.currentMap ().Rows),
                    column = exec.R.Next (exec.currentMap ().Columns);
                    output += " " + '\n';
                    output += string.Format ("{0} is deflected!" + '\n', s.Name);
                    createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);
                    output += executeSkill (exec, s, new Location (row, column),
                        battleMap.oppositeDirection (dir), false, false, !s.HasLinks, decay);
                }
            }

            //OBJECT STOPPED
            else if ((s.SForce && (trap.Projectile || trap.SuperProjectile)))
            {

                //if (!trap.Individual) {
                output += string.Format ("{0} is crushed by {1}!" + '\n', trap.Name, s.Name);
                createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);

                //ITEM DROP
                if (s.LineSkill && s.Properties.Contains ("DROP"))
                {
                    output += itemDrop (exec, s, loc);
                }
                if (!trap.Properties.Contains ("TRACE"))
                {
                    if (s.Properties.Contains ("REFLECT"))
                    {

                        trap.Owner = s.Owner;
                        trap.Direction = getOppositeDirection (trap.Direction);

                        output += " " + '\n';

                        output += string.Format ("{0} is reflected!" + '\n', trap.Name);
                        createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);

                    }
                    else if (s.Properties.Contains ("DEFLECT"))
                    {
                        trap.Owner = s.Owner;

                        string[] directions = new string[] { "N", "E", "S", "W", "NE", "SE", "NW", "SW" };
                        trap.Direction = directions[exec.R.Next (directions.Length)];

                        output += " " + '\n';
                        output += string.Format ("{0} is deflected!" + '\n', trap.Name);
                        createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);

                    }
                }
                else
                {
                    battleMap.removeInteractable (trap);
                }
            }
            else if ((s.Projectile && trap.Projectile)
              || (s.SuperProjectile && trap.SuperProjectile)
              || (s.SForce && trap.SForce))
            {
                //print ("SAME LEVEL");
                if (s.ThresholdMeasure > trap.ThresholdMeasure)
                {

                    s.ThresholdMeasure -= trap.ThresholdMeasure;
                    output += string.Format ("{0} is cancelled out!" + '\n', trap.Name);
                    createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);
                    battleMap.removeInteractable (trap);

                }
                else if (s.ThresholdMeasure < trap.ThresholdMeasure)
                {

                    trap.ThresholdMeasure -= s.ThresholdMeasure;
                    s.ThresholdMeasure = 0;
                    if (!s.Nonstop)
                    {
                        cancelledOut = true;
                    }

                }
                else
                {

                    s.ThresholdMeasure = 0;
                    trap.ThresholdMeasure = 0;
                    if (!s.Nonstop)
                    {
                        cancelledOut = true;
                    }

                    battleMap.removeInteractable (trap);
                    output += string.Format ("{0} is cancelled out!" + '\n', trap.Name);
                    createAnimationOnMap ("Contact", CollisionChannel, getImageFromLocation (loc).transform.position, 2f, true);

                }
            }
        }


        //EMPTY LOCATION
        if (battleMap.isEmpty (loc)
            && !s.Properties.Contains (" NET ")
            && (!s.UsedNow || s.RadiusSkill)
            && s.ThresholdMeasure > 0 && battleMap.locationInHeightRange (loc, s))
        {

            s.UsedNow = true;

            if (exec.skillHeightCanChange (s, loc))
            {
                s.CurrentHeight = battleMap.heightOf (loc);
            }

            if (s.Grapple)
            {
                exec.AddFatigue (s.Recovery);

                if (s.Properties.Contains ("LEAP"))
                {
                    exec.IsCrouching = false;
                    exec.SetHeight (exec.Potency (exec.Airborne) + s.Recovery);
                    exec.InRecovery = true;

                }
                else
                {
                    exec.SetHeight (0);
                    exec.InRecovery = false;
                }
            }

            //MAP OBJECT
            if (s.Properties.Contains ("CREATE"))
            {
                MapObject obj = reader.loadObject (s.Properties.Substring (s.Properties.IndexOf ('+') + 1), null);
                obj.Owner = exec;
                obj.changeLocation (loc);
                output += battleMap.addObject (obj);
                output += " " + '\n';
            }
        }

        if (battleMap.isValid (loc)
            && battleMap.isEmpty (loc)
            && s.ThresholdMeasure >= 1
            && battleMap.locationInHeightRange (loc, s))
        {

            s.UsedNow = true;

            if (s.LineSkill && (s.Projectile || s.SuperProjectile || s.SForce) && !s.Properties.Contains (" NOMAPANIM "))
            {
                createAnimationOnMap ("Whiff", EnvironmentChannel, getImageFromLocation (loc).transform.position, 2f, true);
            }

            if (!s.Properties.Contains (" NOMAPANIM ") && ((s.SForce || s.Magic || s.Projectile || s.SuperProjectile) && (s.RadiusSkill || s.SingleSkill)))
            {

                if (getImageFromLocation (loc) == null)
                {
                    throw new NullReferenceException ("THANKS " + loc);
                }

                if (s.Malicious)
                {
                    createAnimationOnMap ("Burn", EnvironmentChannel, getImageFromLocation (loc).transform.position, 2f, true);
                }
                if (s.Beneficial)
                {
                    createAnimationOnMap ("Icy", EnvironmentChannel, getImageFromLocation (loc).transform.position, 2f, true);
                }
            }

        }


        return new ArrayList { output, target, cancelledOut, executor };
    }

    public string levelUp (Player exec, Boolean display)
    {
        string output = "";
        if (exec.Level <= 99)
        {
            output += exec.LevelUp;
            string useless = exec.PlayerStandard.LevelUp;

            if (exec.Experience < exec.ExperienceCheckpoints[exec.Level + 1] && display)
            {
                createAnimationOnMap ("LevelUp", StatChannel, exec.CentralPosition, 2f, true);
            }
        }
        return output;
    }

    public string masteryUp (Skill s, Boolean display)
    {
        string output = "";
        if (s.Mastery <= 99)
        {
            output += s.Owner.MasteryUp (s);
            if (battleMap.isValid (s.Owner.currentLocation ()))
            {
                createAnimationOnMap ("MasteryUp", StatChannel, s.Owner.CentralPosition, 2f, true);
            }
        }
        return output;
    }

    public string gainProficiency (Skill s, int amount)
    {
        string output = "";
        if (s.Mastery <= 10)
        {
            if (amount != 0)
            {
                s.Experience += amount;
                output += string.Format ("{0} +{1} PROF" + '\n', s.Name, amount);
                if (s.Experience < s.MasteryCheckpoints[s.Mastery + 1])
                {
                    output += string.Format ("{0} {1}/{2} PROF" + '\n', s.Name, s.MasteryDisplay, s.MasteryCheckpointDisplay);
                }
                while (s.Experience >= s.MasteryCheckpoints[s.Mastery + 1])
                {
                    output += masteryUp (s, true);
                }
            }
        }
        return output;
    }

    public string gainExperience (Player exec, int amount)
    {
        string output = "";
        if (!exec.Equals (battleMap.MapOwner))
        {
            if (exec.Level <= 99)
            {
                if (amount != 0)
                {
                    exec.Experience += (amount / 4); //* exec.Ratio;
                    output += string.Format ("{0} +{1} XP" + '\n', exec.FirstName, amount / 4);
                    if (exec.Experience < exec.ExperienceCheckpoints[exec.Level + 1])
                    {
                        output += string.Format ("{0} {1}/{2} XP" + '\n', exec.FirstName, exec.ExperienceDisplay, exec.ExperienceCheckpointDisplay);
                    }
                    while (exec.Experience >= exec.ExperienceCheckpoints[exec.Level + 1])
                    {
                        output += levelUp (exec, true);
                    }
                }
            }
            if (exec.Owner != null
            //&& !exec.NoGainForMaster
            )
            {
                output += gainExperience (exec.Owner, amount / 2);
            }
        }
        return output;
    }

    public void addNotification (Player p, ArrayList soundQueue)
    {

        Notification notif = new Notification (cloneText (p.FirstName + " " + "Text notification (Destroy in checkQueue ())", notificationText, gameCanvas.transform), OUTPUTTIMER, new Vector3(0, 0, 0));

        notificationTexts.Add (notif);

        notif.Info.transform.SetAsLastSibling ();

        Vector3 placementOnMap = p.MapSprite.transform.position;//findObjectInMap (p);

        placementOnMap = new Vector3(placementOnMap.x - 20, placementOnMap.y + 15, placementOnMap.z);

        notif.Info.transform.position = placementOnMap;
        notif.CurrentLocation = placementOnMap;

        string txt = (string)((ArrayList)p.MapOutputs[0])[0];
        print ("PRINTING OUT " + txt);
        notif.Info.color = new Color (notif.Info.color.r, notif.Info.color.g, notif.Info.color.b, 1);
        notif.Info.text = txt;
        skillOutputDelay = 0.75f;

        notif.Info.color = appropriateColor ();

        float timer = OUTPUTTIMER;

        //notif.Info.color = Color.white;
        if (txt.Contains ("HP"))
        {
            //  notif.Info.color = Color.red;
        }
        else if (txt.Contains ("RM"))
        {
            //  notif.Info.color = Color.red;
        }
        else if (txt.Contains ("GM"))
        {
            //  notif.Info.color = Color.blue;
        }
        else if (txt.Contains ("VM"))
        {
            //  notif.Info.color = Color.green;
        }
        else if (txt.Contains ("ST"))
        {
            //  notif.Info.color = Color.magenta;
        }
        else if (txt.Contains (": POISON"))
        {
            notif.Info.color = purple;
        }

        if (p.PlayerOutputIndexes.Count > 0)
        {
            string appropriateSFX = (string)((ArrayList)p.MapOutputs[0])[1];

            print ("found map position of object " + p.SearchName + " for " + txt);

            if (appropriateSFX.Equals (" "))
            {

                //APPROPRIATE SKILLS

                string skillOutputText = (string)((ArrayList)p.MapOutputs[0])[0];

                determineNotificationSoundAndColor (ref p, ref skillOutputText, ref notif);

            }
            else
            {

                if (txt.Contains ("-"))
                {

                    notif.Info.color = Color.red;

                }
                else
                {

                    notif.Info.color = mintGreen;

                }

                playContactSound (p, null, appropriateSFX);
            }
        }

        notif.Timer = timer;


        if (p.PlayerOutputIndexes.Count > 0)
        {

            p.MapOutputs.RemoveAt (0);
            p.PlayerOutputIndexes.RemoveAt (0);
        }
    }

    public void updateNotifications (int index)
    {
        Notification output = (Notification)notificationTexts[index];

        output.Info.enabled = true;
        output.Timer -= Time.deltaTime;

        if (output.Timer < 0.35f)
        {
            output.Info.color = new Color (
                output.Info.color.r, output.Info.color.g, output.Info.color.b, output.Info.color.a - Time.deltaTime);
        }

        float x = output.Info.transform.position.x,
        y = output.Info.transform.position.y,
        z = output.Info.transform.position.z;

        Vector3 newPosition = new Vector3(x, y + TEXTMOVEMENTRATE, z);
        output.Info.transform.position = newPosition;

        if (output.Timer <= 0.0f)
        {
            output.Info.text = "DELETE";
            inactivityTime = 0.0f;
            output.Info.color = Color.clear;
        }
    }

    public void stepDialogue (Player p, string line)
    {
        if (p.Vocals.Dialogue.Count > 0)
        {
            if (line != "" && !line.StartsWith ("#"))
            {

                p.Vocals.Speech.clip = Resources.Load<AudioClip> (@"Players/" + p.SearchName + "/Sound/" + concat (line));
                p.Vocals.Speech.Play ();

            }
            else if (line.Equals ("clear"))
            {
                p.Vocals.Clear ();
            }

        }
        else
        {
            p.Vocals.Clear ();
        }
    }

    public void showActiveAndPassiveStatus ()
    {

        if (activePlayer != null && activePlayer.StateActive (activePlayer.Invisible))
        {
            timeText.color = Color.clear;
        }
        else
        {
            if (activePlayer != null && (activePlayer.KOd || (!activePlayer.CanAct && skillSet.Count == 0 && skill == null)))
            {
                timeText.enabled = true;
                timeText.text = "END " + ((int)endPlayerTimer).ToString ();
                timeText.color = teamColors (activePlayer);
            }
            else
            {
                if (passiveTime > 0)
                {
                    timeText.enabled = true;
                    if (activePlayer == null)
                    {
                        timeText.text = "READY " + ((int)passiveTime).ToString ();
                    }
                    else
                    {
                        timeText.text = "PASSIVE " + ((int)passiveTime).ToString ();
                        timeText.color = teamColors (activePlayer);//Color.green;

                    }
                }
                else
                {
                    timeText.enabled = false;
                }
            }
        }
    }

    public void setNewActivePlayer (Player p, Boolean textReset)
    {
        if (p != null)
        {

            battleMap.Time++;
            //addtoBattleLog (CheckMapTraitsByTime, true);

        }

        Player plx;
        for (int i = 0; i < battleMap.Roster.Count; i++)
        {
            plx = (Player)battleMap.Roster[i];
            print (plx.NameAndTeam + " " + plx.currentLocation () + " in battle ");
            if (plx.ContactSkill != null)
            {
                print ("WE'VE GOT A CONTACT! " + plx.NameAndTeam + " " + plx.ContactSkill.Name + " " + plx.ContactSkill.TurnsRemaining);
                //addToNotificationQueue(null, ((Player)battleMap.Roster[i]), "CONTACT "
                //    + ((Player)battleMap.Roster[i]).ContactSkill.Name.ToUpper() + " " + ((Player)battleMap.Roster[i]).ContactSkill.TurnsRemaining, true);
            } else
            {
                print ("WE'VE NOT GOT A CONTACT! " + plx.NameAndTeam);
            }


        }

        if (battleMap.Index >= battleMap.Roster.Count)
        {
            battleMap.Index = 0;
        }
        timeText.text = "";

        inputSuccess = true;
        readingUserCommands = false;
        inputPrompt.enabled = false;

        stepTime = 0.0f;
        stepTimeModulus = 0.0f;
        skillInfoDisplaying = false;
        inputPressed = false;

        //inputDelay = 1.2f;
        //menuInputDelay = 1.2f;

        clearDialogues ();

        string EndOutput = "";

        timerSFX.Stop ();
        if (p != null && p.IsActive)
        {
            targettedPlayers = new ArrayList ();

            //clearOutputsAndTargets ();
            clearNotifications ();
            clearDialogues ();
        }

        if (!battleMap.Team1.IsDefeated && !battleMap.Team2.IsDefeated)
        {
            Player lastPlayer = activePlayer;

            if (activePlayer != null)
            {

                activePlayer.setBonusTime ();
                if (activePlayer.GetsBonusTime)
                {

                    activePlayer.BonusRoundActivated = true;
                    activePlayer.BonusTime -= .75f;
                    activePlayer.MovesRemaining = activePlayer.Movement / 2;
                    addToBattleLog ("Bonus Round!" + '\n', true);
                    endPlayerTimer = 4.0f;
                    EndOutput += activePlayer.setAction (true);
                    activePlayer.HasActed = false;

                    activePlayer.LongestCombo.Add ("*BONUS*");


                    createAnimationOnMap ("Begin", TurnChannel, activePlayer.CentralPosition/**MapSprite.transform.position*/, 2f, true);

                    firstMoveActivated = true;
                    battleMap.ActiveTime = ((float)activePlayer.Speed * 100) / 10;
                    finishTime = -1.5f;
                    passiveTime = -1.0f;
                    inputPressed = false;

                    setSkill (null, -1, null);
                    skillLocation = null;
                    activePlayer.LockedOnTarget = null;
                    setActiveTime (0, 0.33f);

                    updateActivePlayer ();
                    updatePlayerInfo ();

                    return;
                }

                if (activePlayer.LongestCombo.Count > 0)
                {
                    turnOutput.WriteLine (activePlayer.Name.ToUpper () + '\n' + playerStatusAndCombos (activePlayer));
                }

                activePlayer.ActivePlayer = false;

                if (activePlayer.StateActive (activePlayer.Confuse))
                {
                    EndOutput += string.Format ("{0} kneels to the ground from confusion." + '\n', activePlayer.FirstName);
                    EndOutput += activePlayer.Crouch;
                }

                EndOutput += string.Format ("{0}'s turn ends ({1})." + '\n', p.FirstName, p.MyTeam.Name);

                State st;
                Skill sk;

                for (int i = 0; i < activePlayer.TimedConditions.Count; i++)
                {
                    st = (State)activePlayer.TimedConditions[i];
                    if (st.Name.Equals ("TMFRZ"))
                    {
                        st.NumTurns--;
                        if (st.NumTurns == 0)
                        {


                            if (st.Name.Equals ("TMFRZ"))
                            {
                                EndOutput += string.Format ("Time resumes!" + '\n');

                                activePlayer.TimeStopped = false;
                                if (!bgm.isPlaying)
                                {
                                    playBGM();
                                    ambience.Play ();
                                }

                                for (int j = 0; j < activePlayer.AllSkills.Count; j++)
                                {
                                    sk = (Skill)activePlayer.AllSkills[j];
                                    if (sk.Properties.Contains (" TM ") && activePlayer.forget (sk))
                                    {
                                        EndOutput += string.Format ("{0} is forgotten!" + '\n', sk.Name);
                                    }
                                }
                            }
                            activePlayer.TimedConditions.Remove (st);
                            i--;
                        }
                    }
                }
            }
            if (p == null)
            {
                //playerHealthBar.SetActive (false);
                //playerRushBar.SetActive (false);
                //playerGuardBar.SetActive (false);
                //playerVitalityBar.SetActive (false);
                //playerStunBar.SetActive (false);
            }
            else
            {
                setActivePlayer (p);// activePlayer = p;
                //clearOutputsAndTargets ();

                if (battleMap.Index + 1 >= battleMap.Roster.Count)
                {

                    battleMap.Index = 0;
                    battleMap.Rounds++;
                    addToBattleLog (checkMapTraits ("ROUND", battleMap.Rounds), false);
                }
                else
                {

                    battleMap.Index++;
                    addToBattleLog (checkMapTraits ("INDEX", battleMap.Index), false);
                }


                endTime = -1f;
                upEndTime = 0.0f;
                p.setBonusTime ();
                //setActiveTime ();

                if (battleMap.Index == 0)
                {
                    addToBattleLog (EndOutput + '\n' + '\n', textReset);
                    addToBattleLog ("" + '\n', textReset);
                    addToBattleLog ("NEW ROUND" + '\n', false);
                    addToBattleLog ("" + '\n', false);
                }
                else
                {
                    addToBattleLog ("", textReset);
                }

                if (activePlayer.KOd)
                {
                    if (battleMap.Index >= battleMap.Roster.Count)
                    {

                        battleMap.Index = 0;
                    }
                    setNewActivePlayer ((Player)battleMap.Roster[battleMap.Index], true);
                    return;
                }

                addToBattleLog (IncrementRound (activePlayer, lastPlayer), false);
                addToBattleLog (battleMap.Team1.InfoToString (p) + '\n', false);
                addToBattleLog ("--" + '\n', false);
                addToBattleLog (battleMap.Team2.InfoToString (p) + '\n', false);

                skillSet = new ArrayList ();
                setSkill (null, -1, null);
                skillLocation = null;

                if (!p.OnField || (!p.KOd && !p.IsAble))
                {
                    addToBattleLog (string.Format ("{0} cannot act." + '\n', p.FirstName), false);
                    print ("SETTING NEW PLAYER DUE TO INACTIVITY!");
                    if (battleMap.Index >= battleMap.Roster.Count)
                    {

                        battleMap.Index = 0;
                        battleMap.resetTurns ();
                    }
                    setNewActivePlayer ((Player)battleMap.Roster[battleMap.Index], false);
                    return;
                }

                if (activePlayer.Speed < 0 || activePlayer.HasActedInRound)
                {
                    if (activePlayer.R.NextDouble () < Math.Abs (activePlayer.Speed))
                    {
                        print ("SETTING NEW PLAYER DUE TO SLOWNESS!");
                        if (battleMap.Index >= battleMap.Roster.Count)
                        {
                            battleMap.Index = 0;
                            battleMap.resetTurns ();
                        }
                        setNewActivePlayer ((Player)battleMap.Roster[battleMap.Index], true);
                        return;
                    }
                }

                battleMap.PlayedRounds++;
                addToBattleLog (checkMapTraits ("ROUNDPLAY", battleMap.PlayedRounds), false);

                p.BonusRoundActivated = false;

                createAnimationOnMap ("Begin", TurnChannel, p.CentralPosition, 2f, true);

                if (battleMap.Rounds == 0 || battleMap.Index == 0)
                {
                    announce ("newround");
                }
                else
                {
                    announce ("ready");
                }

                if (trainingMode)
                {
                    addToBattleLog (shiftHealth (activePlayer, activePlayer.Health.MeterMax, false, null, null), false);
                    addToBattleLog (shiftRush (activePlayer, activePlayer.Guard.MeterMax, false, null), false);
                    addToBattleLog (shiftGuard (activePlayer, activePlayer.Rush.MeterMax, false, null), false);
                    addToBattleLog (shiftVitality (activePlayer, activePlayer.Vitality.MeterMax, false, null), false);
                    addToBattleLog (shiftStun (activePlayer, -1 * activePlayer.Stun.MeterMax, false, null), false);
                    activePlayer.Cooldown = 0;
                }

                p.ActivePlayer = true;

                if (p.FirstTurn)
                {
                    p.FirstTurn = false;
                }

                if (p.WasHit)
                {
                    p.WasHit = false;
                }

                p.resetSkillUsage (p.AllSkills);

                p.HasActedInRound = true;

                p.LastTarget = null;

                targettedPlayers = new ArrayList ();

                if (p.StateActive (p.Confuse))
                {
                    dizzySFX.Play ();
                    p.IsCrouching = true;
                }

                randomLocations[0] = activePlayer.currentLocation ().North;
                randomLocations[1] = activePlayer.currentLocation ().East;
                randomLocations[2] = activePlayer.currentLocation ().South;
                randomLocations[3] = activePlayer.currentLocation ().West;

                passiveTime = (float)(((activePlayer.Speed * 10) + (activePlayer.Dexterity * 3)) / 3);//activePlayer.ActionPoints;
                endPlayerTimer = 4.0f;

                setUserControls ();

                setActiveTime (0, 1);
                setFinishTimeMeter ();
                showActiveAndPassiveStatus ();
                setActiveTimeMeter ();

                updateActivePlayer ();

                updatePlayerInfo ();

                displayMapPlayerGraphics (p, p.Row, p.Column);
                for (int i = 0; i < battleMap.Roster.Count; i++)
                {
                    if (!((Player)battleMap.Roster[i]).InMovement)
                    {
                        displayMapPlayerGraphics (((Player)battleMap.Roster[i]),
                            ((Player)battleMap.Roster[i]).Row, ((Player)battleMap.Roster[i]).Column);
                    }
                }
            }

            updateMap (activePlayer);
            updatePlayerInfo ();
            determineSpecificSprite (activePlayer, playerSprite, playerReel, playerFrame, playerSpriteIndex);
            determineAnimation ();

            if (p != null)
            {

                setArrows (p);
            }
        }
    }

    public void setUserControls ()
    {
        if (activePlayer.MyTeam.Equals (battleMap.Team1))
        {
            UserUp = P1Up;
            UserDown = P1Down;
            UserBack = P1Back;
            UserForward = P1Forward;
            UserNorth = P1North;
            UserEast = P1East;
            UserSouth = P1South;
            UserWest = P1West;
            UserAction = P1Action;
            UserCancel = P1Cancel;
            UserInfo = P1Info;
            UserConfirm = P1Confirm;
            UserPause = P1Pause;
            UserActionSet = P1ActionSet;
            UserJumpSet = P1JumpSet;
            UserNormalSet = P1NormalSet;
            UserSpecialSet = P1SpecialSet;
            UserVitalitySet = P1VitalitySet;
            UserBurstSet = P1BurstSet;
            UserItemSet = P1ItemSet;
            UserInventorySet = P1InventorySet;
            UserPaceCancelButton = P1PaceCancelButton;
            UserGuardButton = P1GuardButton;
            UserTauntButton = P1TauntButton;
            UserRestButton = P1RestButton;
            UserCrouchButton = P1CrouchButton;
            UserWaitButton = P1WaitButton;
            UserA = P1A;
            UserB = P1B;
            UserC = P1C;
            UserD = P1D;
            UserY = P1Y;
            UserZ = P1Z;

            User_Alpha1 = P1_Alpha1;
            User_Alpha2 = P1_Alpha2;
            User_Alpha3 = P1_Alpha3;
            User_Alpha4 = P1_Alpha4;
            User_Alpha5 = P1_Alpha5;
            User_Alpha6 = P1_Alpha6;
            User_Alpha7 = P1_Alpha7;
            User_Alpha8 = P1_Alpha8;
            User_Alpha9 = P1_Alpha9;
            User_Alpha0 = P1_Alpha0;
            User_Keypad1 = P1_Keypad1;
            User_Keypad2 = P1_Keypad2;
            User_Keypad3 = P1_Keypad3;
            User_Keypad4 = P1_Keypad4;
            User_Keypad5 = P1_Keypad5;
            User_Keypad6 = P1_Keypad6;
            User_Keypad7 = P1_Keypad7;
            User_Keypad8 = P1_Keypad8;
            User_Keypad9 = P1_Keypad9;
            User_Keypad0 = P1_Keypad0;
            User_ScrollUp1 = P1_ScrollUp1;
            User_ScrollUp2 = P1_ScrollUp2;
            User_ScrollDown1 = P1_ScrollDown1;
            User_ScrollDown2 = P1_ScrollDown2;

            UserAB = new ArrayList { P1A, P1B };
            UserAC = new ArrayList { P1A, P1C };
            UserAD = new ArrayList { P1A, P1D };
            UserBC = new ArrayList { P1B, P1C };
            UserBD = new ArrayList { P1B, P1D };
            UserCD = new ArrayList { P1C, P1D };
            UserYZ = new ArrayList { P1Y, P1Z };
            UserABC = new ArrayList { P1A, P1B, P1C };
            UserBCD = new ArrayList { P1B, P1C, P1D };
            UserABCD = new ArrayList { P1A, P1B, P1C, P1D };

        }
        else
        {
            UserUp = P2Up;
            UserDown = P2Down;
            UserBack = P2Back;
            UserForward = P2Forward;
            UserNorth = P2North;
            UserEast = P2East;
            UserSouth = P2South;
            UserWest = P2West;
            UserAction = P2Action;
            UserCancel = P2Cancel;
            UserInfo = P2Info;
            UserConfirm = P2Confirm;
            UserPause = P2Pause;
            UserActionSet = P2ActionSet;
            UserJumpSet = P2JumpSet;
            UserNormalSet = P2NormalSet;
            UserSpecialSet = P2SpecialSet;
            UserVitalitySet = P2VitalitySet;
            UserBurstSet = P2BurstSet;
            UserItemSet = P2ItemSet;
            UserInventorySet = P2InventorySet;
            UserPaceCancelButton = P2PaceCancelButton;
            UserGuardButton = P2GuardButton;
            UserTauntButton = P2TauntButton;
            UserRestButton = P2RestButton;
            UserCrouchButton = P2CrouchButton;
            UserWaitButton = P2WaitButton;
            UserA = P2A;
            UserB = P2B;
            UserC = P2C;
            UserD = P2D;
            UserY = P2Y;
            UserZ = P2Z;

            User_Alpha1 = P2_Alpha1;
            User_Alpha2 = P2_Alpha2;
            User_Alpha3 = P2_Alpha3;
            User_Alpha4 = P2_Alpha4;
            User_Alpha5 = P2_Alpha5;
            User_Alpha6 = P2_Alpha6;
            User_Alpha7 = P2_Alpha7;
            User_Alpha8 = P2_Alpha8;
            User_Alpha9 = P2_Alpha9;
            User_Alpha0 = P2_Alpha0;
            User_Keypad1 = P2_Keypad1;
            User_Keypad2 = P2_Keypad2;
            User_Keypad3 = P2_Keypad3;
            User_Keypad4 = P2_Keypad4;
            User_Keypad5 = P2_Keypad5;
            User_Keypad6 = P2_Keypad6;
            User_Keypad7 = P2_Keypad7;
            User_Keypad8 = P2_Keypad8;
            User_Keypad9 = P2_Keypad9;
            User_Keypad0 = P2_Keypad0;
            User_ScrollUp1 = P2_ScrollUp1;
            User_ScrollUp2 = P2_ScrollUp2;
            User_ScrollDown1 = P2_ScrollDown1;
            User_ScrollDown2 = P2_ScrollDown2;

            UserAB = new ArrayList { P2A, P2B };
            UserAC = new ArrayList { P2A, P2C };
            UserAD = new ArrayList { P2A, P2D };
            UserBC = new ArrayList { P2B, P2C };
            UserBD = new ArrayList { P2B, P2D };
            UserCD = new ArrayList { P2C, P2D };
            UserYZ = new ArrayList { P2Y, P2Z };
            UserABC = new ArrayList { P2A, P2B, P2C };
            UserBCD = new ArrayList { P2B, P2C, P2D };
            UserABCD = new ArrayList { P2A, P2B, P2C, P2D };

        }

        guardIndicatorText.text = "Guard-" + UserGuardButton.ToString ();
        restIndicatorText.text = "Rest-" + UserRestButton.ToString ();
        tauntIndicatorText.text = "Taunt-" + UserTauntButton.ToString ();
        stanceIndicatorText.text = "Stance-" + UserCrouchButton.ToString ();
        itemIndicatorText.text = "Item-" + UserItemSet.ToString ();
        jumpIndicatorText.text = "Jump-" + UserJumpSet.ToString ();
        normalIndicatorText.text = "Normal-" + UserNormalSet.ToString ();
        specialIndicatorText.text = "Special-" + UserSpecialSet.ToString ();
        vitalityIndicatorText.text = "Vitality-" + UserVitalitySet.ToString ();
        burstIndicatorText.text = "Burst-" + UserBurstSet.ToString ();
        moveIndicatorText.text = "Move-Arrows";
        traitIndicatorText.text = "Trait-" + UserActionSet.ToString ();
        confirmIndicatorText.text = "Confirm-" + UserConfirm.ToString ();
        inventoryIndicatorText.text = "Inventory-" + UserInventorySet.ToString ();

    }

    public void startActiveTime ()
    {
        firstMoveActivated = true;
        addToBattleLog (WaitSpecial, false);
        activePlayer.Vocals.ContactSound.clip = startSound;
        activePlayer.Vocals.ContactSound.Play ();
        timeText.enabled = false;
        announce ("fight");
        setActiveTime (0, 1);
        passiveTime = 0;
    }

    public string WaitSpecial
    {
        get
        {
            string output = "";

            output += string.Format ("{0} waits." + '\n', activePlayer.FirstName);
            if (activePlayer.MovesRemaining > 0)
            {
                //activePlayer.MovesRemaining--;
            }
            else
            {
                //output += shiftGuard (activePlayer, -20, true);
                //activePlayer.MovesRemaining--;
            }
            output += IncrementSingleTurnActions (null, null, true, null, -1.0f);
            output += stepObjectTime (1);
            updateActivePlayer ();
            updateMap (activePlayer);
            return output;
        }
    }

    public void setStepTime (float mult)
    {
        //ACTIVE MATCH TIME / MATCH ACTIVE TIME
        if (skill == null || !skill.Properties.Contains (" FREEZE ") && !activePlayer.TimeStopped)
        {
            Player p;

            for (int i = 0; i < battleMap.Roster.Count; i++)
            {
                p = (Player)battleMap.Roster[i];
                p.StepTime += Time.deltaTime * (mult * 1.5f);
                p.StepTimeModulus = p.StepTime - 1;

                if (p.StepTimeModulus >= 0.0f)
                {

                    incrementBurningFallingStaggerAndStanding (p);
                    p.StepTime = 0.0f;
                }
            }

            stepTime += Time.deltaTime * (mult * 1.5f);
            stepTimeModulus = stepTime - 1;

            if (stepTimeModulus >= 0.0f)
            {
                stepSFX.clip = beepSound;//
                stepSFX.Play ();
                //REMAIN TRUE
                IncrementSingleTurnActions (activePlayer, null, false, null, mult);
                stepTime = 0.0f;

                if (mapHasChanged)
                {
                    updateMap (activePlayer);
                    updatePlayerInfo ();
                    mapHasChanged = false;
                }
            }
        }
        //MATCH TIME ACTIVE
    }

    public string getOppositeDirection (string dir)
    {
        if (dir.Equals ("N"))
        {
            return "S";
        }
        if (dir.Equals ("E"))
        {
            return "W";
        }
        if (dir.Equals ("S"))
        {
            return "N";
        }
        if (dir.Equals ("W"))
        {
            return "E";
        }
        if (dir.Equals ("NE"))
        {
            return "SW";
        }
        if (dir.Equals ("SE"))
        {
            return "NW";
        }
        if (dir.Equals ("NW"))
        {
            return "SE";
        }
        if (dir.Equals ("SW"))
        {
            return "NE";
        }
        return "X";
    }

    public string shiftHealth (Player p, int amount, Boolean printing, Player attacker, Skill s)
    {
        return shiftHealth (p, amount, printing, attacker, s, false);
    }

    public string shiftHealth (Player p, int amount, Boolean printing, Player attacker, Skill s, Boolean combo)
    {
        string output = "";
        if (p.KOd)
        {

        }

        if (printing)
        {

            string input = "";
            if (amount > 0)
            {
                input += "+";
            }
            input += amount;

            if (p.IsGuarding)
            {
                input += " GUARD";
            }

            playContactAnimation (p, s, input);

            if (amount > 0)
            {
                ArrayList newInfo = new ArrayList { p.FirstName.ToUpper () + " " + string.Format ("+" + amount + "HP") };
                createAnimationOnMap ("Heal", HitChannel, p.CentralPosition, 1f, true);

                if (s != null && s.Beneficial && p.sameTeam (attacker) && !p.Equals (attacker))
                {
                    addDialogue (p.Vocals.SpecificAppreciation (attacker.SearchName), p, false, "Appreciation");
                }


                if (s != null && !p.IsGuarding)
                {
                    newInfo.Add (s.SkillInfoList);
                    print (s.Name + " has SkillInfo: " + s.SkillInfoList);
                }
                else
                {
                    newInfo.Add (" ");
                    print (amount + " has no SkillInfo");
                }
                p.PlayerOutputIndexes.Add (p.Index);
                p.MapOutputs.Add (newInfo);
                print ((string)((ArrayList)p.MapOutputs[0])[0]);

            }
            else
            {

                ArrayList newInfo = new ArrayList ();
                if (p.IsGuarding)
                {
                    newInfo = new ArrayList { p.FirstName.ToUpper () + " " + string.Format ("" + amount + "HP GUARD") };
                    createAnimationOnMap ("Guard", HitChannel, p.CentralPosition, 2f, true);
                }
                else
                {
                    newInfo = new ArrayList { p.FirstName.ToUpper () + " " + string.Format ("" + amount + "HP") };
                    if (s != null && s.Magic)
                    {
                        createAnimationOnMap ("HitMagic", HitChannel, p.CentralPosition, 2f, true);
                    }
                    else
                    {
                        createAnimationOnMap ("HitPhysical", HitChannel, p.CentralPosition, 2f, true);
                    }
                }
                if (s != null && !p.IsGuarding)
                {
                    newInfo.Add (s.SkillInfoList);
                    print (s.Name + " has SkillInfo: " + s.SkillInfoList);
                }
                else
                {
                    newInfo.Add (" ");
                    print (amount + " has no SkillInfo");
                }
                p.PlayerOutputIndexes.Add (p.Index);
                p.MapOutputs.Add (newInfo);
                print ((string)((ArrayList)p.MapOutputs[0])[0]);
            }
        }

        p.Health.MeterLevel += amount;
        if (p.Health.MeterLevel < 0)
        {
            p.Health.MeterLevel = 0;
        }
        else if (p.Health.MeterLevel > p.Health.MeterMax)
        {
            p.Health.MeterLevel = p.Health.MeterMax;
        }

        //PRINT
        if (printing)
        {
            if (amount <= 0)
            {
                output += string.Format ("{0} {1} HP ", p.FirstName, amount);
                if (attacker != null)
                {
                    output += string.Format ("({0}%)", (int)(attacker.CurrentProration * 100));
                }
                output += " " + '\n';
            }
            else
            {
                output += string.Format ("{0} +{1} HP" + '\n', p.FirstName, amount);
            }
            output += string.Format ("{0} {1}/{2} HP" + '\n', p.FirstName, p.Health.MeterLevel, p.Health.MeterMax);
        }



        if (amount < 0)
        {
            p.DamageTakenPerRound += Math.Abs (amount);
            p.DamageTakenTotal += Math.Abs (amount);
            output += string.Format ("{0} DMG -{1} HP", p.FirstName, p.DamageTakenPerRound);
            if (attacker != null)
            {

                attacker.DamagePerRound += Math.Abs (amount);

                if (combo && s != null && s.Malicious)
                {
                    if (!s.Combo)
                    {

                        if (attacker.LongestCombo.Count > 1)
                        {
                            turnOutput.WriteLine (attacker.Name.ToUpper () + '\n' + playerStatusAndCombos (attacker));
                        }

                        s.Combo = true;
                        attacker.ComboDamagePerRound = Math.Abs (amount);
                        attacker.Combo = 1;
                    }
                    else
                    {
                        attacker.ComboDamagePerRound += Math.Abs (amount);
                        attacker.Combo++;
                    }
                }
                if (attacker.HighestCombo < attacker.DamagePerRound)
                {
                    attacker.HighestCombo = attacker.DamagePerRound;
                }
                if (s != null)
                {
                    s.SkillOutput += Math.Abs (amount);
                    if (attacker != p)
                    {
                        attacker.DamageTotal += Math.Abs (amount);
                    }
                }
                if (!attacker.FirstName.Contains ("owner"))
                {
                    output += string.Format (" -- {0} OUTPUT -{1} HP" + '\n', attacker.FirstName, attacker.DamagePerRound);
                }
            }
            else
            {
                output += " " + '\n';
            }

            if (s != null && !s.Properties.Contains ("NOEXP ") && !p.Equals (attacker) && !p.KOd)
            {
                output += gainExperience (p, Math.Abs (amount) / 2);
            }
        }

        if (amount > 0 && attacker != null)
        {
            if (s != null)
            {

                attacker.HealingPerRound += amount;
                attacker.HealingTotal += amount;
                s.SkillOutput += Math.Abs (amount);
                if (!s.Properties.Contains ("NOEXP ") && !p.Equals (attacker) && !p.KOd)
                {
                    output += gainExperience (p, Math.Abs (amount) / 2);
                }
            }

            output += string.Format ("{0} HEAL: {1} HP" + '\n', attacker.FirstName, attacker.HealingPerRound);
        }

        if (p.Critical)
        {
            if (!p.WasCritical)
            {
                output += string.Format ("{0} is critical!" + '\n', p.FirstName);
                createAnimationOnMap ("HPCritical", LimitChannel, p.CentralPosition, 2f, true);
                addDialogue (p.Vocals.RandomCritical, p, false, "Critical");

                p.Vocals.Speech.clip = Resources.Load<AudioClip>(@"Sounds/players/" + p.Sex.ToLower () + "damage");
                p.Vocals.Speech.Play ();

                p.CriticalActive = true;
                if (p.Critical && p.CriticalSkill != null && !p.FirstName.Equals ("null") && (s == null || !s.Properties.Contains (" NOLS ")))
                {

                    if (p.CriticalSkill.MyTurn && attacker != null && !attacker.KOd)
                    {
                        attacker.CounterPlayer = p;
                        print (p.FirstName + " is main character now!");
                    }
                    else
                    {
                        print ("NAH MAN");
                    }

                    if (attacker != null && !p.CriticalSkill.SelfSkill)
                    {

                        output += shiftStun (p, -1 * p.Stun.MeterLevel, true, null);

                        output += p.Confuse.ClearStates;
                        if (p.WasHit)
                        {
                            output += p.Grounded.ClearStates;
                            output += p.Airborne.ClearStates;
                            mapHasChanged = true;
                        }

                        output += string.Format ("{0} uses critical" + '\n', p.FirstName);
                        output += p.setAction (true);
                        p.MovesRemaining = p.Movement;
                        p.TurnEnded = false;

                        announce ("limitbreak");

                        createAnimationOnMap ("HPCritical", LimitChannel, p.CentralPosition, 2f, true);

                        output += executeSkill (p, p.CriticalSkill, attacker.currentLocation (),
                            p.currentLocation ().DirectionOf (attacker), true, true, true, 1.0);


                        p.CriticalSkill = null;
                        p.CriticalActive = true;
                    }
                    else
                    {
                        output += p.setAction (true);
                        p.MovesRemaining = p.Movement;
                        p.TurnEnded = false;
                        output += p.Confuse.ClearStates;
                        if (p.WasHit)
                        {
                            output += p.Grounded.ClearStates;
                            output += p.Airborne.ClearStates;
                            mapHasChanged = true;
                        }

                        announce ("limitbreak");

                        createAnimationOnMap ("LimitBreak", LimitChannel, p.CentralPosition, 2f, true);

                        output += string.Format ("{0} uses critical" + '\n', p.FirstName);
                        output += executeSkill (p, p.CriticalSkill, p.currentLocation (),
                            "", true, true, true, 1.0);

                        p.CriticalSkill = null;
                        p.CriticalActive = true;
                    }
                    if (p.CriticalSkill != null && p.CriticalSkill.NumUses == 0)
                    {
                        p.CriticalSkill = null;
                    }
                }
                p.WasCritical = true;
            }
        }
        else
        {
            p.WasCritical = false;
            //if (p.WasCritical)
        }

        if (p.WasCritical && !p.Critical)
        {
            print ("NAHT A PRAHBLEM");
            p.WasCritical = false;
        }

        if (p.KOd)
        {

            if (p.TimeStopped)
            {
                playBGM();
                ambience.Play ();
            }

            if (p.TimeRemaining < 0)
            {
                output += string.Format ("{0} is KO'd!" + '\n', p.FirstName);
                if (attacker != null && !attacker.Equals (p))
                {
                    output += gainExperience (attacker, 500 + (100 * (p.Level - attacker.Level)));
                }
            }
            if (p.KOSkill != null)
            {
                if (attacker != null)
                {
                    output += executeSkill (p, p.KOSkill, attacker.currentLocation (),
                        p.currentLocation ().DirectionOf (attacker), true, false, true, 1.0);
                }
                else
                {
                    output += executeSkill (p, p.KOSkill, p.currentLocation (),
                        "X", true, false, true, 1.0);
                }
            }
            if (p.KOd && !p.Berserk)
            {


                koPlayer (p, attacker, s, s != null && s.Properties.Contains (" WIPEOUT "));

                if (p.Equals (activePlayer))
                {
                    setNewActivePlayer ((Player)battleMap.Roster[battleMap.Index], true);
                }
            }
        }

        return output;
    }

    public string shiftRush (Player p, int amount, Boolean print, Player attacker)
    {
        string output = "";
        if (amount != 0)
        {
            p.Rush.MeterLevel += amount;
            if (p.Rush.MeterLevel < 0)
            {
                p.Rush.MeterLevel = 0;
            }
            else if (p.Rush.MeterLevel > p.Rush.MeterMax)
            {
                p.Rush.MeterLevel = p.Rush.MeterMax;
            }

            //PRINT
            if (print)
            {

                if (amount > 0)
                {
                    addToNotificationQueue (null, p, p.FirstName.ToUpper () + " " + string.Format ("+" + amount + "(RM)"), true);
                }
                else if (amount < 0)
                {
                    addToNotificationQueue (null, p, p.FirstName.ToUpper () + " " + string.Format ("" + amount + "(RM)"), true);
                }

                if (amount <= 0)
                {
                    output += string.Format ("{0} {1} RM" + '\n', p.FirstName, amount);
                }
                else
                {
                    output += string.Format ("{0} +{1} RM" + '\n', p.FirstName, amount);
                }
                output += string.Format ("{0} {1}/{2} RM" + '\n', p.FirstName, p.Rush.MeterLevel, p.Rush.MeterMax);
            }
            if (p.Rush.MeterLevel < p.Rush.MeterMax / 20)
            {
                output += p.GetFatigued;
            }
        }
        return output;
    }

    public string shiftGuard (Player p, int amount, Boolean print, Player attacker)
    {
        string output = "";
        p.Guard.MeterLevel += amount;
        if (p.Guard.MeterLevel < 0)
        {
            p.Guard.MeterLevel = 0;
        }
        else if (p.Guard.MeterLevel > p.Guard.MeterMax)
        {
            p.Guard.MeterLevel = p.Guard.MeterMax;
        }

        //PRINT
        if (print)
        {

            string input = "";

            if (amount > 0)
            {
                input += "+";
            }

            input += amount + "GM";
            if (p.IsGuarding && amount < 0)
            {
                output += " GUARD";
            }
            playContactAnimation (p, null, input);

            if (attacker != null && activePlayer.Equals (attacker))
            {
                if (amount > 0)
                {
                    addToNotificationQueue (null, p, p.FirstName.ToUpper () + " " + string.Format ("+" + amount + "(GM)"), true);
                }
                else if (amount < 0)
                {
                    addToNotificationQueue (null, p, p.FirstName.ToUpper () + " " + string.Format ("" + amount + "(GM)"), true);
                    createAnimationOnMap ("Guard", HitChannel, p.CentralPosition, 2f, true);
                }
            }

            if (amount <= 0)
            {
                output += string.Format ("{0} {1} GM" + '\n', p.FirstName, amount);
            }
            else
            {
                output += string.Format ("{0} +{1} GM" + '\n', p.FirstName, amount);
            }
            output += string.Format ("{0} {1}/{2} GM" + '\n', p.FirstName, p.Guard.MeterLevel, p.Guard.MeterMax);
        }
        if (p.Guard.MeterLevel == 0)
        {
            output += p.GuardBust;
            createAnimationOnMap ("Shock", ContactChannel, p.CentralPosition, 2f, false);

        }
        return output;
    }

    public string shiftVitality (Player p, int amount, Boolean print, Player attacker)
    {
        string output = "";
        Boolean maxedOut = p.Vitality.MeterLevel == p.Vitality.MeterMax;
        p.Vitality.MeterLevel += amount;
        if (p.Vitality.MeterLevel < 0)
        {
            p.Vitality.MeterLevel = 0;
        }
        else if (p.Vitality.MeterLevel > p.Vitality.MeterMax)
        {
            p.Vitality.MeterLevel = p.Vitality.MeterMax;
        }

        if (print)
        {

            if (amount > 0)
            {
                addToNotificationQueue (null, p, p.FirstName.ToUpper () + " " + string.Format ("+" + amount + "(VM)"), false);
            }
            else if (amount < 0)
            {
                addToNotificationQueue (null, p, p.FirstName.ToUpper () + " " + string.Format ("" + amount + "(VM)"), false);
            }

            if (amount <= 0)
            {
                output += string.Format ("{0} {1} VM" + '\n', p.FirstName, amount);
            }
            else
            {
                output += string.Format ("{0} +{1} VM" + '\n', p.FirstName, amount);
            }
            output += string.Format ("{0} {1}/{2} VM" + '\n', p.FirstName, p.Vitality.MeterLevel, p.Vitality.MeterMax);
        }
        if (!maxedOut && p.Vitality.MeterLevel == p.Vitality.MeterMax)
        {
            output += string.Format ("{0} VM Max Bonus!" + '\n' + '\n', p.FirstName);
        }

        return output;
    }

    public string shiftStun (Player p, int amount, Boolean print, Player attacker)
    {
        string output = "";
        p.Stun.MeterLevel += amount;
        if (p.Stun.MeterLevel < 0)
        {
            p.Stun.MeterLevel = 0;
        }
        else if (p.Stun.MeterLevel > p.Stun.MeterMax)
        {
            p.Stun.MeterLevel = p.Stun.MeterMax;
        }

        if (print)
        {

            output += string.Format ("{0} {1} ST" + '\n', p.FirstName, amount);
            output += string.Format ("{0} {1}/{2} ST" + '\n', p.FirstName, p.Stun.MeterLevel, p.Stun.MeterMax);
        }

        if (p.Stun.MeterLevel == p.Stun.MeterMax)
        {

            p.Confuse.Add (new State ("Confuse", "CON", 2, 0.0, 2, 1.0, true, "is confused!"));
            //Confuse.AdditionalStates.Add (new State ("Confuse", "CON", 2, 0.0, 2, 1.0));
            if (!p.StateActive (p.Airborne))
            {
                p.Grounded.Potency += 5;
            }
            else
            {
                p.Grounded.Potency += 1;
                p.FallingHeight = p.Potency (p.Airborne);
            }

            if (print)
            {
                if (attacker != null)
                {
                    createAnimationOnMap ("Dizzy", StateChannel, p.CentralPosition, 2f, true);

                }
            }

            output += string.Format ("@_@ ");
            output += string.Format ("{0} is dizzy!", p.FirstName);
            output += string.Format (" @_@ " + '\n');

            p.Stun.MeterLevel = 0;
            output += p.Daze.ClearStates;
            p.IsDizzied = true;
        }

        if (amount > 0 && attacker != null)
        {
            attacker.StunPerRound += amount;
            attacker.StunTotal += amount;
            output += string.Format ("{0} STUN: {1}" + '\n', attacker.FirstName, attacker.StunPerRound);
        }
        return output;
    }

    public string activateMapSkill (State st)
    {
        Skill sk = battleMap.MapOwner.getSkill (st.Name);
        sk.setLocations ();
        string output = "";

        if (sk != null && st.Probability > 0)
        {
            double chnc = new System.Random ().NextDouble ();
            if (chnc < st.Probability)
            {
                output += string.Format (sk.Name + " affects the map!" + '\n');
                output += executeSkill (battleMap.MapOwner, sk, activePlayer.currentLocation (),
                                                   "X", true, false, true, 1);
            }
            else
            {
                //throw new NullReferenceException (st.Name + " NOPE!");
            }
        }
        else if (sk == null)
        {
            throw new NullReferenceException (st.Name + " SKILL NOT PRESENT");
        }

        return output;
    }

    public void executeSkill ()
    {
        string output = "";
        Player target = null;
        Skill followUpSkill = null;
        Boolean newPlayer = false;

        if (skill.LineSkill)
        {
            target = getTarget ();
            if (target != null)
            {
                //print (target.FirstName + " execute skill?");
                skillLocation = target.currentLocation ();
            }
        }
        else if (skillLocation != null && !battleMap.isEmpty (skillLocation) && battleMap.objectAt (skillLocation).sentient ())
        {
            target = (Player)battleMap.objectAt (skillLocation);
            //print (target.FirstName + " target execute skill?");
        }

        //if (skillL == null) {
        //  return;
        //}
        if (skill.Name.EndsWith ("Cancel") || skill.Name.Equals ("Break"))
        {
            activePlayer.LongestCombo.Add ("...");
        }
        else
        {
            activePlayer.LongestCombo.Add (skill.Name);
        }
        firstMoveActivated = true;

        output += executeSkill (activePlayer, skill, skillLocation,
            activePlayer.currentLocation ().DirectionOf (skillLocation), true, true, false, activePlayer.CurrentProration);
        
        updatePlayerInfo ();

        addToBattleLog (output, true);


        //SET ENGAGE MODE
        if (activePlayer != null && skill != null && skill.Properties.Contains ("ENGAGE")
            && output.Contains (" engages ") && target != null && !activePlayer.KOd && !target.KOd)
        {
            Player p1 = null, p2 = null, p3 = null, p4 = null;

            StreamWriter player1Writer = new StreamWriter (@"Assets/Resources/Data/Current/Player1.txt"),
            player2Writer = new StreamWriter (@"Assets/Resources/Data/Current/Player2.txt"),
            player3Writer = new StreamWriter (@"Assets/Resources/Data/Current/Player3.txt"),
            player4Writer = new StreamWriter (@"Assets/Resources/Data/Current/Player4.txt"),
            team1Writer = new StreamWriter (@"Assets/Resources/Data/Current/Team1Versus.txt"),
            team2Writer = new StreamWriter (@"Assets/Resources/Data/Current/Team2Versus.txt");

            engageBox.enabled = true;
            engageTeam1Info.enabled = true;
            engageTeam2Info.enabled = true;
            engageText.enabled = true;
            engageVsText.enabled = true;
            engagePlayer1.enabled = true;
            engagePlayer2.enabled = true;

            engageTeam1Info.text = @"";
            engageTeam2Info.text = @"";

            if (activePlayer.MyTeam.Equals (battleMap.Team1))
            {
                print ("TEAM 1 CHALLENGING TEAM 2");
                p1 = activePlayer;
                p2 = target;
                player1Writer.WriteLine (activePlayer.ToString ());
                player2Writer.WriteLine (target.ToString ());
                team1Writer.WriteLine (activePlayer.SearchName);
                team2Writer.WriteLine (target.SearchName);
            }
            else
            {
                print ("TEAM 2 CHALLENGING TEAM 1");
                p2 = activePlayer;
                p1 = target;
                player2Writer.WriteLine (activePlayer.ToString ());
                player1Writer.WriteLine (target.ToString ());
                team2Writer.WriteLine (activePlayer.SearchName);
                team1Writer.WriteLine (target.SearchName);
            }

            if (p1.BestBorderAlly != null)
            {
                p3 = p1.BestBorderAlly;
                player3Writer.WriteLine (p3.ToString ());
                team1Writer.WriteLine (p3.SearchName);
                print (p3.SearchName);
            }
            else
            {
                player3Writer.WriteLine (@"none");
                team1Writer.WriteLine (@"none");
            }
            if (p2.BestBorderAlly != null)
            {
                p4 = p2.BestBorderAlly;
                player4Writer.WriteLine (p4.ToString ());
                team2Writer.WriteLine (p4.SearchName);
                print (p4.SearchName);
            }
            else
            {
                player4Writer.WriteLine (@"none");
                team2Writer.WriteLine (@"none");
            }

            player1Writer.Close ();
            player2Writer.Close ();
            player3Writer.Close ();
            player4Writer.Close ();
            team1Writer.Close ();
            team2Writer.Close ();

            engagePlayer1.texture = p1.Portrait;
            engageTeam1Info.text += p1.FirstName + @" " + p1.PlayStyleActual + p1.Ratio + @" " + p1.Health.MeterLevel + @"HP";

            engagePlayer2.texture = p2.Portrait;
            engageTeam2Info.text += p2.FirstName + @" " + p2.PlayStyleActual + p2.Ratio + @" " + p2.Health.MeterLevel + @"HP";

            if (p3 != null)
            {
                engagePlayer3.enabled = true;
                engagePlayer3.texture = p3.Portrait;
                engageTeam1Info.text += @"" + '\n' + p3.FirstName + @" " + p3.PlayStyleActual + p3.Ratio + @" " + p3.Health.MeterLevel + @"HP";
            }
            if (p4 != null)
            {
                engagePlayer4.enabled = true;
                engagePlayer4.texture = p4.Portrait;
                engageTeam2Info.text += @"" + '\n' + p4.FirstName + @" " + p4.PlayStyleActual + p4.Ratio + @" " + p4.Health.MeterLevel + @"HP";
            }

            finishTimeMax = -5.0f;
            readingUserCommands = false;
            ///addToBattleLog (@"Starting battle! " + p1.FirstName + @" vs. " + p2.FirstName, false);
            addDialogue (activePlayer.Vocals.SpecificIntro (target), activePlayer, true, "Attack");
            engageTimer = 3.0f;
        }

        if (skill != null && activePlayer != null && activePlayer.CounterPlayer != null)
        {
            print (activePlayer.CounterPlayer.FirstName + @" acting");

            setActivePlayer (activePlayer.CounterPlayer);
            //activePlayer = activePlayer.CounterPlayer;

            skillSet = new ArrayList ();
            skillLocation = null;

            firstMoveActivated = false;
            newPlayer = true;
            if (skill.CanAct)
            {
                addToBattleLog (activePlayer.setAction (true), false);
                activePlayer.HasActed = false;
                activePlayer.TurnEnded = false;
            }
        }
        else
        {

        }

        if (skill != null)
        {
            //CANCELS
            if (skill.Properties.Contains ("PCANCEL"))
            {
                activePlayer.CanCancelSkill = true;
            } else {
                activePlayer.CanCancelSkill = false;
            }
        }
        
        if ((!activePlayer.OnField) || !activePlayer.IsAble || (!activePlayer.setCostsAndConditionsMet (activePlayer.ChainSkills) && !activePlayer.setCostsAndConditionsMet (activePlayer.BurstFollowUpSkills)))
        {
            if (skill != null)
            {
                print ("Ending execution of " + skill.Name + "1");
            }
            else
            {
                print ("Ending execution of skill");
            }
            setSkill (null, -1, null);
            skillSet = new ArrayList ();
            skillLocation = null;

            currentSkillInput.enabled = false;

            activePlayer.CounterPlayer = null;
            activePlayer.LockedOnTarget = null;

            activePlayer.BurstFollowUpSkills = new ArrayList ();
            activePlayer.ChainSkills = new ArrayList ();
            //print ("RETURNING AT END!");

            return;
        }
        else
        {
            //print ("NAH");
        }

        if (activePlayer.ChainSkills.Count > 0
            && activePlayer.setCostsAndConditionsMet (activePlayer.ChainSkills)
            && (output.Contains ("***") || (skill.Targetless && output.Contains ("connects on")))
            && (!output.Contains ("ends!") || !output.Contains ("(for " + activePlayer.FirstName + ")")))
        {

            skillSet = activePlayer.ChainSkills;
            int skInd = 0;
            setSkill ((Skill)skillSet[skInd], skInd, skillSet);
            while (!skill.CostsAndConditionsMet)
            {
                skInd++;
                setSkill ((Skill)skillSet[skInd], skInd, skillSet);
                //setAnimation ();
            }

            setSkillLocations ();

            setSkillLocations ();

            if (skill.Inputs.Length > 0)
            {
                currentSkillInput.enabled = true;
                currentSkillInput.texture = ProperInput (skill);
            }
            else
            {
                currentSkillInput.enabled = false;
            }

        }
        else if (activePlayer.BurstFollowUpSkills.Count > 0 &&
          activePlayer.setCostsAndConditionsMet (activePlayer.BurstFollowUpSkills))
        {

            skillSet = activePlayer.BurstFollowUpSkills;
            activePlayer.BurstFollowUpSkills = new ArrayList ();
            int skInd = 0;
            setSkill ((Skill)skillSet[skInd], skInd, skillSet);
            while (!skill.CostsAndConditionsMet)
            {
                skInd++;
                setSkill ((Skill)skillSet[skInd], skInd, skillSet);
            }

            setSkillLocations ();
            //setAnimation ();

            if (activePlayer.LockedOnTarget != null && skill.locationsContains (activePlayer.LockedOnTarget.currentLocation ()))
            {
                skillLocation = activePlayer.LockedOnTarget.currentLocation ();
            }
            else
            {
                skillLocation = activePlayer.currentLocation ();
            }
            if (skill.Inputs.Length > 0)
            {
                currentSkillInput.enabled = true;
                currentSkillInput.texture = ProperInput (skill);
            }
            else
            {
                currentSkillInput.enabled = false;
            }

        }
        else
        {
            if (!activePlayer.CanAct)
            {
                activePlayer.ChainSkills = new ArrayList ();
                activePlayer.BurstFollowUpSkills = new ArrayList ();
                if (!skill.Properties.Contains ("MAP ")
                    && activePlayer.MovesRemaining > 0)
                {
                    activePlayer.MovesRemaining = 0;
                }

                if (skill != null)
                {
                    print ("Ending execution of " + skill.Name + "2");
                }
                else
                {
                    print ("Ending execution of skill");
                }
                setSkill (null, -1, null);
                skillSet = new ArrayList ();
                skillLocation = null;

                if (!activePlayer.CanAct)
                {
                    //endTurn ();
                }

                currentSkillInput.enabled = false;
                activePlayer.CounterPlayer = null;
                activePlayer.LockedOnTarget = null;

            }
            else
            {
                activePlayer.ChainSkills = new ArrayList ();
                if (!skill.Properties.Contains ("MAP ")
                    && activePlayer.MovesRemaining > 0)
                {
                    activePlayer.MovesRemaining = 0;
                }

                if (!activePlayer.CanAct)
                {
                    //endTurn ();
                }

                currentSkillInput.enabled = false;
                activePlayer.CounterPlayer = null;
                activePlayer.LockedOnTarget = null;
            }
        }

        if (skill != null)
        {
            //ANIMATION SET
            determineAnimation ();
        }
        else
        {
            animation.enabled = false;
            animationReel.Clear ();
        }
    }

    public void setActivePlayer (Player p)
    {
        if (p != activePlayer)
        {
            activePlayer = p;

            activePlayer.Health.MeterLevelAppearance = activePlayer.Health.MeterLevel;
            activePlayer.Rush.MeterLevelAppearance = activePlayer.Rush.MeterLevel;
            activePlayer.Guard.MeterLevelAppearance = activePlayer.Guard.MeterLevel;
            activePlayer.Vitality.MeterLevelAppearance = activePlayer.Vitality.MeterLevel;
            activePlayer.Stun.MeterLevelAppearance = activePlayer.Stun.MeterLevel;

            setHP(activePlayer, false);
            setRM(activePlayer, false);
            setGM(activePlayer, false);
            setVM(activePlayer, false);
            setStun (activePlayer, false);
            setXP(activePlayer);
        }
    }

    public void setInputImages ()
    {
        inputImages.Clear ();
        for (int i = 0; i < correctInputs.Count; i++)
        {
            if (correctInputs[i].GetType ().Name.Equals ("KeyCode"))
            {
                print (skill.Name + " SINGLE INPUT");
                if (((KeyCode)correctInputs[i]) == UserA)
                {
                    inputImages.Add (buttonA);
                    print (skill.Name + " - Button A");
                }
                else if (((KeyCode)correctInputs[i]) == UserB)
                {
                    inputImages.Add (buttonB);
                    print (skill.Name + " - Button B");
                }
                else if (((KeyCode)correctInputs[i]) == UserY)
                {
                    inputImages.Add (buttonY);
                    print (skill.Name + " - Button Y");
                }
                else if (((KeyCode)correctInputs[i]) == UserC)
                {
                    inputImages.Add (buttonC);
                    print (skill.Name + " - Button C");
                }
                else if (((KeyCode)correctInputs[i]) == UserD)
                {
                    inputImages.Add (buttonD);
                    print (skill.Name + " - Button D");
                }
                else if (((KeyCode)correctInputs[i]) == UserZ)
                {
                    inputImages.Add (buttonZ);
                    print (skill.Name + " - Button Z");
                }
                else if (((KeyCode)correctInputs[i]) == UserUp)
                {
                    inputImages.Add (buttonUp);
                    print (skill.Name + " - Button Up");
                }
                else if (((KeyCode)correctInputs[i]) == UserForward)
                {
                    inputImages.Add (buttonForward);
                    print (skill.Name + " - Button Forward");
                }
                else if (((KeyCode)correctInputs[i]) == UserDown)
                {
                    inputImages.Add (buttonDown);
                    print (skill.Name + " - Button Down");
                }
                else if (((KeyCode)correctInputs[i]) == UserBack)
                {
                    inputImages.Add (buttonBack);
                    print (skill.Name + " - Button Back");
                }
            }
            else
            {
                print (skill.Name + " DOUBLE INPUT");
                if (((ArrayList)correctInputs[i]).Contains (UserA)
                    && ((ArrayList)correctInputs[i]).Contains (UserB))
                {
                    inputImages.Add (buttonAB);
                    print (skill.Name + " - Button AB");
                }
                else if (((ArrayList)correctInputs[i]).Contains (UserA)
                  && ((ArrayList)correctInputs[i]).Contains (UserC))
                {
                    inputImages.Add (buttonAC);
                    print (skill.Name + " - Button AC");
                }
                else if (((ArrayList)correctInputs[i]).Contains (UserA)
                  && ((ArrayList)correctInputs[i]).Contains (UserD))
                {
                    inputImages.Add (buttonAD);
                    print (skill.Name + " - Button AD");
                }
                else if (((ArrayList)correctInputs[i]).Contains (UserB)
                  && ((ArrayList)correctInputs[i]).Contains (UserC))
                {
                    inputImages.Add (buttonBC);
                    print (skill.Name + " - Button BC");
                }
                else if (((ArrayList)correctInputs[i]).Contains (UserB)
                  && ((ArrayList)correctInputs[i]).Contains (UserD))
                {
                    inputImages.Add (buttonBD);
                    print (skill.Name + " - Button BD");
                }
                else if (((ArrayList)correctInputs[i]).Contains (UserC)
                  && ((ArrayList)correctInputs[i]).Contains (UserD))
                {
                    inputImages.Add (buttonCD);
                    print (skill.Name + " - Button CD");
                }
                else if (((ArrayList)correctInputs[i]).Contains (UserY)
                  && ((ArrayList)correctInputs[i]).Contains (UserZ))
                {
                    inputImages.Add (buttonYZ);
                    print (skill.Name + " - Button YZ");
                }
                else if (((ArrayList)correctInputs[i]).Contains (UserDown)
                  && ((ArrayList)correctInputs[i]).Contains (UserForward))
                {
                    inputImages.Add (buttonDownForward);
                    print (skill.Name + " - Button DF");
                }
                else if (((ArrayList)correctInputs[i]).Contains (UserDown)
                  && ((ArrayList)correctInputs[i]).Contains (UserBack))
                {
                    inputImages.Add (buttonDownBack);
                    print (skill.Name + " - Button DB");
                }
                else if (((ArrayList)correctInputs[i]).Contains (UserUp)
                  && ((ArrayList)correctInputs[i]).Contains (UserForward))
                {
                    inputImages.Add (buttonUpForward);
                    print (skill.Name + " - Button UF");
                }
                else if (((ArrayList)correctInputs[i]).Contains (UserUp)
                  && ((ArrayList)correctInputs[i]).Contains (UserBack))
                {
                    inputImages.Add (buttonUpBack);
                    print (skill.Name + " - Button UB");
                }
                else if (((ArrayList)correctInputs[i]).Contains (UserA)
                  && ((ArrayList)correctInputs[i]).Contains (UserB)
                  && ((ArrayList)correctInputs[i]).Contains (UserC))
                {
                    inputImages.Add (buttonABC);
                    print (skill.Name + " - Button ABC");
                }
            }
        }
        if (inputImages.Count > 0 && correctInputs.Count > 0)
        {
            inputPrompt.texture = (Texture)inputImages[0];
            inputPrompt.enabled = true;
            inputPrompt.transform.SetAsLastSibling ();

            //inputPrompt.enabled = true;
            //activePlayer.Vocals.Clear ();
            //endSpeech (playerFollowUpText, playerFollowUpIndex, playerSpeechBubble, playerSpeechBubbleImage, ref playerSpeechCountdown);
        }
        else
        {
            inputPrompt.enabled = false;
        }
    }

    public void setSkillLocations ()
    {
        Player p;
        targettedPlayers.Clear ();
        for (int i = 0; i < battleMap.Roster.Count; i++)
        {
            p = (Player)battleMap.Roster[i];
            if (skill.properHitSection (p) && skill.locationsContains (p.currentLocation ())
                && ((skill.Malicious && !p.sameTeam (activePlayer))
                    || (skill.Beneficial && p.sameTeam (activePlayer))
                    || (!skill.Beneficial && !skill.Malicious)))
            {
                targettedPlayers.Add (p);
            }
        }
    }

    public void addDialogue (string dialogue, Player p, Boolean clear, string emotion)
    {
        if (clear)
        {
            p.Vocals.Dialogue = new ArrayList ();
        }


        if (!dialogue.StartsWith ("#") && !dialogue.Equals ("") && dialogue.Length > 0)
        {
            p.Vocals.Dialogue.Add (dialogue);
            p.Emotions.Add (emotion);
            if (p.Vocals.Dialogue.Count == 1)
            {
                p.Vocals.SpeechCountdown = 0.01f;
            }
        }
    }

    public float MenuDexterity
    {
        get
        {
            return 0.0f;
        }
    }

    public int getSkillOfType (string token)
    {
        for (int i = 0; i < skillSet.Count; i++)
        {
            if (((Skill)skillSet[i]).Properties.Contains (token))
            {
                return i;
            }
        }
        return -1;
    }

    public Player nextAvailablePlayer (Player pl)
    {
        if (pl == null)
        {
            return null;
        }

        int i = battleMap.indexOfPlayer (pl), rounds = 1;

        Player p = null;

        for (int j = 0; j < battleMap.Roster.Count; j++)
        {

            p = (Player)battleMap.Roster[i];

            if (!p.CanActNext)
            {
                return p;
            }
            else
            {
                p = null;
            }

            i++;

            if (i >= battleMap.Roster.Count)
            {
                i = 0;
            }

        }


        if (p == null && !((Player)battleMap.Roster[0]).KOd)
        {
            return (Player)battleMap.Roster[i];
        }
        return p;
    }

    public int nextAvailableIndex (int increment)
    {
        int nextSkillIndex = currentSkillIndex;
        for (int i = 0; i < Math.Abs (increment); i++)
        {

            if (increment >= 0)
            {
                nextSkillIndex++;
            }
            else
            {
                nextSkillIndex--;
            }

            if (nextSkillIndex >= 0 && nextSkillIndex < skillSet.Count && ((Skill)skillSet[nextSkillIndex]).CostsAndConditionsMet)
            {
                return nextSkillIndex;
            }
        }

        while (nextSkillIndex >= 0 && nextSkillIndex < skillSet.Count)
        {
            if (increment >= 0)
            {
                nextSkillIndex++;
            }
            else
            {
                nextSkillIndex--;
            }

            if (nextSkillIndex >= 0 && nextSkillIndex < skillSet.Count && ((Skill)skillSet[nextSkillIndex]).CostsAndConditionsMet)
            {
                return nextSkillIndex;
            }
        }

        return currentSkillIndex;
    }

    public string koPlayer (Player p, Player attacker, Skill s, Boolean removed)
    {
        string output = "";

        p.Defeats++;
        p.Health.MeterLevel = 0;

        if (attacker != null)
        {
            attacker.Victories++;
            print (string.Format (attacker.FirstName + " wins!"));
            if (s != null)
            {
                s.DefeatedTarget = true;
                s.DefeatedName = p.SearchName;
            }
        }

        setCanvas (p.InfoFrame, false);

        if (trainingMode)
        {
            return shiftHealth (p, p.Health.MeterMax, false, null, null);

        }

        p.InPlay = false;

        if (p.StoredPlayer != null)
        {
            p.transform (p.StoredPlayer, false, p.CriticalActive, true, -1);
        }

        p.SetFatigue (0);
        string ko = "";
        ko += p.ClearStats;
        ko += p.ClearStates;
        p.IsResting = false;
        p.IsTaunting = false;
        p.ChainSkills = new ArrayList ();
        p.BurstFollowUpSkills = new ArrayList ();
        p.CurrentProration = 1.0;
        p.MovesRemaining = p.Movement;
        p.HasJumped = false;
        p.HasActed = false;
        p.IsGuarding = false;
        p.AutoGuard = false;
        p.IsCrouching = false;
        p.WasDizzied = false;
        p.WasCritical = false;
        if (p.IsDizzied)
        {
            p.IsDizzied = false;
            p.WasDizzied = true;
        }
        p.DamagePerRound = 0;
        p.HealingPerRound = 0;
        p.DamageTakenPerRound = 0;
        p.StatusAidsPerRound = 0;
        p.StatusAfflictionsPerRound = 0;

        if (p.Equals (activePlayer))
        {
            passiveTime = -1.0f;
            battleMap.ActiveTime = -1.0f;
        }

        if (!p.StateActive (p.Grounded) && !p.StateActive (p.Airborne))
        {
            p.Grounded.Potency = 100;
            p.Grounded.NumTurns = 10;
        }

        for (int i = 0; i < p.TrackSkills.Count; i++)
        {
            battleMap.removeInteractable ((Skill)p.TrackSkills[i]);
        }
        p.TrackSkills.Clear ();

        addDialogue (p.Vocals.RandomDefeat, p, true, "Defeat");
        if (attacker != null)
        {
            addDialogue (attacker.Vocals.SpecificVictory (p.SearchName), attacker, false, "Victory");
        }

        if (p.Equals (activePlayer))
        {
            setSkill (null, -1, null);
            skillSet = new ArrayList ();
            skillLocation = null;
            p.CanAct = false;
            passiveTime = -1.0f;
        }

        createAnimationOnMap ("KO", KOChannel, getImageFromLocation (p.currentLocation ()).transform.position, 2f, true);
        announce ("ko");

        if (removed)
        {
            p.Vocals.Speech.clip = Resources.Load<AudioClip>(@"Sounds/players/" + p.Sex.ToLower () + "fall");
        }
        else
        {
            p.Vocals.Speech.clip = Resources.Load<AudioClip>(@"Sounds/players/" + p.Sex.ToLower () + "ko");
        }
        p.Vocals.Speech.Play ();

        if (p.TimeRemaining >= 0 || removed)
        {
            output += removePlayer (p);
        }

        if (p.MyTeam.IsDefeated)
        {
            matchOver = true;
            matchOverTimer = 7.0f;
            p.Vocals.Speech.clip = Resources.Load<AudioClip>(@"Sounds/players/" + p.Sex.ToLower () + "ko");
            p.Vocals.Speech.Play ();

            p.MyTeam.Representative = p;
            oppositeTeam (p).Representative = oppositeTeam (p).Representative;

            updateMap (activePlayer);
            beginOutro (null, p, battleMap.Team1.IsDefeated && battleMap.Team2.IsDefeated);
        }
        if (p.Owner == null && p.MyTeam.ActiveSize == 1 && !finalRound)
        {
            //FINAL ROUND 
            finalRound = true;
            announce ("finalround");
            bgm.clip = finalRoundMusic;
            playBGM();
        }

        if (p.OnField)
        {
            displayMapPlayerGraphics (p, p.Row, p.Column);
        }

        print ("SETTING GRAPHICS AND AUDIO FOR " + p.FirstName.ToUpper ());

        if (s == null)
        {
            updateMap ();
        }

        return output;
    }

    public void addToNotificationQueue (Skill s, Player target, string txt, Boolean atBeginning)
    {
        if (!target.KOd || (txt.Contains ("KNOCKED OUT!") || (s != null && s.Properties.Contains ("KNOCKOUT"))))
        {
            ArrayList newInfo = new ArrayList { string.Format (txt), string.Format (" ") };

            target.PlayerOutputIndexes.Add (target.Index);
            target.MapOutputs.Add (newInfo);
        }
    }

    public void setInputs ()
    {
        inputPressed = false;
        correctInputs.Clear ();
        playerInputs.Clear ();
        activePlayer.CurrentHitRate = 0;

        if (skill.Inputs.Length > 0)
        {
            //ONE BUTTON INPUTS
            //FORWARD
            string readSkill = skill.Inputs[0];

            if (skill.Inputs[0].StartsWith ("Jump"))
            {
                if (!activePlayer.StateActive (activePlayer.Airborne))
                {
                    correctInputs.Add (UserUp);
                }
                readSkill = readSkill.Substring (4);
            }

            if (skill.Inputs[0].StartsWith ("Crouch"))
            {
                if (!activePlayer.IsCrouching)
                {
                    correctInputs.Add (UserDown);
                }
                readSkill = readSkill.Substring (6);
            }

            if (readSkill.Equals ("Forward"))
            {
                correctInputs.Add (UserForward);
            }

            //UP
            if (readSkill.Equals ("Up"))
            {
                correctInputs.Add (UserUp);
            }

            //BACK
            if (readSkill.Equals ("Back"))
            {
                correctInputs.Add (UserBack);
            }

            //DOWN
            if (readSkill.Equals ("Down"))
            {
                correctInputs.Add (UserDown);
            }

            //A
            if (readSkill.Equals ("A"))
            {
                correctInputs.Add (UserA);
            }

            //B
            if (readSkill.Equals ("B"))
            {
                correctInputs.Add (UserB);
            }

            //C
            if (readSkill.Equals ("C"))
            {
                correctInputs.Add (UserC);
            }

            //D
            if (readSkill.Equals ("D"))
            {
                correctInputs.Add (UserD);
            }

            //Y
            if (readSkill.Equals ("Y"))
            {
                correctInputs.Add (UserY);
            }

            //Z
            if (readSkill.Equals ("Z"))
            {
                correctInputs.Add (UserZ);
            }

            //AB
            if (readSkill.Equals ("AB"))
            {
                correctInputs.Add (UserAB);
            }
            //AC
            if (readSkill.Equals ("AC"))
            {
                correctInputs.Add (UserAC);
            }
            //BD
            if (readSkill.Equals ("BD"))
            {
                correctInputs.Add (UserBD);
            }
            //CD
            if (readSkill.Equals ("CD"))
            {
                correctInputs.Add (UserCD);
            }
            //YZ
            if (readSkill.Equals ("YZ"))
            {
                correctInputs.Add (UserYZ);
            }

            //AA
            if (readSkill.Equals ("AA"))
            {
                correctInputs.Add (UserA);
                correctInputs.Add (UserA);
            }
            //BB
            if (readSkill.Equals ("BB"))
            {
                correctInputs.Add (UserB);
                correctInputs.Add (UserB);
            }
            //CC
            if (readSkill.Equals ("CC"))
            {
                correctInputs.Add (UserC);
                correctInputs.Add (UserC);
            }
            //DD
            if (readSkill.Equals ("DD"))
            {
                correctInputs.Add (UserD);
                correctInputs.Add (UserD);
            }
            //YY
            if (readSkill.Equals ("YY"))
            {
                correctInputs.Add (UserY);
                correctInputs.Add (UserY);
            }
            //ZZ
            if (readSkill.Equals ("ZZ"))
            {
                correctInputs.Add (UserZ);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("ABC"))
            {
                correctInputs.Add (UserABC);
            }


            //TWO BUTTON INPUTS
            //x2
            if (readSkill.Equals ("Forwardx2"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
            }
            if (readSkill.Equals ("Backx2"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserBack);
            }
            if (readSkill.Equals ("Downx2"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
            }

            if (readSkill.Equals ("Upx2"))
            {
                if (!activePlayer.StateActive (activePlayer.Airborne))
                {
                    correctInputs.Add (UserUp);
                }
                correctInputs.Add (UserUp);
            }

            if (readSkill.Equals ("BackForward"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
            }


            //FORWARD
            if (readSkill.Equals ("ForwardA"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("ForwardB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("ForwardC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("ForwardD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("ForwardAB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("ForwardCD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("ForwardY"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("ForwardZ"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("ForwardYZ"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserYZ);
            }
            if (readSkill.Equals ("ForwardCD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("ForwardAC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("ForwardBD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("ForwardBA"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
                correctInputs.Add (UserA);
            }

            //FORWARD x2
            if (readSkill.Equals ("Forwardx2A"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("Forwardx2B"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("Forwardx2C"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("Forwardx2D"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("Forwardx2AB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("Forwardx2CD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("Forwardx2AC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("Forwardx2BD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("Forwardx2Y"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("Forwardx2Z"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserZ);
            }

            //BACK
            if (readSkill.Equals ("BackA"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("BackB"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("BackC"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("BackD"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("BackAB"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("BackCD"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("BackAC"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("BackBD"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("BackYZ"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserYZ);
            }
            if (readSkill.Equals ("BackY"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("BackZ"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserZ);
            }

            //DOWN/CROUCH
            if (readSkill.Equals ("DownA"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("DownB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("DownC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("DownD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("DownAB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("DownCD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("DownAC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("DownBD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("DownYZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserYZ);
            }
            if (readSkill.Equals ("DownY"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("DownZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserZ);
            }

            //Up
            if (readSkill.Equals ("UpA"))
            {
                correctInputs.Add (UserUp);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("UpB"))
            {
                correctInputs.Add (UserUp);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("UpC"))
            {
                correctInputs.Add (UserUp);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("UpD"))
            {
                correctInputs.Add (UserUp);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("UpY"))
            {
                correctInputs.Add (UserUp);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("UpZ"))
            {
                correctInputs.Add (UserUp);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("UpAB"))
            {
                correctInputs.Add (UserUp);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("UpCD"))
            {
                correctInputs.Add (UserUp);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("UpAC"))
            {
                correctInputs.Add (UserUp);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("UpBD"))
            {
                correctInputs.Add (UserUp);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("BA"))
            {
                correctInputs.Add (UserB);
                correctInputs.Add (UserA);
                //correctInputs.Add (A);
            }

            if (readSkill.Equals ("AD"))
            {
                correctInputs.Add (UserAD);
            }
            if (readSkill.Equals ("BC"))
            {
                correctInputs.Add (UserBC);
            }

            if (readSkill.Equals ("BackAD"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserAD);
            }
            if (readSkill.Equals ("BackBC"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserBC);
            }


            //QCF
            if (readSkill.Equals ("QCF"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
            }
            if (readSkill.Equals ("CrouchAB"))
            {
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("QCFA") || readSkill.Equals ("CrouchForwardA"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("QCFB") || readSkill.Equals ("CrouchForwardB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("QCFC") || readSkill.Equals ("CrouchForwardC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("QCFD") || readSkill.Equals ("CrouchForwardD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("QCFAB") || readSkill.Equals ("CrouchForwardAB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("QCFCD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserC);
                correctInputs.Add (UserD);
            }

            if (readSkill.Equals ("CrouchForwardCD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("QCFAC") || readSkill.Equals ("CrouchForwardAC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("QCFBD") || readSkill.Equals ("CrouchForwardBD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("QCFY") || readSkill.Equals ("CrouchForwardY"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("QCFZ") || readSkill.Equals ("CrouchForwardZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("QCFYZ") || readSkill.Equals ("CrouchForwardYZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserYZ);
            }
            if (readSkill.Equals ("QCFYY"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("QCFZZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserZ);
                correctInputs.Add (UserZ);
            }

            //Down Up
            if (readSkill.Equals ("DownUpA"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("DownUpB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("DownUpC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("DownUpD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("DownUpY"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("DownUpZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("DownUpAB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("DownUpCD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("DownUpAC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("DownUpBD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("DownUpBA"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserB);
                correctInputs.Add (UserA);
                //correctInputs.Add (A);
            }


            //QCF x2
            if (readSkill.Equals ("QCFx2A"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("QCFx2B"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("QCFx2C"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("QCFx2D"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("QCFx2Y"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("QCFx2Z"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("QCFx2AB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("QCFxCD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("QCFx2AC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("QCFx2BD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("QCFx2YZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserYZ);
            }
            if (readSkill.Equals ("QCFx4Y"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
            }

            //QCF x2
            if (readSkill.Equals ("QCBx2A"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("QCBx2B"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("QCBx2C"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("QCBx2D"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("QCBx2Y"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("QCBx2Z"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("QCBx2AB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("QCBx2CD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("QCBx2AC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("QCBx2BD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("QCBx2YZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserYZ);
            }

            //QCB
            if (readSkill.Equals ("QCB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
            }
            if (readSkill.Equals ("QCBA"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("QCBB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("QCBC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("QCBD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("QCBY"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("QCBZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("QCBAB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("QCBCD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("QCBAC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("QCBBD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("QCBYZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserYZ);
            }

            //QCB
            if (readSkill.Equals ("QCDA"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("QCDB"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("QCDC"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("QCDD"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("QCDY"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("QCDZ"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("QCDAB"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("QCDCD"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("QCDAC"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("QCDBD"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("QCDYZ"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserYZ);
            }

            //Down Down
            if (readSkill.Equals ("Downx2A"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("Downx2B"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("Downx2C"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("Downx2D"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("Downx2Y"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("Downx2Z"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("Downx2AB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("Downx2CD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("Downx2AC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("Downx2BD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("Downx2YZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserYZ);
            }

            //Down Down Down
            if (readSkill.Equals ("Downx3A"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("Downx3B"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("Downx3C"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("Downx3D"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("Downx3Y"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("Downx3Z"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("Downx3AB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("Downx3CD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("Downx3AC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("Downx3BD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("Downx3YZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserYZ);
            }

            //DP
            if (readSkill.Equals ("DP"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
            }
            if (readSkill.Equals ("DPA"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("DPB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("DPC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("DPD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("DPY"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("DPZ"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("DPAB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("DPCD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("DPAC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("DPBD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("DPYZ"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserYZ);
            }

            //FORWARD x3
            if (readSkill.Equals ("Forwardx3A"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("Forwardx3B"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("Forwardx3C"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("Forwardx3D"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("Forwardx3AB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("Forwardx3CD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("Forwardx3AC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("Forwardx3BD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("Forwardx3Y"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("Forwardx3Z"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("Forwardx3YZ"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserYZ);
            }

            //QCB Forward
            if (readSkill.Equals ("QCBForwardA"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("QCBForwardB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("QCBForwardC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("QCBForwardD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("QCBForwardY"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("QCBForwardZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("QCBForwardAB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("QCBForwardCD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("QCBForwardAC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("QCBForwardBD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("QCBForwardYZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserYZ);
            }

            //RDP
            if (readSkill.Equals ("RDP"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
            }
            if (readSkill.Equals ("RDPA"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("RDPB"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("RDPC"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("RDPD"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("RDPY"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("RDPZ"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("RDPAB"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("RDPCD"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("RDPAC"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("RDPBD"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("RDPYZ"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserYZ);
            }

            //HCF
            if (readSkill.Equals ("HCF"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
            }
            if (readSkill.Equals ("HCFA"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("HCFB"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("HCFC"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("HCFD"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("HCFY"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("HCFZ"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("HCFAB"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("HCFCD"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("HCFAC"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("HCFBD"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("HCFYZ"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserYZ);
            }

            //HCFU
            if (readSkill.Equals ("HCFUA"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("HCFUB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("HCFUC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("HCFUD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("HCFUY"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("HCFUZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("HCFUAB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("HCFUCD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("HCFUAC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("HCFUBD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("HCFUYZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserYZ);
            }

            //HCF x2
            if (readSkill.Equals ("HCFx2A"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("HCFx2B"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("HCFCx2"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("HCFx2D"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("HCFx2Y"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("HCFx2Z"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("HCFx2AB"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("HCFx2CD"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("HCFx2AC"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("HCFx2BD"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("HCFx2YZ"))
            {
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserYZ);
            }


            //HCB
            if (readSkill.Equals ("HCB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
            }
            if (readSkill.Equals ("HCBA"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("HCBB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("HCBC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("HCBD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("HCBY"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("HCBZ"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("HCBAB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("HCBCD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("HCBAC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("HCBBD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("HCBYZ"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserYZ);
            }

            //HCBx2
            if (readSkill.Equals ("HCBx2A"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("HCBx2B"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("HCBx2C"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("HCBx2D"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("HCBx2Y"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("HCBx2Z"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("HCBx2AB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("HCBx2CD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("HCBx2AC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("HCBx2BD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("HCBx2YZ"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserYZ);
            }


            //Forward HCF
            if (readSkill.Equals ("ForwardHCFA"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("ForwardHCFB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("ForwardHCFC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("ForwardHCFD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("ForwardHCFY"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("ForwardHCFZ"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("ForwardHCFAB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("ForwardHCFCD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("ForwardHCFAC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("ForwardHCFBD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("ForwardHCFYZ"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserYZ);
            }


            //HCB Forward
            if (readSkill.Equals ("HCBForwardA"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("HCBForwardB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("HCBForwardC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("HCBForwardD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("HCBForwardY"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("HCBForwardZ"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("HCBForwardAB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("HCBForwardCD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("HCBForwardAC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("HCBUserForwardBD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("HCBForwardYZ"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserYZ);
            }

            //QCFQCB
            if (readSkill.Equals ("QCFHCBA"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("QCFHCBB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("QCFHCBC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("QCFHCBD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("QCFHCBY"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("QCFHCBZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("QCFHCBAB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("QCFHCBCD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("QCFHCBAC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("QCFHCBBD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("QCFHCBYZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserYZ);
            }

            //QCBQCF
            if (readSkill.Equals ("QCBHCFA"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("QCBHCFB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("QCBHCFC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("QCBHCFB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("QCBHCFY"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("QCBHCFZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("QCBHCFAB"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("QCBHCFCD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("QCBHCFAC"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("QCBHCFBD"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("QCBHCFYZ"))
            {
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserYZ);
            }

            //BACK FORWARD
            if (readSkill.Equals ("BackChargeForward"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
            }
            if (readSkill.Equals ("BackChargeForwardA"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("BackChargeForwardB"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("BackChargeForwardC"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("BackChargeForwardD"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("BackChargeForwardY"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("BackChargeForwardZ"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("BackChargeForwardAB"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("BackChargeForwardCD"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("BackChargeForwardAC"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("BackChargeForwardBD"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("BackChargeForwardYZ"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserYZ);
            }
            if (readSkill.Equals ("BackChargeForwardAA"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserA);
                correctInputs.Add (UserA);
            }


            //BACK FORWARD-BACK-FORWARD
            if (readSkill.Equals ("BackChargeFBFA"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("BackChargeFBFB"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("BackChargeFBFC"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("BackChargeFBFD"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("BackChargeFBFY"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("BackChargeFBFZ"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("BackChargeFBFAB"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("BackChargeFBFCD"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("BackChargeFBFAC"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("BackChargeFBFBD"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("BackChargeFBFYZ"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserBack);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserYZ);
            }

            //Down Up
            if (readSkill.Equals ("DownChargeUp"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserUp);
            }
            if (readSkill.Equals ("DownChargeUpA"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserUp);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("DownChargeUpB"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserUp);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("DownChargeUpC"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserUp);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("DownChargeUpD"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserUp);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("DownChargeUpY"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserUp);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("DownChargeUpZ"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserUp);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("DownChargeUpAB"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserUp);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("DownChargeUpCD"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserUp);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("DownChargeUpAC"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserUp);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("DownChargeUpBD"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserUp);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("DownChargeUpYZ"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserUp);
                correctInputs.Add (UserYZ);
            }

            //Down Up
            if (readSkill.Equals ("DownChargeFDUA"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("DownChargeFDUB"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("DownChargeFDUC"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("DownChargeFDUD"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("DownChargeFDUY"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("DownChargeFDUZ"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("DownChargeFDUAB"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("DownChargeFDUCD"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("DownChargeFDUAC"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("DownChargeFDUBD"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("DownChargeFDUYZ"))
            {
                for (int i = 0; i < chargeTime; i++)
                {
                    correctInputs.Add (UserDown);
                }
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserYZ);
            }

            //Down Up
            if (readSkill.Equals ("FBF"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
            }
            if (readSkill.Equals ("FBFA"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("FBFB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("FBFC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("FBFD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("FBFY"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("FBFZ"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("FBFAB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("FBFCD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("FBFAC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("FBFBD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("FBFYZ"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserYZ);
            }

            //360
            if (readSkill.Equals ("360"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
            }
            if (readSkill.Equals ("360A"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("360B"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("360C"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("360D"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("360Y"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("360Z"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("360AB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("360CD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("360AC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("360BD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("360YZ"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserYZ);
            }

            //720
            if (readSkill.Equals ("720A"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("720B"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("720C"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("720D"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("720Y"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("720Z"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("720AB"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserAB);
            }
            if (readSkill.Equals ("720CD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserCD);
            }
            if (readSkill.Equals ("720AC"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserAC);
            }
            if (readSkill.Equals ("720BD"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserBD);
            }
            if (readSkill.Equals ("720YZ"))
            {
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserDown);
                correctInputs.Add (UserBack);
                correctInputs.Add (UserUp);
                correctInputs.Add (UserYZ);
            }
            if (readSkill.Equals ("RapidAB"))
            {
                correctInputs.Add (UserA);
                correctInputs.Add (UserB);
                correctInputs.Add (UserA);
                correctInputs.Add (UserB);
                correctInputs.Add (UserA);
                correctInputs.Add (UserB);
                correctInputs.Add (UserA);
                correctInputs.Add (UserB);
            }

            if (readSkill.Equals ("RapidCD"))
            {
                correctInputs.Add (UserC);
                correctInputs.Add (UserD);
                correctInputs.Add (UserC);
                correctInputs.Add (UserD);
                correctInputs.Add (UserC);
                correctInputs.Add (UserD);
                correctInputs.Add (UserC);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("RapidABCD"))
            {
                correctInputs.Add (UserAB);
                correctInputs.Add (UserCD);
                correctInputs.Add (UserAB);
                correctInputs.Add (UserCD);
                correctInputs.Add (UserAB);
                correctInputs.Add (UserCD);
                correctInputs.Add (UserAB);
                correctInputs.Add (UserCD);
            }

            if (readSkill.Equals ("Ax5"))
            {
                correctInputs.Add (UserA);
                correctInputs.Add (UserA);
                correctInputs.Add (UserA);
                correctInputs.Add (UserA);
                correctInputs.Add (UserA);
            }
            if (readSkill.Equals ("Bx5"))
            {
                correctInputs.Add (UserB);
                correctInputs.Add (UserB);
                correctInputs.Add (UserB);
                correctInputs.Add (UserB);
                correctInputs.Add (UserB);
            }
            if (readSkill.Equals ("Cx5"))
            {
                correctInputs.Add (UserC);
                correctInputs.Add (UserC);
                correctInputs.Add (UserC);
                correctInputs.Add (UserC);
                correctInputs.Add (UserC);
            }
            if (readSkill.Equals ("Dx5"))
            {
                correctInputs.Add (UserD);
                correctInputs.Add (UserD);
                correctInputs.Add (UserD);
                correctInputs.Add (UserD);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("Yx5"))
            {
                correctInputs.Add (UserY);
                correctInputs.Add (UserY);
                correctInputs.Add (UserY);
                correctInputs.Add (UserY);
                correctInputs.Add (UserY);
            }
            if (readSkill.Equals ("Zx5"))
            {
                correctInputs.Add (UserZ);
                correctInputs.Add (UserZ);
                correctInputs.Add (UserZ);
                correctInputs.Add (UserZ);
                correctInputs.Add (UserZ);
            }
            if (readSkill.Equals ("ABCDABCD"))
            {
                correctInputs.Add (UserA);
                correctInputs.Add (UserB);
                correctInputs.Add (UserC);
                correctInputs.Add (UserD);
                correctInputs.Add (UserA);
                correctInputs.Add (UserB);
                correctInputs.Add (UserC);
                correctInputs.Add (UserD);
            }
            if (readSkill.Equals ("ABCDAll"))
            {
                correctInputs.Add (UserABCD);
            }
            if (readSkill.Equals ("RD"))
            {
                correctInputs.Add (UserA);
                correctInputs.Add (UserA);
                correctInputs.Add (UserForward);
                correctInputs.Add (UserB);
                correctInputs.Add (UserY);
            }

            fullInputPrompt.enabled = true;
            fullInputPrompt.transform.SetAsLastSibling ();
        }

        skillInputDelay = -1.0f;
        delayBetweenInputs = 0.0f;
        setInputImages ();
        setInputDelay ();
        stepSFX.clip = stepSound;
        stepSFX.Play ();
    }

    public Boolean remainsOnTarget (Player exec, Skill s, Player lastTarget, Location presentLoc, string direction, string output)
    {
        Location nextLoc = lastTarget.currentLocation ().getNewLocationFromDirection (direction);
        Boolean remains = s.Properties.Contains ("NOPUSH")
            //TARGET ISN'T EQUAL TO NULL
            && (!lastTarget.FirstName.Equals ("null"))
            && !exec.currentMap ().isEmpty (presentLoc)
            && (exec.currentMap ().objectAt (presentLoc).Equals (lastTarget)
                && !exec.currentMap ().isEmpty (exec.currentLocation ().getNewLocationFromDirection (direction))
                && ((exec.currentMap ().isValid (nextLoc)
                    && (!exec.currentMap ().isEmpty (nextLoc)
                        || !exec.currentMap ().canMakeMove (lastTarget, nextLoc, s)
                        || output.Contains ("is destroyed")))));
        return remains;
    }

    public void setInputDelay ()
    {
        if (correctInputs.Count == 1)
        {
            INPUTRESETTIMER = 0.2f;
        }
        else if (correctInputs.Count == 2)
        {
            INPUTRESETTIMER = 0.18f;
        }
        if (correctInputs.Count == 3)
        {
            INPUTRESETTIMER = 0.12f;
        }
        if (correctInputs.Count == 4)
        {
            INPUTRESETTIMER = 0.08f;
        }
        if (correctInputs.Count == 5)
        {
            INPUTRESETTIMER = 0.05f;
        }
        else
        {
            INPUTRESETTIMER = 0.2f;
        }

        //JUST FOR TESTING
        INPUTRESETTIMER = 0.08f;
    }

    //LOAD SKILL
    public void playAppropriateInitialAnimation (Player p, Skill s)
    {
        print (s.Name + " initial sound!");

        if (s.Timer < 0 && ((s.SelfSkill || s.Projectile || s.SuperProjectile || s.SForce || s.Magic) && (!s.Properties.Contains (" MAP ") || s.Properties.Contains (" THROW "))))
        {
            if (!s.Magic)
            {
                createAnimationOnMap ("Dust", EnvironmentChannel, p.CentralPosition, 2f, true);
            }
            else
            {
                createAnimationOnMap ("UseMagic", EnvironmentChannel, p.CentralPosition, 2f, true);
            }
        }

        if (!s.Properties.Contains ("NOSOUND"))
        {
            if (s.SearchName.Equals ("Run"))
            {
                p.Vocals.ContactSound.clip = runSound;
                p.Vocals.ContactSound.Play ();
            }
            else if (s.Name.Equals (@"Pace Cancel"))
            {
                //createAnimationOnMap("Cancel", EnvironmentChannel, p.CentralPosition, 3.5f, true);
            }
            else if (s.Properties.Contains ("BURST") || s.Properties.Contains ("CRITICAL") || s.Properties.Contains ("KNOCKOUT") || s.Name.Equals ("Pace Cancel"))
            {
                createAnimationOnMap ("Burst", EnvironmentChannel, p.CentralPosition, 2f, true);
            }
            else if (s.Properties.Contains ("VITALITY"))
            {
                createAnimationOnMap ("Vitality", EnvironmentChannel, p.CentralPosition, 2f, true);
            }
            else if (s.Malicious)
            {
                if (s.Magic)
                {
                    createAnimationOnMap ("UseMagic", EnvironmentChannel, p.CentralPosition, 2f, true);
                }
                else if (s.Physical || (s.Weapon && !s.Projectile && !s.SForce) || s.Grapple)
                {
                    createAnimationOnMap ("Dust", EnvironmentChannel, p.CentralPosition, 2f, true);
                }
                else if (s.Projectile)
                {
                    p.Vocals.ContactSound.clip = projectileSound;
                    p.Vocals.ContactSound.Play ();
                }
                else if (s.SForce || s.SuperProjectile)
                {
                    p.Vocals.ContactSound.clip = forceSound;
                    p.Vocals.ContactSound.Play ();
                }
                else if (s.Movement)
                {
                    createAnimationOnMap ("Dust", EnvironmentChannel, p.CentralPosition, 2f, true);
                }
            }
            else if (s.Beneficial)
            {
                createAnimationOnMap ("Heal", EnvironmentChannel, p.CentralPosition, 2f, true);
                if (s.Properties.Contains ("DRINK") || s.Properties.Contains ("EAT"))
                {
                    p.Vocals.Speech.clip = eatSound;
                    p.Vocals.Speech.Play ();
                }
                else
                {

                }
            }
            else
            {
                if (s.Properties.Contains ("RELOAD"))
                {

                    //p.Vocals.ContactSound.clip = reloadSound;
                    //p.Vocals.ContactSound.Play ();

                    //createAnimationOnMap ("Buff", EnvironmentChannel, p.CentralPosition, 2f, true);
                }
                else if (s.Movement || s.Type.Equals ("THROW"))
                {

                    p.Vocals.ContactSound.clip = whiffSound;
                    p.Vocals.ContactSound.Play ();

                }
                else
                {
                    //YESH
                }
            }

            if (s.Movement || s.MotionRange > 0 || s.Properties.Contains ("LEAP"))
            {
                createAnimationOnMap ("Dust", EnvironmentChannel, p.CentralPosition, 2f, true);
            }
        }
    }

    public void muteSound ()
    {
        //for (int i = 0; i < FindObjectsOfType<AudioSource> ().Length; i ++) { FindObjectsOfType<AudioSource> ()[i].volume = 0.0f;}
    }

    public string itemDrop (Player exec, Skill s, Location loc)
    {
        string output = "";

        if (!s.HasDropped)
        {
            Location fallLoc;
            Skill dropItem = s.DropItem.CloneSkill;
            dropItem.Index = exec.ObjectIndex;
            exec.ObjectIndex++;

            //Random r = new Random (
            if (!s.Properties.Contains ("DROPRANDOM"))
            {
                if (s.Benign)
                {
                    fallLoc = exec.openInteractableOf (loc, true);
                }
                else
                {
                    fallLoc = exec.openBorderOf (loc, false, dropItem);
                }
                dropItem.Location = fallLoc;
                dropItem.CurrentLocation = fallLoc;
                if (exec.currentMap ().addInteractable (dropItem, fallLoc))
                {
                    output += string.Format ("{0} is dropped! {1}" + '\n', s.DropItem.Name, fallLoc);
                    dropItem.StepTime = 0.0f;
                    s.HasDropped = true;
                }
            }
            else
            {
                ArrayList locations = exec.randomInteractablesOf (loc);
                if (exec.currentMap ().isEmpty (loc) && exec.currentMap ().isEmptyInteractable (loc)
                    && exec.currentMap ().isEmptyProjectile (loc))
                {
                    //locations = new ArrayList ();
                    //locations.Add (loc);
                    fallLoc = loc;
                }
                else
                {
                    fallLoc = (Location)locations[new System.Random ().Next (locations.Count)];
                }
                dropItem.Location = fallLoc;
                dropItem.CurrentLocation = fallLoc;
                if (exec.currentMap ().addInteractable (dropItem, fallLoc))
                {
                    output += string.Format ("{0} is dropped at random! {1}" + '\n', s.DropItem.Name, fallLoc);
                    dropItem.StepTime = 0.0f;
                    s.HasDropped = true;
                }
                //output += string.Format ("{0}" + '\n', currentMap ().interactableAt (fallLoc).Name);
            }
        }
        return output;
    }

    public void beginOutro (Player winner, Player loser, Boolean doubleKO)
    {
        if (!doubleKO)
        {
            winningTeam = oppositeTeam (loser);
            losingTeam = oppositeTeam (winningTeam);

            winningTeam.HasWon = true;


            if (winningTeam == null)
            {
                throw new NullReferenceException ("RIK?");
            }
        }

        dialogueScreenActive = true;

        setCanvas (introCutsceneCanvas, false);
        setCanvas (outroCutsceneCanvas, true);

        //outroCutsceneCanvas.transform.position = new Vector3 (outroCutsceneCanvas.transform.position.x - outroCutsceneCanvas.rectTransform.sizeDelta.x,
        //  outroCutsceneCanvas.transform.position.y);

        outroCutsceneCanvas.texture = Resources.Load<Texture>(@"Maps/" + battleMap.SearchName + "/Graphics/BackgroundHotizontal");

        bgm.Stop ();
        bgm.clip = endBattleMusic;
        bgm.Play ();
        outroWinnerText.text = "";
        dialogue = new ArrayList ();

        dialogue = new ArrayList ();

        outroP1Sprite.texture = battleMap.Team1.Representative.SpriteAppearance;
        outroP2Sprite.texture = battleMap.Team2.Representative.SpriteAppearance;
        outroP2Sprite.rectTransform.rotation = new Quaternion (0, 180, 0, 0);

        team1MVP.texture = battleMap.Team1.MVP.Portrait;
        team2MVP.texture = battleMap.Team2.MVP.Portrait;
        team2MVP.rectTransform.rotation = new Quaternion (0, 180, 0, 0);

        endgameWinner.text = winningTeam.Name.ToUpper () + " WINS!";
        endgameInfo.text = "Damage Total" + '\n';
        endgameInfo.text += HighestDamage + '\n';
        endgameInfo.text += "Highest Combo" + '\n';
        endgameInfo.text += LongestCombo;


        if (!battleMap.Team1.IsDefeated)
        {
            if (!battleMap.Team1.Representative.SearchName.Equals (battleMap.Team2.Representative.SearchName))
            {
                dialogue.Add (battleMap.Team1.Representative.SearchName + ":" + battleMap.Team1.Champion.Vocals.SpecificFinalVictory (battleMap.Team2.Fallen));
            }
            else
            {
                dialogue.Add ("mirror1:" + battleMap.Team1.Champion.Vocals.SpecificFinalVictory (battleMap.Team2.Fallen));
            }
        }
        if (!battleMap.Team2.IsDefeated)
        {
            if (!battleMap.Team1.Representative.SearchName.Equals (battleMap.Team2.Representative.SearchName))
            {
                dialogue.Add (battleMap.Team2.Representative.SearchName + ":" + battleMap.Team2.Champion.Vocals.SpecificFinalVictory (battleMap.Team1.Fallen));
            }
            else
            {
                dialogue.Add ("mirror2:" + battleMap.Team2.Champion.Vocals.SpecificFinalVictory (battleMap.Team1.Fallen));
            }
        }

        updateOutroCutscene ();

    }

    public Team oppositeTeam (Player p)
    {
        if (p.MyTeam.Name.Equals (battleMap.Team1.Name))
        {
            return battleMap.Team2;
        }
        return battleMap.Team1;
    }

    public Team oppositeTeam (Team t)
    {
        if (t.Equals (battleMap.Team1))
        {
            return battleMap.Team2;
        }
        return battleMap.Team1;
    }

    public string LongestCombo
    {
        get
        {
            return string.Format ("({0}) {1}     {2} ({3})",
                new object[] { battleMap.Team1.LongestCombo, battleMap.Team1.LongestComboChar, battleMap.Team2.LongestComboChar, battleMap.Team2.LongestCombo });
        }
    }

    public string HighestDamage
    {
        get
        {
            return string.Format ("({0}) {1}     {2} ({3})",
                new object[] { battleMap.Team1.HighestDamage, battleMap.Team1.HighestDamageChar, battleMap.Team2.HighestDamageChar, battleMap.Team2.HighestDamage });
        }
    }

    public string removePlayer (Player p)
    {
        string output = "";
        if (p.Vocals.ContactSound.volume > 0.0f)
        {
            p.Vocals.ContactSound.volume = 0.7f;
        }
        p.Vocals.ContactSound.clip = burstSound;
        p.Vocals.ContactSound.Play ();

        output += string.Format ("{0} disappears from battlefield!" + '\n', p.FirstName);
        p.Health.MeterLevel = 0;

        p.MyTeam.Roster.Remove (p);

        if (battleMap.Index >= battleMap.Roster.Count && battleMap.Index > 0)
        {
            battleMap.Index--;
        }

        Destroy (p.MapSprite);
        Destroy (p.ShadowSprite);
        Destroy (p.StatusIcon);
        Destroy (p.HealthBar);
        Destroy (p.HealthBarBackground);

        battleMap.removeObject (p);
        p.OnField = false;

        return output;
    }

    public Player getTarget ()
    {
        Location targetLoc = skillLocation;
        string direction = activePlayer.currentLocation ().DirectionOf (skillLocation);

        while (skill.locationsContains (targetLoc) && battleMap.isValid (targetLoc)
            && (battleMap.isEmpty (targetLoc) || !battleMap.objectAt (targetLoc).sentient ()))
        {

            targetLoc = targetLoc.getNewLocationFromDirection (direction);
        }
        if (battleMap.isValid (targetLoc) && !battleMap.isEmpty (targetLoc) && battleMap.objectAt (targetLoc).sentient ())
        {
            return (Player)battleMap.objectAt (targetLoc);
        }
        return null;
    }

    //LOAD SKILL
    public void playContactAnimation (Player target, Skill s, string input)
    {
        Location loc = target.currentLocation ();

        if (input.StartsWith ("+"))
        {
            createAnimationOnMap ("Heal", HitChannel, target.CentralPosition, 2f, true);
        }
        else if (input.StartsWith ("-"))
        {
            if (input.Contains ("GUARD") || target.IsGuarding)
            {
                createAnimationOnMap ("Guard", HitChannel, target.CentralPosition, 2f, true);
            }
            else
            {
                if ((s != null && s.Claw) || input.Contains ("CLAW"))
                {
                    createAnimationOnMap ("Claw", HitChannel, target.CentralPosition, 2f, true);
                }
                else
                {
                    createAnimationOnMap ("Hit", HitChannel, target.CentralPosition, 2f, true);
                }
            }
        }
        else if (s != null)
        {

            if (s.Malicious)
            {
                target.Vocals.Speech.clip = Resources.Load<AudioClip>(@"Sounds/players/" + target.Sex.ToLower () + "damage");
                target.Vocals.Speech.Play ();
            }

            if (s.Grapple)
            {
                createAnimationOnMap ("Grapple", HitChannel, target.CentralPosition, 2f, true);
            }
            else if (s.Claw)
            {
                createAnimationOnMap ("Claw", HitChannel, target.CentralPosition, 2f, true);
            }
            else if (s.Magic)
            {
                createAnimationOnMap ("HitMagic", HitChannel, target.CentralPosition, 2f, true);
            }
            else if (s.Projectile)
            {
                createAnimationOnMap ("Projectile", HitChannel, target.CentralPosition, 2f, true);
            }
            else if (s.SForce || s.SuperProjectile)
            {
                createAnimationOnMap ("Force", HitChannel, target.CentralPosition, 2f / 2, true);
            }
            else if (s.Weapon)
            {
                createAnimationOnMap ("Weapon", HitChannel, target.CentralPosition, 2f, true);
            }
            else if (s.Malicious)
            {
                if (!target.IsGuarding)
                {
                    createAnimationOnMap ("Hit", HitChannel, target.CentralPosition, 2f, true);
                }
            }
        }

        if (((s == null || s.Malicious) && (input.Contains ("-") && input.EndsWith ("HP"))) && !target.IsGuarding)
        {
            target.Vocals.Speech.clip = Resources.Load<AudioClip>(@"Sounds/players/" + target.Sex + "damage");
            target.Vocals.Speech.Stop ();
            target.Vocals.Speech.Play ();
        }
        if (s != null && s.Properties.Contains (" DRINK "))
        {
            target.Vocals.ContactSound.clip = poisonSound;
            target.Vocals.ContactSound.Stop ();
            target.Vocals.ContactSound.Play ();
        }
        else if (s != null && s.Properties.Contains (" EAT "))
        {
            target.Vocals.ContactSound.clip = poisonSound;
            target.Vocals.ContactSound.Stop ();
            target.Vocals.ContactSound.Play ();
        }

    }

    //BATTLE MAP OPTIONS, STEP FORWARD ONCE
    public string IncrementSingleTurnActions (Player p, ArrayList players, Boolean objectMotion, Skill s, float mult)
    {
        string output = "" + '\n';

        output += checkMapTraits ("TIME", battleMap.Time);

        /**

        Player cur;
        int reps = 0;
        //Skill skl;


        for (int i = 0; i < battleMap.Roster.Count; i++) {
            cur = (Player)battleMap.Roster [i];
            if (//!cur.KOd &&
                //!cur.Equals (p) &&
                (players == null || !players.Contains (cur))) {
                if (cur.PlayerCanIncrementCycle) {
                    reps++;
                    if (reps == 1) {
                        output += string.Format ("CYCLING" + '\n');
                    }

                    //output += incrementBurningFallingAndStanding (((Player)battleMap.Roster [i]));
                }
            }
        }
        if (reps > 0) {
            output += " " + '\n';
        }
        */
        if (!objectMotion || s == null)
        {
            output += IncrementObjectMotion ("", null, mult);
        }
        else
        {
            output += IncrementObjectMotion (s.TrapSkill.Name, s.Owner, mult);
        }
        return output;
    }

    public string incrementBurningFallingStaggerAndStanding (Player p)
    {
        string output = "";

        if (p.Fatigue == 0)
        {
            p.ResidualFatigue = 0;
        }

        if (!p.KOd && p.Fatigue > 0)
        {

            p.AddFatigue (-1);
            if (p.Fatigue == 0)
            {
                p.Fatigue = 0;
                output += string.Format ("{0} recovers." + '\n', p.FirstName);
                if (!p.StateActive (p.Invisible))
                {
                    addToNotificationQueue (null, p, p.FirstName.ToUpper () + " RECOVERS!", true);
                    createAnimationOnMap ("Recovery", StateChannel, p.CentralPosition, 1f, false);
                }

            }
            else
            {
                output += string.Format ("{0} Recovery: {1}" + '\n', p.FirstName, p.Fatigue);
                createAnimationOnMap ("Breathe", StateChannel, p.CentralPosition, p.Fatigue / (1f + p.Fatigue), true);
                //addToNotificationQueue (null, p, p.FirstName.ToUpper () + " REC " + p.Fatigue + ")!", true);
                if (!p.Equals (activePlayer))
                {

                }
            }
        }

        //STAGGERING
        if (p.StaggerTime > 0)
        {

            Location nextLoc = null;
            Location oldLoc = p.currentLocation ();
            int oldHeight = p.Potency (p.Airborne);

            if (p.StaggerDirection.Equals ("N"))
            {
                nextLoc = p.currentLocation ().North;
            }
            if (p.StaggerDirection.Equals ("E"))
            {
                nextLoc = p.currentLocation ().East;
            }
            if (p.StaggerDirection.Equals ("S"))
            {
                nextLoc = p.currentLocation ().South;
            }
            if (p.StaggerDirection.Equals ("W"))
            {
                nextLoc = p.currentLocation ().West;
            }
            if (p.StaggerDirection.Equals ("X"))
            {
                nextLoc = p.currentLocation ();
            }

            p.StaggerTime--;
            //addToNotificationQueue (null, p, "STAG " + p.StaggerTime, false);

            p.Vocals.ContactSound.clip = stepSound;
            p.Vocals.ContactSound.Play ();

            //STAGGER
            if (p.StaggerTime == 0)
            {

                p.SetGround (p.HurtStun + 1, true);
                p.Staggered = false;
                p.StaggerTime = -1;
                p.StaggerDirection = "";
            }
            else if (p.StaggerTime > 0 && battleMap.isValid (nextLoc))
            {

                if (battleMap.isEmpty (nextLoc) || p.currentLocation ().Equals (nextLoc))
                {
                    oldLoc = p.currentLocation ();
                    oldHeight = p.Potency (p.Airborne);

                    output += recordMovement (p, null, nextLoc, false, false, p.CanFly || p.StateActive (p.Airborne), false, false, true, nextLoc.DirectionOf (oldLoc));

                    if (p.OnField)
                    {
                        displayMapMovement (p, oldLoc, oldHeight, p.currentLocation (), p.Potency (p.Airborne), "CrouchNeutral", 5, false, null, nextLoc.DirectionOf (oldLoc));
                    }
                }
                //if an object is in that location
                else
                {

                    if (p.HurtStun > 0)
                    {
                        p.IsCrouching = true;
                        p.HurtStun++;
                    }
                    else
                    {
                        p.SetGround (p.HurtStun, true);
                    }


                    if (!battleMap.objectAt (nextLoc).sentient ())
                    {

                        MapObject ob = (MapObject)battleMap.objectAt (nextLoc);
                        int str = ob.Strength;

                        if (ob.Strength > p.StaggerTime)
                        {

                            ob.Strength -= p.StaggerTime;

                            p.StaggerTime = -1;
                            p.StaggerDirection = "";
                            p.Staggered = false;

                            if (p.HurtStun > 0)
                            {
                                p.IsCrouching = true;
                                p.HurtStun++;
                            }
                            else
                            {
                                p.SetGround (p.HurtStun, true);
                            }



                        }
                        else if (p.StaggerTime > ob.Strength)
                        {
                            output += string.Format ("{0} is destroyed!" + '\n', ob.Name);
                            createAnimationOnMap ("Burn", EnvironmentChannel, getImageFromLocation (ob.currentLocation ()).transform.position, 1f, true);
                            battleMap.removeObject (ob);

                        }
                    }
                    //if a player is in that location
                    else
                    {

                    }
                }

            }
            else
            {

                p.StaggerTime = -1;
                p.StaggerDirection = "";

                if (p.HurtStun > 0)
                {
                    p.IsCrouching = true;
                    p.HurtStun++;
                }
                else
                {
                    p.SetGround (p.HurtStun, true);
                }
            }
        }

        //GROUNDED
        if (!p.KOd && !p.StateActive (p.Sleep)
            && p.Potency (p.Grounded) > 1
            && !p.StateActive (p.Confuse) && (p.WasHit || p.InRecovery))
        {
            //NEW STAND UP MECHANIC
            p.Grounded.Potency--;
            if (!p.StateActive (p.Grounded))
            {
                p.Grounded.Potency = 0;
                p.Grounded.NumTurns = 0;
                p.Grounded.Probability = 0.0;
                output += string.Format ("{0} stands up." + '\n', p.FirstName);
                p.Vocals.ContactSound.clip = stepSound;
                p.Vocals.ContactSound.Play ();
                mapHasChanged = true;
            }
            else
            {
                output += string.Format ("{0} Grounded {1}" + '\n', p.FirstName, p.Potency (p.Grounded));
            }
        }

        //AIRBORNE
        if (p.StateActive (p.Airborne) && !p.Flight //|| p.KOd || p.WasHit || p.AirOff || p.InRecovery 
            && (p != activePlayer || (skill != null && !skill.Properties.Contains ("FLOAT "))))
        {

            p.SetHeight (p.Potency (p.Airborne) - 1);
            mapHasChanged = true;

            if (!p.StateActive (p.Airborne))
            {
                p.AirOff = false;

                if (p.KOd)
                {
                    p.Grounded.Potency = 100;
                }

                if (p.WasHit)
                {
                    if (p.FallingHeight > 10)
                    {
                        output += string.Format ("{0} crashes into the ground!" + '\n', p.FirstName);

                        createAnimationOnMap ("Earth", EnvironmentChannel, p.CentralPosition, 1f, true);

                        p.Grounded.Potency = (p.FallingHeight / 2) + 1;


                        if (!p.KOd)
                        {
                            if ((-10 + (p.Grit / 20)) * p.FallingHeight >= 0)
                            {
                                output += shiftHealth (p, -1, true, null, null);
                            }
                            else
                            {
                                output += shiftHealth (p, (-10 + (p.Grit / 20)) * p.FallingHeight, true, null, null);
                            }
                        }
                    }
                    else
                    {
                        output += string.Format ("{0} falls to the ground!" + '\n', p.FirstName);
                        p.Grounded.Potency = (p.FallingHeight / 2) + 1;

                        createAnimationOnMap ("Earth", EnvironmentChannel, p.CentralPosition, 1f, true);

                    }


                }
                else
                {
                    output += string.Format ("{0} lands." + '\n', p.FirstName);
                    createAnimationOnMap ("Dust", EnvironmentChannel, p.CentralPosition, 1f, false);
                    p.Vocals.ContactSound.clip = stepSound;
                    p.Vocals.ContactSound.Play ();
                }
                p.FallingHeight = 0;
            }

            //POSITION CHECK
            if (skill != null && !skill.presentPositionConditionsMet (activePlayer))
            {
                setSkill (null, -1, null);
            }

        }
        if (p.GuardStun > 0)
        {
            p.GuardStun--;
            output += string.Format ("{0} Guard Stun {1}" + '\n', p.FirstName, p.GuardStun);
            if (p.GuardStun == 0)
            {
                createAnimationOnMap ("Recovery", StateChannel, p.CentralPosition, 1f, true);
            }
        }
        if (p.HurtStun > 0)
        {
            p.HurtStun--;
            output += string.Format ("{0} Hurt Stun {1}" + '\n', p.FirstName, p.HurtStun);
            if (p.HurtStun == 0)
            {
                createAnimationOnMap ("Stun", StateChannel, p.CentralPosition, 1f, true);
            }
        }
        if (p.StateActive (p.Burn))
        {
            output += burnPlayer (p);
        }
        output += " " + '\n';
        return output;
    }

    public string burnPlayer (Player p)
    {

        string output = "";
        double chance = p.R.NextDouble ();
        if (p.StateActive (p.Burn))
        {
            output += string.Format ("{0} gets burned!" + '\n', p.FirstName);
            int shift = (p.Potency (p.Burn) * -3) + (p.ElementalDefense[0] / 5);

            if (shift > -1)
            {
                shift = -1;
            }

            addToNotificationQueue (null, p, string.Format (p.FirstName + ": ABLAZE! " + shift + "HP").ToUpper (), true);
            createAnimationOnMap ("Burn", HitChannel, p.CentralPosition, 2f, true);

            output += shiftHealth (p, shift, false, null, null);
            if (chance < p.Dexterity)
            {
                string x = p.Burn.IncrementVariants;
                if (!p.StateActive (p.Burn))
                {
                    output += string.Format ("Flame is doused." + '\n');
                }
            }
        }
        return output;

    }

    public string IncrementObjectMotion (string s, Player owner, float mult)
    {
        string output = "";
        Skill skl;
        for (int i = 0; i < battleMap.Interactables.Count; i++)
        {
            if (i >= 0)
            {
                skl = (Skill)battleMap.Interactables[i];
                if (mult > 0.0f)
                {
                    skl.StepTime += Time.deltaTime * (mult * 2);
                    skl.StepTimeModulus = stepTime - 1;
                }

                if (skl.StepTimeModulus >= 0.0f || mult < 0.0f)
                {

                    skl.StepTime = 0.0f;

                    if (!skl.Name.Equals (s) && !skl.Owner.Equals (owner) && skl.MaxRange > 0)
                    {
                        if (skl.CurrentRange.Equals (skl.MaxRange))
                        {
                            output += string.Format ("{0} ends. ({1})" + '\n', skl.Name, skl.CurrentRange);
                            battleMap.removeInteractable (skl);
                            i--;
                            mapHasChanged = true;
                        }
                        else if (!battleMap.isValid (skl.Location))
                        {
                            output += string.Format ("{0} ({1}) hits a boundary." + '\n', skl.Name, skl.Location);
                            battleMap.removeInteractable (skl);
                            i--;
                            mapHasChanged = true;
                        }
                        else
                        {
                            skl.CurrentRange++;

                            Location changeLoc = null;

                            if ((!skl.Direction.Equals ("X") && !skl.Direction.Equals ("")) || skl.Properties.Contains ("TRACK"))
                            {
                                battleMap.ProjectileGrid[skl.Location.Row][skl.Location.Column] = null;
                                if (skl.Properties.Contains ("TRACK"))
                                {
                                    changeLoc = closestMemberTo (skl);
                                }
                                else if (skl.Direction.Equals ("N"))
                                {
                                    changeLoc = skl.Location.North;
                                }
                                else if (skl.Direction.Equals ("E"))
                                {
                                    changeLoc = skl.Location.East;
                                }
                                else if (skl.Direction.Equals ("S"))
                                {
                                    changeLoc = skl.Location.South;
                                }
                                else if (skl.Direction.Equals ("W"))
                                {
                                    changeLoc = skl.Location.West;
                                }
                                else if (skl.Direction.Equals ("NE"))
                                {
                                    changeLoc = skl.Location.NorthEast;
                                }
                                else if (skl.Direction.Equals ("SE"))
                                {
                                    changeLoc = skl.Location.SouthEast;
                                }
                                else if (skl.Direction.Equals ("NW"))
                                {
                                    changeLoc = skl.Location.NorthWest;
                                }
                                else if (skl.Direction.Equals ("SW"))
                                {
                                    changeLoc = skl.Location.SouthWest;
                                }
                            }

                            if (skl.Properties.Contains ("BOOMERANG") &&
                                (!battleMap.isValid (changeLoc)
                                 || !battleMap.isEmptyInteractable (changeLoc)
                                 || !battleMap.isEmptyProjectile (changeLoc)))
                            {
                                skl.Direction = battleMap.oppositeDirection (skl.Direction);
                                if (skl.Properties.Contains ("TRACK"))
                                {
                                    changeLoc = closestMemberTo (skl);
                                }
                                else if (skl.Direction.Equals ("N"))
                                {
                                    changeLoc = skl.Location.North;
                                }
                                else if (skl.Direction.Equals ("E"))
                                {
                                    changeLoc = skl.Location.East;
                                }
                                else if (skl.Direction.Equals ("S"))
                                {
                                    changeLoc = skl.Location.South;
                                }
                                else if (skl.Direction.Equals ("W"))
                                {
                                    changeLoc = skl.Location.West;
                                }
                                else if (skl.Direction.Equals ("NE"))
                                {
                                    changeLoc = skl.Location.NorthEast;
                                }
                                else if (skl.Direction.Equals ("SE"))
                                {
                                    changeLoc = skl.Location.SouthEast;
                                }
                                else if (skl.Direction.Equals ("NW"))
                                {
                                    changeLoc = skl.Location.NorthWest;
                                }
                                else if (skl.Direction.Equals ("SW"))
                                {
                                    changeLoc = skl.Location.SouthWest;
                                }

                            }

                            if (!skl.Properties.Contains ("TRACE") && (!skl.Direction.Equals ("X") || skl.Properties.Contains ("TRACK"))
                                && battleMap.isValid (changeLoc)
                                && battleMap.locationInHeightRange (changeLoc, skl)
                                && battleMap.lineSkillCanReach (skl, changeLoc))
                            {

                                output += changeSkillLocation (skl, changeLoc, ref i, battleMap.Interactables);
                                mapHasChanged = true;

                            }
                            else
                            {
                                if (owner != null)
                                {
                                    playAppropriateSound (owner.Vocals.ContactSound, skl);
                                }
                                output += string.Format ("{0} ({1}) ceases to exist." + '\n', skl.Name, skl.Location);
                                battleMap.removeInteractable (skl);
                                i--;
                                mapHasChanged = true;

                            }
                        }

                        if (battleMap.Interactables.Contains (skl) && skl.Timer > 0)
                        {
                            skl.Timer--;
                            //output += string.Format ("{0} ({1} remaining)" + '\n', skl.Name, skl.Timer);
                            if (skl.Timer == 0)
                            {

                                if (skl.Properties.Contains ("ACTIVATE"))
                                {
                                    output += string.Format ("{0} is time activated!" + '\n', skl.Name);

                                    output += executeSkill (skl.Owner, skl, skl.CurrentLocation,
                                        "", true, false, !skl.HasLinks, 1.0);
                                    if (skl.ThresholdMeasure == 0 || skl.NumUses == 0)
                                    {
                                        battleMap.removeInteractable (skl);
                                        i--;
                                    }
                                }
                                else
                                {
                                    if (owner != null)
                                    {
                                        playAppropriateSound (owner.Vocals.ContactSound, skl);
                                    }
                                    output += string.Format ("{0} ({1}) ceases to exist." + '\n', skl.Name, skl.Location);
                                    battleMap.removeInteractable (skl);
                                    i--;
                                    mapHasChanged = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        return output;
    }

    //LOAD SKILL
    public void playAppropriateSound (AudioSource src, Skill s)
    {
        if (!s.Properties.Contains ("NOSOUND"))
        {

            src.clip = blankSound;
            if (src.volume > 0.0f && src.volume == 1.0f)
            {
                src.volume = 0.7f;
            }
            if (s.Properties.Contains ("BURST") || s.Properties.Contains ("CRITICAL") || s.Properties.Contains ("KNOCKOUT"))
            {
                src.clip = burstSound;
            }
            else if (s.Properties.Contains ("VITALITY"))
            {
                if (s.Grapple)
                {
                    src.clip = grappleSound;
                }
                else if (s.Claw)
                {
                    src.clip = clawSound;
                }
                else if (s.Magic)
                {
                    src.clip = malMagicSound;
                }
                else if (s.Projectile)
                {
                    src.clip = projectileSound;
                }
                else if (s.Weapon)
                {
                    src.clip = weaponSound;
                }
                else
                {
                    src.clip = forceSound;
                }
            }
            else if (s.Malicious)
            {
                if (s.Grapple)
                {
                    src.clip = grappleSound;
                }
                else if (s.Claw)
                {
                    src.clip = clawSound;
                }
                else if (s.Magic)
                {
                    src.clip = malMagicSound;
                }
                else if (s.Projectile)
                {
                    src.clip = projectileSound;
                }
                else if (s.SForce || s.SuperProjectile)
                {
                    src.clip = forceSound;
                }
                else if (s.Weapon)
                {
                    src.clip = weaponSound;
                }
                else
                {
                    src.clip = punchSound;
                }
            }
            else if (s.Beneficial)
            {
                src.clip = benMagicSound;
            }
            else
            {
                if (s.Properties.Contains ("RELOAD"))
                {
                    //src.clip = reloadSound;
                }
                else if (s.Movement)
                {
                    src.clip = whiffSound;
                }
                else
                {
                    src.clip = skillSound;
                }
            }
            print (s.Name + " sound");
            src.Play ();
        }
    }

    public Location closestMemberTo (Skill s, Location loc, Team t)
    {

        int spn = 50;
        Location l = null;
        Boolean diagonals = s.Properties.Contains ("DIAGONAL");
        Player p;

        for (int i = 0; i < t.Roster.Count; i++)
        {
            p = (Player)t.Roster[i];
            print (p.closestLocationFrom (loc, diagonals) + " is closest to " + loc + " for " + p.Name);
            if (p.closestLocationFrom (loc, diagonals).span (loc) < spn)
            {

                l = p.closestLocationFrom (loc, diagonals);
                spn = l.span (loc);
                print (p.Name + " (" + spn + ") is closest.");
            }
        }
        return l;
    }

    public Location closestMemberTo (Skill s)
    {

        int spn = 50;
        Location l = s.Location, cLoc = null;
        Location sLoc = s.Location;
        Player p;
        string nm = "";
        Boolean diagonals = s.Properties.Contains ("DIAGONAL");

        print (s.Name + " is at " + s.Location);
        for (int i = 0; i < battleMap.Roster.Count; i++)
        {
            p = (Player)battleMap.Roster[i];
            cLoc = p.closestLocationFrom (sLoc, diagonals);
            if (s.properHitSection (p) && (s.Malicious && !p.sameTeam (s.Owner)) || (s.Beneficial && p.sameTeam (s.Owner)) && (!p.KOd || (s.Properties.Contains ("KOD ") || s.Properties.Contains (" ALLST "))))
            {
                print ("Checking if " + cLoc + " is closest to " + s.Owner.FirstName + "'s skill of location " + s.Location + " for " + p.Name);

                if (((battleMap.isEmpty (cLoc) || !battleMap.objectAt (cLoc).isVisible ()) || (!s.Properties.Contains ("SMART")
                    || (s.Malicious && battleMap.objectAt (cLoc).sentient () && !((Player)battleMap.objectAt (cLoc)).sameTeam (s.Owner))
                    || (s.Beneficial && battleMap.objectAt (cLoc).sentient () && ((Player)battleMap.objectAt (cLoc)).sameTeam (s.Owner))))
                    && cLoc.span (p.currentLocation ()) < spn)
                {
                    nm = p.Name;
                    l = cLoc;
                    spn = l.span (p.currentLocation ());
                    print (p.Name + " (" + spn + ") is closer than the last.");
                    s.Direction = s.Location.DirectionOf (p);
                }
            }
        }

        print (nm + " (" + l + ") is the closest location of all to " + sLoc);
        return l;
    }

    public string checkMapTraits (string nm, int mapVariable)
    {
        string output = "Checking " + nm + '\n';
        for (int i = 0; i < battleMap.Traits.Length; i++)
        {

            if (battleMap.Traits[i].Abbreviation.Equals (nm))
            {


                print (battleMap.Traits[i].Name + " by " + nm + ": " + mapVariable);

                if (mapVariable % battleMap.Traits[i].NumTurns == 0)
                {
                    output += string.Format ("{0} is activated! ({1}%)" + '\n', battleMap.Traits[i].Name, (int)(battleMap.Traits[i].Probability * 100));
                    output += activateMapSkill (battleMap.Traits[i]);//executeMapTrait (battleMap.Traits [i]);
                }
                else
                {
                    output += string.Format ("{0} rounds until activating... {1}" + '\n', battleMap.Traits[i].Name,
                                            battleMap.Traits[i].NumTurns - (mapVariable % battleMap.Traits[i].NumTurns));

                }
            }
        }
        return output;
    }

    public string stepObjectTime (int amount)
    {

        string output = "";
        for (int t = 0; t < amount; t++)
        {

            for (int i = 0; i < battleMap.Interactables.Count; i++)
            {
                Skill s = (Skill)battleMap.Interactables[i];
                if (!s.Properties.Contains ("DIRECTION") && s.Timer > 0 && !s.Properties.Contains (" PERM "))
                {
                    s.Timer--;

                    if (s.Timer == 0)
                    {

                        //if (!s.Owner.FirstName.Contains ("owner")) {
                        //}

                        //addToNotificationQueue (s, s.Owner, s.Name + " ACTIVATED!", false);


                        output += string.Format ("{0} is activated!" + '\n', s.Name);
                        output += executeSkill (s.Owner, s, s.CurrentLocation, "", true, false, !s.HasLinks, 1.0);
                        battleMap.removeInteractable (s);
                        i--;
                    }
                    else
                    {

                        if (s.Properties.Contains (" COUNTDOWN "))
                        {
                            addToNotificationQueue (s, s.Owner, s.Name + " COUNTDOWN (" + s.Timer + ")", false);
                        }

                        if (!s.Properties.Contains ("DIRECTION"))
                        {
                            output += string.Format ("{0} time remaining: {1}." + '\n', s.Name, s.Timer);

                            if (!s.Owner.FirstName.Contains ("owner"))
                            {

                            }
                        }
                    }
                }
            }
        }
        return output;
    }

    public void setActiveTime (float addition, float ratio)
    {
        if (activePlayer != null)
        {
            if (activePlayer.Speed > 0)
            {
                battleMap.ActiveTime = ((((float)activePlayer.Speed * 120) / 5) + addition) * ratio;
                timeMax = ((((float)activePlayer.Speed * 120) / 5) + addition) * ratio;

            }
            else
            {
                battleMap.ActiveTime = 0.001f;
                timeMax = 1.0f;
            }
            if (activePlayer.MyTeam.AutoLink)
            {

            }
        }
    }

    public string IncrementRound (Player obj, Player lastPlayer)
    {

        string output = "";

        for (int i = 0; i < battleMap.Objects.Count; i++)
        {
            Locatable p = (Locatable)battleMap.Objects[i];
            if (p.sentient ())
            {
                if (obj.Equals (p))
                {
                    output += resetRound ((Player)p, null);
                }
                else
                {
                    if (!p.Equals (lastPlayer))
                    {
                        output += incrementRound ((Player)p);
                    }
                }
            }
            else
            {
                if (((MapObject)p).RemainingTime > 0)
                {
                    ((MapObject)p).RemainingTime--;

                    if (((MapObject)p).RemainingTime == 0)
                    {
                        output += string.Format ("{0} disappears." + '\n', ((MapObject)p).Name);

                        if (obj.Vocals.ContactSound.volume > 0.0f)
                        {
                            obj.Vocals.ContactSound.volume = 0.7f;
                        }

                        createAnimationOnMap ("Contact", EnvironmentChannel, getImageFromLocation (p.currentLocation ()).transform.position, 1f, true);


                        battleMap.removeObject (p);
                        updateMap (activePlayer);
                        i--;
                    }
                    else
                    {
                        output += string.Format ("{0} time remaining: {1}." + '\n', ((MapObject)p).Name, ((MapObject)p).RemainingTime);
                    }
                }
            }
        }
        output += stepObjectTime (1);
        if (!obj.KOd && obj.IsAble)
        {
            //REMAIN TRUE
            output += IncrementSingleTurnActions (null, battleMap.Roster, true, null, -1.0f);
        }
        return output;
    }

    public string resetRound (Player p, Player lastPlayer)
    {
        string output = "";
        //string output = "RESET ROUND OF " + FirstName + "," +
        //  " " + timeRemaining + '\n';
        firstMoveActivated = false;

        if (p.TransformationTime > 0)
        {
            p.TransformationTime --;
            if (p.TransformationTime == 0)
            {
                output += p.transform (p.StoredPlayer, false, p.CriticalActive, true, -1);
            }
        }


        if (p.TimeRemaining > 0)
        {
            p.TimeRemaining--;
        }

        if (p.TimeRemaining == 0)
        {

            output += removePlayer(p);
            updateMap();

        }
        else if (battleMap.heightOf (p.currentLocation ()) < 0 && !p.Flight && !p.CanFly)
        {
            output += koPlayer (p, null, null, true);
        }
        else
        {
            output += string.Format ("{0}'s turn begins." + '\n', p.FirstName);
            p.CounterPlayer = null;

            output += reduceTimedSkillTimers (p);
            output += p.strength.IncrementVariants;
            output += p.grit.IncrementVariants;
            output += p.magick.IncrementVariants;
            output += p.resistance.IncrementVariants;
            output += p.dexterity.IncrementVariants;
            output += p.speed.IncrementVariants;
            output += p.proration.IncrementVariants;
            output += p.movement.IncrementVariants;
            output += p.teamwork.IncrementVariants;
            output += p.luck.IncrementVariants;

            if (p.AssimilatedTime != 0)
            {
                p.AssimilatedTime--;
                if (p.AssimilatedTime == 0)
                {
                    p.AssimilatedClass = "";
                }
            }

            p.Staggered = false;
            p.StaggerDirection = "";
            p.StaggerTime = -1;

            Skill lskl;

            p.LongestCombo.Clear ();

            for (int i = 0; i < p.StateResistances.Length; i++)
            {
                if (p.StateResistances[i].Holder > 0)
                {
                    p.StateResistances[i].Holder--;

                    if (p.StateResistances[i].Holder == 0)
                    {
                        p.StateResistances[i].BaseValue = 0;
                        output += string.Format ("{0} resistance back to normal." + '\n', p.StateResistances[i].Name);
                    }
                }
            }

            State st;
            Skill sk;
            for (int i = 0; i < p.TimedConditions.Count; i++)
            {

                st = (State)p.TimedConditions[i];
                if (!st.Name.Equals ("TMFRZ") && st.NumTurns > 0)
                {
                    st.NumTurns--;
                    if (st.NumTurns == 0)
                    {

                        if (st.Name.Equals ("LAST STAND"))
                        {
                            output += string.Format ("Last Stand ends!" + '\n');
                            p.LastStand = false;
                            for (int j = 0; j < p.AllSkills.Count; j++)
                            {
                                sk = (Skill)p.AllSkills[j];
                                if (sk.Properties.Contains (" LSTAND ") && p.forget (sk))
                                {
                                    output += string.Format ("{0} is forgotten!" + '\n', sk.Name);
                                }
                            }
                        }

                        if (st.Name.Equals ("LEECH"))
                        {
                            output += string.Format ("Leech ends!" + '\n');
                            p.Leech = false;
                            for (int j = 0; j < p.AllSkills.Count; j++)
                            {
                                sk = (Skill)p.AllSkills[j];
                                if (sk.Properties.Contains (" LEECHONLY ") && p.forget (sk))
                                {
                                    output += string.Format ("{0} is forgotten!" + '\n', sk.Name);
                                }
                            }
                        }

                        if (st.Name.Equals ("COUNTER"))
                        {
                            output += string.Format ("Counter state ends!" + '\n');
                            p.CounterState = false;
                            for (int j = 0; j < p.AllSkills.Count; j++)
                            {
                                sk = (Skill)p.AllSkills[j];
                                if (sk.Properties.Contains (" CTRST ") && p.forget (sk))
                                {
                                    output += string.Format ("{0} is forgotten!" + '\n', sk.Name);
                                }
                            }
                        }


                        if (st.Name.Equals ("X-STATE"))
                        {
                            output += string.Format ("Special State ends!" + '\n');
                            for (int j = 0; j < p.AllSkills.Count; j++)
                            {
                                sk = (Skill)p.AllSkills[j];
                                if (sk.Properties.Contains (" S-ST ") && p.forget (sk))
                                {
                                    output += string.Format ("{0} is forgotten!" + '\n', sk.Name);
                                }
                            }
                            p.SpecialState = false;
                        }

                        if (st.Name.Equals ("BLOOD"))
                        {
                            output += string.Format ("Blood Price ends!" + '\n');
                            for (int j = 0; j < p.AllSkills.Count; j++)
                            {
                                sk = (Skill)p.AllSkills[j];
                                if (sk.Properties.Contains (" BLOOD ") && p.forget (sk))
                                {
                                    output += string.Format ("{0} is forgotten!" + '\n', sk.Name);
                                }
                            }
                            p.BloodPrice = false;
                        }

                        if (st.Name.Equals ("BERSERK"))
                        {
                            output += string.Format ("Berserker Mode ends!" + '\n');
                            for (int j = 0; j < p.AllSkills.Count; j++)
                            {
                                sk = (Skill)p.AllSkills[j];
                                if (sk.Properties.Contains (" BRSRK ") && p.forget (sk))
                                {
                                    output += string.Format ("{0} is forgotten!" + '\n', sk.Name);
                                }
                            }
                            p.Berserk = false;
                            if (p.Health.MeterLevel <= 0)
                            {
                                koPlayer (p, null, null, false);
                            }
                        }

                        if (st.Name.Equals ("UNDEAD"))
                        {
                            output += string.Format ("Return to the living!" + '\n');
                            for (int j = 0; j < p.AllSkills.Count; j++)
                            {
                                sk = (Skill)p.AllSkills[j];
                                if (sk.Properties.Contains (" UNDED ") && p.forget (sk))
                                {
                                    output += string.Format ("{0} is forgotten!" + '\n', sk.Name);
                                }
                            }
                            p.Undead = false;
                        }

                        if (st.Name.Equals ("FLIGHT"))
                        {
                            output += string.Format ("Flight ends!" + '\n');
                            for (int j = 0; j < p.AllSkills.Count; j++)
                            {
                                sk = (Skill)p.AllSkills[j];
                                if (sk.Properties.Contains (" FLY ") && p.forget (sk))
                                {
                                    output += string.Format ("{0} is forgotten!" + '\n', sk.Name);
                                }
                            }
                            p.Flight = false;
                        }

                        if (st.Name.StartsWith ("HITSTUN"))
                        {
                            output += string.Format ("Hit stun returns to normal!" + '\n');
                            p.HitStunAdjustment -= NumberConverter.ConvertToInt (st.Name.Substring (st.Name.IndexOf ('-') + 1));
                            new DataReader ().calibrateLinks (p, true);
                        }

                        if (st.Name.Equals ("NOCONDITIONS"))
                        {
                            output += string.Format ("No  ends!" + '\n');
                            for (int j = 0; j < p.AllSkills.Count; j++)
                            {
                                sk = (Skill)p.AllSkills[j];
                                if (sk.Properties.Contains (" NOCOND ") && p.forget (sk))
                                {
                                    output += string.Format ("{0} is forgotten!" + '\n', sk.Name);
                                }
                            }
                            p.NoConditions = false;
                        }

                        if (st.Name.Equals ("HALFCOST"))
                        {
                            output += string.Format ("Costs back to normal!" + '\n');
                            p.HalfCost = false;
                        }

                        if (st.Name.Equals ("NOCOST"))
                        {
                            output += string.Format ("Costs back to normal!" + '\n');
                            p.NoCost = false;
                        }

                        p.TimedConditions.Remove (st);
                        i--;
                    }
                }


            }
            Skill s;

            for (int i = 0; i < p.TrackSkills.Count; i++)
            {
                s = (Skill)p.TrackSkills[i];
                if (s.ThresholdMeasure == 0 || s.Threshold == 0 || s.NumUses == 0)
                {

                    p.TrackSkills.Remove (p.TrackSkills[i]);
                    i--;
                }
            }


            if (p.StateActive (p.Grounded))
            {
                p.Grounded.Potency = 0;
                p.Grounded.NumTurns = 0;
                p.Grounded.Probability = 0.0;
                output += string.Format ("{0} stands up. ", p.FirstName);
            }

            if (!p.KOd)
            {
                for (int i = 0; i < p.States.Length; i++)
                {
                    if (!p.States[i].Name.Equals ("Burn"))
                    {
                        output += p.States[i].IncrementVariants;
                        if (p.States[i].Name.Equals ("Counter")
                            && !p.StateActive (p.States[i])
                            && p.CounterSkill != null)
                        {
                            p.forget (p.CounterSkill);
                        }
                    }
                }

                output += " " + '\n';
                if (p.Health.MeterShift > 0)
                {
                    output += shiftHealth (p, (int)(p.Health.MeterShift), false, null, null);
                }
                else
                {
                    if (!p.IsResting)
                    {
                        output += shiftHealth (p, (int)(p.Health.MeterShift), false, null, null);
                    }
                }
                output += shiftRush (p, (int)(p.Rush.MeterShift * p.RestRatio) * p.Ratio, false, null);
                output += shiftGuard (p, (int)(p.Guard.MeterShift * p.RestRatio), false, null);
                output += shiftVitality (p, (int)(p.Vitality.MeterShift), false, null);


                if (p.IsTaunting)
                {
                    output += string.Format ("{0} taunting bonus! {1}" + '\n', p.FirstName, shiftVitality (p, 100 + (200 / p.TauntBonus (oppositeTeam (p))), true, null));
                    p.TauntDecay++;
                    p.IsResting = false;
                }
                p.IsTaunting = false;

                if (!p.IsResting)
                {
                    output += shiftStun (p, -1, false, null);
                }
                else
                {
                    output += shiftHealth (p, (int)(200 * p.Ratio), true, null, null);
                    if (p.IsCrouching)
                    {
                        output += shiftHealth (p, (int)(100 * p.Ratio), true, null, null);
                    }
                    output += shiftStun (p, -5 * p.Ratio, false, null);
                    output += p.Daze.ClearStates;
                    output += p.Adle.ClearStates;
                    output += p.Poison.ClearStates;
                    output += p.Confuse.ClearStates;

                    p.NumRests++;
                }
                p.IsResting = false;

                //canChain = false;
                p.ChainSkills = new ArrayList ();
                p.BurstFollowUpSkills = new ArrayList ();

                if (p.CounterSkill != null && !p.CounterSkill.Properties.Contains ("REMAIN "))
                {
                    p.CounterSkill = null;
                }

                p.CurrentProration = 1.0;
                p.MovesRemaining = p.Movement;
                p.HasJumped = false;
                p.HasActed = false;
                output += p.setAction (true);
                p.WasDizzied = false;
                if (p.IsDizzied)
                {
                    p.IsDizzied = false;
                    p.WasDizzied = true;
                }
                p.InRecovery = false;
                p.CanRest = true;
                p.HitMaliciously = false;
                p.TurnEnded = false;
                p.ConnectsPerRound = 0;
                p.AttacksPerRound = 0;
                p.SpeedBonuses = 0;
                if (p.Cooldown > 0)
                {
                    p.Cooldown--;
                    output += string.Format ("Cooldown: {0}" + '\n', p.Cooldown);
                }

                if (p.StateActive (p.Poison))
                {
                    output += getPoisoned (p) + '\n';
                }

                if (p.StateActive (p.Regen) && !p.StateActive (p.Parry))
                {
                    output += getRegen (p) + '\n';
                }


                p.Combo = 0;
                p.ComboDamagePerRound = 0;
                p.DamagePerRound = 0;
                p.HealingPerRound = 0;
                p.StunPerRound = 0;
                p.DamageTakenPerRound = 0;
                p.StatusAfflictionsPerRound = 0;
                p.StatusAidsPerRound = 0;
                p.GuardStun = 0;
                p.HurtStun = 0;
                p.LockedOnTarget = null;
                p.resetDefeats ();

                output += p.Unguard;
            }
        }
        return output;
    }

    public string getPoisoned (Player p)
    {
        string output = string.Format ("{0} feels the effects of poison!" + '\n', p.FirstName);
        int shift = ((p.Potency (p.Poison) * -30) - (p.Resistance / 30)) * 2;

        addToNotificationQueue (null, p, string.Format (p.FirstName + ": POISON " + shift + "HP").ToUpper (), true);
        createAnimationOnMap ("Poison", HitChannel, getImageFromLocation (p.currentLocation ()).transform.position, 2f, true);
        output += shiftHealth (p, p.randomOutput (shift), false, null, null);

        double rand = p.R.NextDouble ();
        if (rand < p.Dexterity / 2)
        {
            output += p.Poison.IncrementVariants;
        }

        return output;
    }

    public string getRegen (Player p)
    {
        string output = string.Format ("{0} regenerates health!" + '\n', p.FirstName);
        int shift = p.Potency (p.Regen) * 25;
        output += shiftHealth (p, p.randomOutput (shift) * 2, true, null, null);
        return output;
    }

    public string incrementRound (Player p)
    {
        string output = "";

        output += p.Grounded.IncrementVariants;
        output += p.Airborne.IncrementVariants;
        output += shiftStun (p, -1, false, null);

        if (p.StateActive (p.Sleep))
        {
            createAnimationOnMap ("Sleep", StateChannel, p.CentralPosition, 1f, true);
            addToNotificationQueue (null, p, p.Sleep.NumTurns + " ZZZ...", true);
        }

        return output;
    }

    public string concat (string text)
    {
        string finalTxt = "";

        if ((text.Equals ("...") && text.Length <= 4) || text.Equals ("…") && text.Length <= 2)
        {
            return "grunt";
        }
        for (int i = 0; i < text.Length; i++)
        {
            if ((text.ToLower ()[i] >= 'a' && text.ToLower ()[i] <= 'z'))
            {
                finalTxt += text.ToLower ()[i];
            }
        }
        return finalTxt;
    }

    public string reduceTimedSkillTimers (Player p)
    {
        string output = "";
        Skill s;
        for (int i = 0; i < p.TimeActivatedSkills.Count; i++)
        {
            s = (Skill)p.TimeActivatedSkills[i];
            output += string.Format ("{0}" + '\n', s.Name);
            s.Timer--;
            output += string.Format ("{0} Time Remaining: {1}" + '\n', s.Name, s.Timer);
            if (s.Timer == 0)
            {
                output += string.Format ("{0} is activated!" + '\n', s.Name);
                output += executeSkill (s.Owner, s, p.currentLocation (),
                    "X", true, false, !s.HasLinks, 1.0);

                if (s.Magic)
                {
                    createAnimationOnMap ("Shock", HitChannel, p.CentralPosition, 2f, true);
                }
                else
                {
                    createAnimationOnMap ("Dust", HitChannel, p.CentralPosition, 2f, true);
                }
                p.TimeActivatedSkills.Remove (s);
                i--;
            }
        }
        return output;
    }

    //LOAD SKILL
    public void playContactSound (Player target, Skill s, string input)
    {
        AudioSource src = new GameObject ().AddComponent<AudioSource>();
        src.gameObject.name = target.SearchName + " PlayContactSound ";
        if (s != null)
        {
            src.gameObject.name += s.SearchName;
        }
        else
        {
            src.gameObject.name += input;
        }
        src.clip = blankSound;
        src.volume = 1.0f;
        muteSound ();

        if (src.volume > 0.0f && src.volume == 1.0f)
        {
            src.volume = 0.7f;
        }

        if (input.StartsWith ("+"))
        {
            src.clip = benMagicSound;
            if (!target.IsGuarding)
            {
                createAnimationOnMap ("Heal", HitTextChannel, target.CentralPosition, 2f, false);
            }
        }
        else if (input.StartsWith ("-"))
        {
            if (target.IsGuarding)
            {
                createAnimationOnMap ("HitPhysical", HitTextChannel, target.CentralPosition, 2f, false);
                src.clip = guardSound;
            }
            else
            {
                createAnimationOnMap ("HitPhysical", HitTextChannel, target.CentralPosition, 2f, false);
                target.Vocals.ContactSound.clip = punchSound;
                target.Vocals.ContactSound.Play ();
            }
        }
        else if (input.Contains ("GRAPPLE"))
        {
            createAnimationOnMap ("Grapple", HitTextChannel, target.CentralPosition, 2f, false);
            src.clip = grappleSound;
        }
        else if (input.Contains ("CLAW"))
        {
            createAnimationOnMap ("Claw", HitTextChannel, target.CentralPosition, 2f, false);
            src.clip = clawSound;
        }
        else if (input.Contains ("MAGIC") && input.Contains ("MALICIOUS"))
        {
            if (input.Contains ("MALICIOUS") || (s.Malicious))
            {
                createAnimationOnMap ("HitMagic", HitTextChannel, target.CentralPosition, 2f, false);
                src.clip = punchSound;
            }
            else
            {
                createAnimationOnMap ("Heal", HitTextChannel, target.CentralPosition, 2f, true);

            }
        }
        else if (input.Contains ("PROJECTILE"))
        {
            createAnimationOnMap ("HitPhysical", HitTextChannel, target.CentralPosition, 2f, false);
            src.clip = projectileSound;
        }
        else if (input.Contains ("PROJECTILE-S") || input.Contains ("FORCE"))
        {
            createAnimationOnMap ("HitPhysical", HitTextChannel, target.CentralPosition, 2f, false);
            src.clip = forceSound;
        }
        else if (input.Contains ("WEAPON"))
        {
            createAnimationOnMap ("HitPhysical", HitTextChannel, target.CentralPosition, 2f, false);
            src.clip = weaponSound;
        }
        else if (input.Contains ("MALICIOUS"))
        {
            if (!target.IsGuarding)
            {
                createAnimationOnMap ("HitPhysical", HitTextChannel, target.CentralPosition, 2f, false);
            }
            src.clip = punchSound;
        }

        src.Play ();

    }

    private string force (Player exec, int distance, Player target, string direction)
    {
        int finalDistance = distance;
        if (target.IsGuarding && Math.Abs (distance) > 1)
        {
            finalDistance /= 2;
        }
        string output = "";
        double chance = 0;
        Boolean hitObject = false;
        //string direction = baseLoc.DirectionOf (target.currentLocation ());
        Location checkLocation = target.currentLocation ();

        //PUSHING
        if (distance > 0)
        {
            for (int i = 0; i < finalDistance && !hitObject; i++)
            {
                checkLocation = checkLocation.getNewLocationFromDirection (direction);
                if (battleMap.isValid (checkLocation))
                {
                    if (battleMap.isEmpty (checkLocation))
                    {
                        output += recordMovement (target, null, checkLocation, false, false,
                                                  target.Flight, false, true, true, target.DirectionOf (exec));
                    }
                }
                else
                {
                    hitObject = true;
                    output += string.Format ("{0} hits the wall!" + '\n', target.FirstName);

                }
            }
        }

        //PULLING
        else if (distance < 0)
        {
            for (int i = 0; i < finalDistance && !hitObject; i++)
            {
                chance = exec.R.NextDouble ();
                checkLocation = checkLocation.getNewLocationFromOppositeDirection (direction);
                if (battleMap.isValid (checkLocation))
                {
                    if (battleMap.isEmpty (checkLocation))
                    {
                        output += recordMovement (target, null, checkLocation, false, false,
                                                  target.Flight, false, true, true, target.DirectionOf (exec));
                    }
                }
                else
                {
                    hitObject = true;
                    output += string.Format ("{0} hits the wall!" + '\n', target.FirstName);
                }
            }
        }

        return output;
    }

    //FORCE
    private string force (Player exec, Skill s, Player target, Location baseLoc, Boolean cancelledOut, string direction)
    {
        int finalDistance = s.Force.Potency;
        if (target.IsGuarding && Math.Abs (s.Force.Potency) > 1)
        {
            finalDistance /= 2;
        }
        string output = "";
        double chance = 0;
        Boolean hitObject = false;
        Location checkLocation = target.currentLocation ();
        Location contactPoint = target.currentLocation ();
        Location goFlyingLoc = new Location (checkLocation.Row, checkLocation.Column);

        print (direction + " is push direction");

        //PUSHING
        if (s.Force.Potency > 0 && (!s.Properties.Contains ("CTRFRC") || target.ResidualFatigue > 0))
        {
            for (int i = 0; i < finalDistance && !hitObject; i++)
            {
                //print (s.Name + " pushing " + target.currentLocation ());
                chance = exec.R.NextDouble ();
                if (chance < s.Force.Probability)
                {
                    checkLocation = checkLocation.getNewLocationFromDirection (direction);
                    if (battleMap.isValid (checkLocation))
                    {
                        contactPoint = checkLocation;
                    }
                    if (battleMap.isValid (checkLocation) && battleMap.isEmpty (checkLocation)
                        && battleMap.canBePushed (target, checkLocation, s))
                    {
                        goFlyingLoc = new Location (checkLocation.Row, checkLocation.Column);
                    }

                    //print (s.Name + " pushing " + target.currentLocation () + " " + checkLocation);
                    if (battleMap.isValid (checkLocation) && battleMap.canBePushed (target, checkLocation, s))
                    {

                        //print (s.Name + " pushing again" + target.currentLocation () + " " + checkLocation);
                        if (battleMap.isEmpty (checkLocation) && !s.Properties.Contains ("GOFLYING"))
                        {
                            //output += "YEAH!" + '\n';

                            //print (s.Name + " pushing one more time " + target.currentLocation () + " " + checkLocation);
                            output += recordMovement (target, s, checkLocation, false, false,
                                                      target.Flight || s.Properties.Contains ("SPIRAL"), false, true, true, target.DirectionOf (exec));

                        }
                        else
                        {
                            if (!battleMap.isEmpty (checkLocation)
                                && !battleMap.objectAt (checkLocation).sentient () && !s.Properties.Contains ("GOFLYING"))
                            {

                                MapObject obj = (MapObject)battleMap.objectAt (checkLocation);
                                if (obj.interactsWith (target))
                                    hitObject = true;

                                obj.Strength--;
                                output += string.Format ("{0} hits {1}! ({2})" + '\n',
                                    target.FirstName, obj.Name, obj.Strength);

                                if (obj.Strength <= 0)
                                {
                                    output += string.Format ("{0} is destroyed!" + '\n', obj.Name);
                                    createAnimationOnMap ("Burn", EnvironmentChannel, getImageFromLocation (obj.currentLocation ()).transform.position, 1f, true);
                                    battleMap.removeObject (obj);
                                }

                                if (s.Properties.Contains ("SPIRALCHAIN")
                                    && s.setCostsAndConditionsMet (s.LinkSkills)
                                    && (!s.Properties.Contains ("BORDERONLY") || target.OnBorder)
                                    && (!s.Properties.Contains ("CTRONLY") || target.ResidualFatigue > 0)
                                    && (!s.Properties.Contains ("AIRONLY") || target.StateActive (target.Airborne) && !target.AirOff)
                                    && (!s.Properties.Contains ("GROUNDONLY") || target.StateActive (target.Grounded))
                                    && (!s.Properties.Contains ("STANDONLY") || (!target.StateActive (target.Airborne))))
                                {

                                    output += "*** SPIRAL LINK" + '\n';
                                    hitObject = true;

                                    if (!s.Properties.Contains ("SPIRALDMG")
                                        && !s.Properties.Contains ("SPIRALHP")
                                        && !s.Properties.Contains ("SPIRALBOUNCE"))
                                    {
                                        createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                                    }
                                    else
                                    {
                                        createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                                    }
                                }
                                if (s.Properties.Contains ("SPIRALDMG"))
                                {

                                    if (!s.Properties.Contains ("SPIRALCHAIN")
                                        && !s.Properties.Contains ("SPIRALHP")
                                        && !s.Properties.Contains ("SPIRALBOUNCE"))
                                    {
                                        createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                                    }
                                    else
                                    {
                                        createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                                    }

                                    output += shiftHealth (target, exec.randomOutput (s.Change[0] / 3), true, exec, s);
                                }
                                if (s.Properties.Contains ("SPIRALHP"))
                                {
                                    output += properOutput (exec, (int)(exec.CurrentProration * (NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('%') + 1, 3)) * -1)), target, s);
                                }
                                if (s.Properties.Contains ("SPIRALBOUNCE"))
                                {
                                    int bounce = NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('%') + 1, 3));
                                    Location bounceLoc = target.currentLocation ();
                                    for (int j = 0; j < bounce; j++)
                                    {
                                        bounceLoc = target.currentLocation ().getNewLocationFromDirection (target.currentLocation ().DirectionOf (exec));
                                        if (battleMap.isEmpty (bounceLoc))
                                        {
                                            recordMovement (target, s, bounceLoc, false, false,
                                                            target.Flight, false, true, true, target.DirectionOf (exec));
                                        }
                                    }

                                    if (!s.Properties.Contains ("SPIRALCHAIN")
                                        && !s.Properties.Contains ("SPIRALHP")
                                        && !s.Properties.Contains ("SPIRALDMG"))
                                    {
                                        createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                                    }
                                    else
                                    {
                                        createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                                    }
                                }
                                if (s.Properties.Contains ("WALLFALL"))
                                {
                                    target.States[1].Potency += s.StateAlterations[1].Potency;
                                }

                            }
                        }
                    }
                    else
                    {
                        if (!s.Properties.Contains ("GOFLYING"))
                        {
                            hitObject = true;
                            output += string.Format ("{0} hits the wall!" + '\n', target.FirstName);

                            if (s.Properties.Contains ("SPIRALCHAIN")
                                && s.setCostsAndConditionsMet (s.LinkSkills)
                                && (!s.Properties.Contains ("BORDERONLY") || target.OnBorder)
                                && (!s.Properties.Contains ("CTRONLY") || target.ResidualFatigue > 0 || target.Fatigue > 0)
                                && (!s.Properties.Contains ("AIRONLY") || target.StateActive (target.Airborne) && !target.AirOff)
                                && (!s.Properties.Contains ("GROUNDONLY") || target.StateActive (target.Grounded))
                                && (!s.Properties.Contains ("STANDONLY") || (!target.StateActive (target.Airborne))))
                            {
                                output += "*** PUSH LINK" + '\n';
                                hitObject = true;
                                if (!s.Properties.Contains ("SPIRALDMG")
                                    && !s.Properties.Contains ("SPIRALHP")
                                    && !s.Properties.Contains ("SPIRALBOUNCE"))
                                {
                                    createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                                }
                                else
                                {
                                    createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                                }

                            }
                            if (s.Properties.Contains ("SPIRALDMG"))
                            {
                                if (!s.Properties.Contains ("SPIRALCHAIN")
                                    && !s.Properties.Contains ("SPIRALHP")
                                    && !s.Properties.Contains ("SPIRALBOUNCE"))
                                {
                                    createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                                }
                                else
                                {
                                    createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                                }
                                output += shiftHealth (target, exec.randomOutput (s.Change[0] / 3), true, exec, s);
                            }
                            if (s.Properties.Contains ("SPIRALHP"))
                            {
                                if (!s.Properties.Contains ("SPIRALCHAIN")
                                    && !s.Properties.Contains ("SPIRALDMG")
                                    && !s.Properties.Contains ("SPIRALBOUNCE"))
                                {
                                    createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                                }
                                else
                                {
                                    createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                                }
                                output += properOutput (exec, (int)(exec.CurrentProration * (NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('%') + 1, 3)) * -1)), target, s);
                            }
                            if (s.Properties.Contains ("SPIRALBOUNCE"))
                            {

                                if (!s.Properties.Contains ("SPIRALCHAIN")
                                    && !s.Properties.Contains ("SPIRALHP")
                                    && !s.Properties.Contains ("SPIRALDMG"))
                                {
                                    createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                                }
                                else
                                {
                                    createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                                }

                                int bounce = NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('%') + 1, 3));
                                Location bounceLoc = target.currentLocation ();
                                for (int j = 0; j < bounce; j++)
                                {
                                    bounceLoc = target.currentLocation ().getNewLocationFromDirection (target.currentLocation ().DirectionOf (exec));
                                    if (battleMap.isEmpty (bounceLoc))
                                    {
                                        output += recordMovement (target, s, bounceLoc, false, false,
                                                                  target.Flight, false, true, true, target.DirectionOf (exec));
                                    }
                                }
                            }
                            if (s.Properties.Contains ("WALLFALL"))
                            {
                                target.States[1].Potency += s.StateAlterations[1].Potency;
                            }
                        }
                    }
                }
            }
            if (s.Properties.Contains ("GOFLYING"))
            {
                //output += "YEAH";
                output += recordMovement (target, s, goFlyingLoc, false, false,
                                          target.Flight, false, true, true, target.DirectionOf (exec));
            }
        }

        //PULLING
        else if (s.Force.Potency < 0 && (!s.Properties.Contains ("CTRFRC") || target.ResidualFatigue > 0 || target.Fatigue > 0))
        {
            checkLocation = target.currentLocation ();
            for (int i = 0; i < Math.Abs (finalDistance) && !hitObject; i++)
            {
                chance = exec.R.NextDouble ();
                if (chance < s.Force.Probability)
                {
                    checkLocation = checkLocation.getNewLocationFromOppositeDirection (direction);
                    if (battleMap.isValid (checkLocation))
                    {
                        contactPoint = checkLocation;
                    }
                    if (battleMap.isValid (checkLocation))
                    {
                        if (battleMap.isEmpty (checkLocation))
                        {
                            output += recordMovement (target, s, checkLocation, false, false,
                                                      target.Flight, false, true, true, target.DirectionOf (exec));
                        }
                        else
                        {
                            if (battleMap.objectAt (checkLocation).Equals (this) && s.Properties.Contains ("PULL "))
                            {
                                hitObject = true;
                            }
                        }
                    }
                    else
                    {
                        hitObject = true;
                        output += string.Format ("{0} hits the wall!" + '\n', target.FirstName);
                        if (s.Properties.Contains ("SPIRALCHAIN")
                            && s.setCostsAndConditionsMet (s.LinkSkills)
                            && (!s.Properties.Contains ("BORDERONLY") || target.OnBorder)
                            && (!s.Properties.Contains ("CTRONLY") || target.ResidualFatigue > 0)

                            && (!s.Properties.Contains ("AIRONLY") || target.StateActive (target.Airborne) && !target.AirOff)

                            && (!s.Properties.Contains ("GROUNDONLY") || target.StateActive (target.Grounded))
                            && (!s.Properties.Contains ("STANDONLY") || (!target.StateActive (target.Airborne))))
                        {
                            output += "*** PULL LINK" + '\n';
                            hitObject = true;

                            if (!s.Properties.Contains ("SPIRALDMG"))
                            {
                                createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                            }
                            else
                            {
                                createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                            }
                        }
                        if (s.Properties.Contains ("SPIRALDMG"))
                        {
                            if (!s.Properties.Contains ("SPIRALCHAIN"))
                            {
                                createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                            }
                            else
                            {
                                createAnimationOnMap ("Wall", EnvironmentChannel, getImageFromLocation (contactPoint).transform.position, 1f, true);
                            }

                            output += shiftHealth (target, exec.randomOutput (s.Change[0] / 10), true, exec, s);
                        }
                    }
                }
            }
        }
        return output;
    }

    public string properOutput (Player exec, int value, Player target, Skill s)
    {
        return shiftHealth (target, exec.randomOutput (s.elementalOutput (target, s.ratioOutput (target, value))), true, exec, null);
    }

    public string elements (Player exec, Skill s, Player target, double decay)
    {
        string output = "";
        double chance;

        double dexMagChanceRatio = (((exec.Dexterity / 10) * s.Ratio) + ((exec.Magick / 1000) * (1 - s.Ratio)));
        if (s.Malicious)
        {
            dexMagChanceRatio -= ((target.Dexterity / 10) * s.Ratio) + ((target.Magick / 1000) * (1 - s.Ratio));
        }

        //FIRE PROBABILITY
        if (s.Elementals[0].Probability > 0)
        {
            chance = exec.R.NextDouble () - dexMagChanceRatio;
            if (chance < s.Elementals[0].Probability)
            {

                //FIRE MALICIOUS EFFECT
                if (s.Malicious)
                {
                    createAnimationOnMap ("Burn", ElementChannel, target.CentralPosition, 1f * s.Elementals[0].Potency, true);

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("FIRE- ({0}, {1})", new object[] { (s.Elementals[0].Potency), (s.Elementals[0].NumTurns) }), true);
                    }


                    if (!target.IsGuarding)
                    {

                        if (target.StateActive (target.Freeze))
                        {
                            output += string.Format ("{0} is unfrozen and set ablaze!" + '\n', target.FirstName);
                            target.Freeze.Clear ();
                        }
                        else
                        {
                            output += string.Format ("{0} is set ablaze!" + '\n', target.FirstName);
                        }

                        target.Burn.Add (new State ("Burn", "BRN",
                            (s.Elementals[0].Potency), 0.0, s.Elementals[0].NumTurns, 1.0, true, "is burned!"));
                        s.Owner.StatusAfflictionsPerRound++;
                        s.Owner.StatusAfflictionsTotal++;

                    }
                    else
                    {

                        target.Burn.Add (new State ("Burn", "BRN",
                            (s.Elementals[0].Potency / 2), 0.0, s.Elementals[0].NumTurns, 1.0, true, "is burned!"));
                        s.Owner.StatusAfflictionsPerRound++;
                        s.Owner.StatusAfflictionsTotal++;

                    }
                    //FIRE BENEFICIAL EFFECT
                }
                else
                {
                    createAnimationOnMap ("Burn", ElementChannel, target.CentralPosition, 1f * s.Elementals[1].Potency, true);

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("FIRE+ ({0}, {1})", new object[] { (s.Elementals[0].Potency), (s.Elementals[0].NumTurns) }), true);
                    }


                    output += string.Format ("{0}'s strength is augmented by {1} for {2} turns!" + '\n',
                        target.FirstName, (int)(s.Elementals[0].Potency * decay), s.Elementals[0].NumTurns);
                    target.strength.addVariant (new State ("Strength", "STR", s.Elementals[0].Potency, 0.0,
                        s.Elementals[0].NumTurns, 1, true, "'s strength is augmented!"));
                    output += string.Format ("Strength {0}" + '\n', target.Strength);

                }
            }
        }

        //ICE PROBABILITY
        if (s.Elementals[1].Probability > 0)
        {
            chance = exec.R.NextDouble () - dexMagChanceRatio;
            if (chance < s.Elementals[1].Probability)
            {

                createAnimationOnMap ("Icy", ElementChannel, target.CentralPosition, 1f * s.Elementals[2].Potency, true);

                //ICE MALICIOUS EFFECT
                if (s.Malicious)
                {

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("ICE- ({0}, {1})", new object[] { (s.Elementals[1].Potency), (s.Elementals[1].NumTurns) }), true);
                    }


                    if (!target.IsGuarding)
                    {

                        output += string.Format ("{0} is frozen!" + '\n', target.FirstName);
                        s.Owner.StatusAfflictionsPerRound++;
                        s.Owner.StatusAfflictionsTotal++;
                        target.Freeze.Add (new State ("Freeze", "FRZ",
                            (s.Elementals[1].Potency), 0.0, s.Elementals[1].NumTurns, 1.0, true, "is frozen!"));

                    }
                    else
                    {
                        output += shiftHealth (target, -1 * (s.Elementals[1].Potency), true, exec, s);
                        output += shiftGuard (target, -1 * (s.Elementals[1].Potency), true, exec);
                    }
                    //ICE BENEFICIAL EFFECT
                }
                else
                {


                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("ICE+ ({0}, {1})", new object[] { (s.Elementals[1].Potency), (s.Elementals[1].NumTurns) }), true);
                    }


                    output += string.Format ("{0}'s grit is augmented by {1} for {2} turns!" + '\n',
                        target.FirstName, s.Elementals[1].Potency, s.Elementals[1].NumTurns);
                    target.strength.addVariant (new State ("Grit", "GRT", s.Elementals[1].Potency, 0.0,
                        s.Elementals[1].NumTurns, 1, false, ""));
                    output += string.Format ("Grit {0}" + '\n', target.Grit);


                }
            }

        }

        //ELECTRICITY PROBABILITY
        if (s.Elementals[2].Probability > 0)
        {
            chance = exec.R.NextDouble () - dexMagChanceRatio;
            if (chance < s.Elementals[2].Probability)
            {

                createAnimationOnMap ("Shock", ElementChannel, target.CentralPosition, 1f * s.Elementals[2].Potency, true);

                //ELECTRICITY MALICIOUS EFFECT
                if (s.Malicious)
                {

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("ELECTRICITY- ({0}, {1})", new object[] { (s.Elementals[2].Potency), (s.Elementals[2].NumTurns) }), true);
                    }

                    if (!target.IsGuarding)
                    {

                        output += string.Format ("{0} is shocked!" + '\n', target.FirstName);
                        s.Owner.StatusAfflictionsPerRound++;
                        s.Owner.StatusAfflictionsTotal++;
                        target.Daze.Add (new State ("Daze", "DAZ",
                            (s.Elementals[2].Potency), 0.0, s.Elementals[2].NumTurns, 1.0, true, "is stunned!"));

                    }
                    else
                    {
                        output += shiftHealth (target, -1 * (s.Elementals[2].Potency), true, exec, s);
                        output += shiftGuard (target, -1 * (s.Elementals[2].Potency), true, exec);

                    }
                    //ELECTRICITY BENEFICIAL EFFECT
                }
                else
                {

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("ELECTRICITY- ({0}, {1})", new object[] { (s.Elementals[2].Potency), (s.Elementals[2].NumTurns) }), true);
                    }

                    output += string.Format ("{0}'s resistant to Stun for {1} turns!" + '\n',
                        target.FirstName, s.Elementals[0].Potency, s.Elementals[0].NumTurns);
                    target.StateResistances[0].BaseValue = s.Elementals[2].Potency / 10;
                    target.StateResistances[0].Holder = s.Elementals[2].NumTurns;
                }
            }
        }

        //WIND PROBABILITY
        if (s.Elementals[3].Probability > 0)
        {
            chance = exec.R.NextDouble () - dexMagChanceRatio;
            if (chance < s.Elementals[3].Probability)
            {

                createAnimationOnMap ("Whiff", ElementChannel, target.CentralPosition, 1f * s.Elementals[3].Potency, true);

                //WIND MALICIOUS EFFECT
                if (s.Malicious)
                {

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("AIR- ({0}, {1})", new object[] { (s.Elementals[3].Potency), (s.Elementals[3].NumTurns) }), true);
                    }


                    if (!target.IsGuarding)
                    {
                        output += string.Format ("{0} is blasted!" + '\n', target.FirstName);
                        output += force (exec, s.Elementals[3].Potency, target, exec.currentLocation ().DirectionOf (target));
                    }
                    else
                    {
                        output += force (exec, s.Elementals[3].Potency / 2, target, exec.currentLocation ().DirectionOf (target));
                    }
                    //WIND BENEFICIAL EFFECT
                }
                else
                {

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("AIR+ ({0}, {1})", new object[] { (s.Elementals[3].Potency), (s.Elementals[3].NumTurns) }), true);
                    }

                    output += string.Format ("{0}'s movement is augmented by {1} for {2} turns!" + '\n',
                        target.FirstName, s.Elementals[3].Potency, s.Elementals[3].NumTurns);
                    target.movement.addVariant (new State ("Movement", "MOV", s.Elementals[3].Potency, 0.0,
                        s.Elementals[3].NumTurns, 1, false, "movement is augmented!"));
                    output += string.Format ("Movement {0}" + '\n', target.Movement);

                }
            }
        }

        //WATER PROBABILITY
        if (s.Elementals[4].Probability > 0)
        {
            chance = exec.R.NextDouble () - dexMagChanceRatio;
            if (chance < s.Elementals[4].Probability)
            {

                createAnimationOnMap ("Water", ElementChannel, target.CentralPosition, 1f * s.Elementals[4].Potency, true);

                //WATER MALICIOUS EFFECT
                if (s.Malicious)
                {

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("WATER- ({0}, {1})", new object[] { (s.Elementals[4].Potency), (s.Elementals[4].NumTurns) }), true);
                    }


                    if (!target.IsGuarding)
                    {
                        if (!target.StateActive (target.Burn))
                        {
                            output += string.Format ("{0} is soaked!" + '\n', target.FirstName);
                        }
                        else
                        {
                            output += string.Format ("{0} is soaked and doused!" + '\n', target.FirstName);
                            target.Burn.Clear ();
                        }

                        target.speed.addVariant (new State ("Speed", "SPD",
                            0, -1 * ((double)s.Elementals[4].Potency) / 50, s.Elementals[4].NumTurns, 1.0, false, ""));
                        target.dexterity.addVariant (new State ("Dexterity", "SPD",
                            0, -1 * ((double)s.Elementals[4].Potency) / 100, s.Elementals[4].NumTurns, 1.0, false, ""));

                    }
                    else
                    {
                        output += shiftHealth (target, -1 * (s.Elementals[4].Potency), true, exec, s);
                        output += shiftGuard (target, -1 * (s.Elementals[4].Potency), true, exec);
                    }
                    //WATER BENEFICIAL EFFECT
                }
                else
                {

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("WATER+ ({0}, {1})", new object[] { (s.Elementals[4].Potency), (s.Elementals[4].NumTurns) }), true);
                    }

                    output += string.Format ("{0} is slicker for {1} turn (s)!" + '\n', target.FirstName, s.Elementals[4].NumTurns);
                    target.speed.addVariant (new State ("Speed", "SPD",
                        0, ((double)s.Elementals[4].Potency) / 50, s.Elementals[4].NumTurns, 1.0, false, ""));
                    target.dexterity.addVariant (new State ("Dexterity", "SPD",
                        0, ((double)s.Elementals[4].Potency) / 100, s.Elementals[4].NumTurns, 1.0, false, ""));

                }
            }
        }

        //EARTH PROBABILITY
        if (s.Elementals[5].Probability > 0)
        {
            chance = exec.R.NextDouble () - dexMagChanceRatio;
            if (chance < s.Elementals[5].Probability)
            {

                createAnimationOnMap ("Earth", ElementChannel, target.CentralPosition, 1f * s.Elementals[5].Potency, true);

                //EARTH MALICIOUS EFFECT
                if (s.Malicious)
                {

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("EARTH- ({0}, {1})", new object[] { (s.Elementals[5].Potency), (s.Elementals[5].NumTurns) }), true);
                    }

                    if (!target.IsGuarding)
                    {
                        output += string.Format ("{0} is crushed!" + '\n', target.FirstName);
                        target.Grounded.Potency += s.Elementals[5].Potency;
                    }
                    else
                    {
                        output += shiftHealth (target, -4 * (s.Elementals[5].Potency), true, exec, s);
                        output += shiftGuard (target, -4 * (s.Elementals[5].Potency), true, exec);

                    }
                    //EARTH BENEFICIAL EFFECT
                }
                else
                {

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("EARTH+ ({0}, {1})", new object[] { (s.Elementals[5].Potency), (s.Elementals[5].NumTurns) }), true);
                    }


                    output += string.Format ("{0} gains immunity and invulnerability for {1} turn (s)!" + '\n', target.FirstName,
                        s.Elementals[5].NumTurns);
                    target.Invulnerable.Add (new State ("Invulnerable", "INV", s.Elementals[5].Potency,
                        0.0, s.Elementals[5].NumTurns, 0, false, ""));
                    target.Immune.Add (new State ("Immunity", "IMM", s.Elementals[5].Potency,
                        0.0, s.Elementals[5].NumTurns, 0.0, false, ""));

                }
            }

        }

        //METAL PROBABILITY
        if (s.Elementals[6].Probability > 0)
        {
            chance = exec.R.NextDouble () - dexMagChanceRatio;
            if (chance < s.Elementals[6].Probability)
            {

                createAnimationOnMap ("Parry", ElementChannel, target.CentralPosition, 1f * s.Elementals[6].Potency, true);

                //METAL MALICIOUS EFFECT
                if (s.Malicious)
                {

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("METAL- ({0}, {1})", new object[] { (s.Elementals[6].Potency), (s.Elementals[6].NumTurns) }), true);
                    }

                    if (!target.IsGuarding)
                    {
                        output += string.Format ("{0} is pummeled!" + '\n', target.FirstName);
                        output += shiftHealth (target, -10 * s.Elementals[6].Potency, true, exec, s);

                    }
                    else
                    {
                        output += shiftHealth (target, -5 * (s.Elementals[6].Potency), true, exec, s);
                    }
                    //METAL BENEFICIAL EFFECT
                }
                else
                {

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("METAL+ ({0}, {1})", new object[] { (s.Elementals[6].Potency), (s.Elementals[6].NumTurns) }), true);
                    }

                    output += string.Format ("{0} gains parry for {1} turn (s)!" + '\n', target.FirstName,
                        s.Elementals[6].NumTurns);
                    target.Parry.Add (new State ("Parry", "PAR", s.Elementals[6].Potency,
                        0.0, s.Elementals[6].NumTurns, 0, false, ""));
                }
            }
        }

        //DARKNESS PROBABILITY
        if (s.Elementals[7].Probability > 0)
        {
            chance = exec.R.NextDouble () - dexMagChanceRatio;
            if (chance < s.Elementals[7].Probability)
            {

                createAnimationOnMap ("Darkness", ElementChannel, target.CentralPosition, 1f * s.Elementals[7].Potency, true);

                //DARKNESS MALICIOUS EFFECT

                if (s.Malicious)
                {

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("DARK- ({0}, {1})", new object[] { (s.Elementals[7].Potency), (s.Elementals[7].NumTurns) }), true);
                    }

                    if (!target.IsGuarding)
                    {
                        //double prob = exec.R.NextDouble ();
                        //if (prob < s.Elementals[7].Probability)
                        //{
                        output += string.Format ("{0} is shrouded with darkness!" + '\n', target.FirstName);
                        output += shiftHealth (target, -1 * target.Health.MeterLevel, true, null, s);
                        //}

                    }
                    else
                    {
                        output += shiftGuard (target, -5 * (s.Elementals[7].Potency), true, exec);

                    }

                    //DARKNESS BENEFICIAL EFFECT
                }
                else
                {

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("DARK+ ({0}, {1})", new object[] { (s.Elementals[7].Potency), (s.Elementals[7].NumTurns) }), true);
                    }

                    output += string.Format ("{0}'s resistance is augmented by {1} for {2} turns!" + '\n',
                        target.FirstName, s.Elementals[7].Potency, s.Elementals[7].NumTurns);
                    target.strength.addVariant (new State ("Resistance", "RES", s.Elementals[7].Potency, 0.0,
                        s.Elementals[7].NumTurns, 1, false, ""));
                    output += string.Format ("Resistance {0}" + '\n', target.Resistance);


                }
            }

        }

        //LIGHT PROBABILITY
        if (s.Elementals[8].Probability > 0)
        {
            chance = exec.R.NextDouble () - dexMagChanceRatio;
            if (chance < s.Elementals[8].Probability)
            {
                createAnimationOnMap ("Heal", ElementChannel, target.CentralPosition, 1f * s.Elementals[8].Potency, true);

                //LIGHT MALICIOUS (COURTESY OF FLO! DO NOT REMOVE, OR RISK DEATH) 
                if (s.Malicious)
                {

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("LIGHT- ({0}, {1})", new object[] { (s.Elementals[7].Potency), (s.Elementals[7].NumTurns) }), true);
                    }

                    if (!target.IsGuarding)
                    {
                        output += string.Format ("{0} is overwhelmed by the light!" + '\n', target.FirstName);
                        output += shiftHealth (target, -1 * s.Elementals[6].Potency, true, exec, s);

                        if (s.Properties.Contains ("DESTROYEVIL") && target.ElementalDefense[8] <= -10)
                        {
                            output += shiftHealth (target, target.Health.MeterMax * -1, true, exec, s);
                        }

                    }
                    else
                    {

                    }
                    //LIGHT BENEFICIAL
                }
                else
                {

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("LIGHT+ ({0}, {1})", new object[] { (s.Elementals[8].Potency), (s.Elementals[8].NumTurns) }), true);
                    }

                    output += string.Format ("{0} gains Regen for {1} turn (s)!" + '\n', target.FirstName, s.Elementals[8].NumTurns);
                    target.Regen.Add (new State ("Regen", "REG", s.Elementals[8].Potency,
                        0.0, s.Elementals[8].NumTurns, 0, false, ""));
                }
            }

        }

        //BREAK PROBABILITY
        if (s.Elementals[9].Probability > 0)
        {
            chance = exec.R.NextDouble () - dexMagChanceRatio;
            if (chance < s.Elementals[9].Probability)
            {
                if (!s.Malicious)
                {

                    if (!s.Properties.Contains (" NOSTAT "))
                    {
                        addToNotificationQueue (s, target, string.Format ("CRUSH- ({0}, {1})", new object[] { (s.Elementals[7].Potency), (s.Elementals[7].NumTurns) }), true);
                    }

                    output += string.Format ("{0}'s resistant to Breaking effects for {1} turns!" + '\n',
                        target.FirstName, s.Elementals[0].NumTurns);
                    target.StateResistances[12].BaseValue = (double)s.Elementals[9].Potency / 10;
                    target.StateResistances[12].Holder = s.Elementals[9].NumTurns;

                    target.StateResistances[13].BaseValue = s.Elementals[9].Potency / 10;
                    target.StateResistances[13].Holder = s.Elementals[9].NumTurns;

                }
            }
        }
        return output;
    }

    public void determineNotificationSoundAndColor (ref Player pl, ref string txt, ref Notification output)
    {
        output.Info.color = new Color (output.Info.color.r, output.Info.color.g, output.Info.color.b, 1);
        AudioSource src = new GameObject ().AddComponent<AudioSource>();
        src.gameObject.name = pl.FirstName + " determineNotificationSoundAndColor";

        src.volume = 1.0f;
        muteSound ();
        if (pl.StateActive (pl.Invisible))
        {
            output.Info.color = Color.clear;
        }
        else if (txt.Contains ("TURN BEGIN") || txt.Contains ("NEW ROUND") || txt.Contains ("BONUS ROUND"))
        {
            output.Timer = 1.2f;
        }
        else if (txt.Contains (" WALKING"))
        {
            output.Timer = 1.2f;
        }
        else if (txt.Contains (" EXECUTES ") || txt.Contains ("SKL "))
        {
            src.volume = 0.0f;
        }
        else if (txt.Contains (pl.FirstName.ToUpper () + " LDIFFL "))
        {
            output.Timer = 1.2f;
            output.Info.color = mintGreen;
        }
        else if (txt.Contains ("@_@"))
        {
            dizzySFX.Play ();
            src.clip = Resources.Load<AudioClip>(@"Sounds/announcer/dizzy");
            src.Play ();
        }
        else if (txt.Contains ("POISON (") || (txt.Contains (": POISON")))
        {
            output.Info.color = purple;
            pl.Vocals.Speech.clip = Resources.Load<AudioClip>(@"Sounds/players/" + pl.Sex + "damage");
            pl.Vocals.Speech.Play ();
        }
        else if (txt.Contains ("SLEEP (") || txt.Contains ("ZZZ"))
        {
            output.Info.color = Color.blue;
            if (txt.Contains ("SLEEP ("))
            {
                src.clip = Resources.Load<AudioClip>(@"Sounds/players/sleep");
                src.Play ();
            }
        }
        else if (txt.Contains ("WAKES UP"))
        {
            output.Info.color = Color.blue;
            src.clip = Resources.Load<AudioClip>(@"Sounds/players/yawn");
            src.Play ();
        }
        //PLAYER STATES
        //FIRE ELEMENTALS
        else if (txt.Contains ("STAGGER"))
        {
            src.clip = runSound;
            src.Play ();
        }
        else if (txt.Contains ("STAG "))
        {
            src.clip = stepSound;
            src.Play ();
        }
        else if (txt.Contains ("COUNTER ("))
        {
            output.Info.color = pl.Counter.StateColor; ;
            src.clip = parrySound;
            src.Play ();
        }
        else if (txt.Contains ("FREEZE (") || txt.Contains ("FROZEN"))
        {
            output.Info.color = pl.Freeze.StateColor;
            src.clip = Resources.Load<AudioClip>(@"Sounds/freeze");
            src.Play ();
        }
        else if (txt.Contains ("ADLE ("))
        {
            output.Info.color = pl.Adle.StateColor;
            src.clip = Resources.Load<AudioClip>(@"Sounds/adle");
            src.Play ();
        }
        else if (txt.Contains ("SADNESS ("))
        {
            output.Info.color = pl.Sadness.StateColor;
            src.clip = Resources.Load<AudioClip>(@"Sounds/adle");
            src.Play ();
        }
        else if (txt.Contains ("LEECH ("))
        {
            src.clip = Resources.Load<AudioClip>(@"Sounds/adle");
            src.Play ();
        }
        else if (txt.Contains ("INVULNERABLE ("))
        {
            output.Info.color = pl.Invulnerable.StateColor;
            src.clip = parrySound;
            src.Play ();
        }
        else if (txt.Contains ("IMMUNE ("))
        {
            output.Info.color = pl.Immune.StateColor;
            src.clip = benMagicSound;
            src.Play ();
        }
        else if (txt.Contains ("DAZE ("))
        {
            output.Info.color = pl.Daze.StateColor;
            src.clip = dizzySFX.clip;
            src.Play ();
        }
        else if (txt.Contains ("PARRY (") || txt.Contains ("PARRIES! ("))
        {
            output.Info.color = Color.cyan;
            src.clip = parrySound;
            src.Play ();
        }
        else if (txt.Contains ("REGEN ("))
        {
            output.Info.color = mintGreen;
            src.clip = benMagicSound;
            src.Play ();
        }
        else if (txt.Contains ("LEARN (")
                 || txt.Contains (" LEARNS "))
        {
            output.Info.color = darkBlue;
            src.clip = dingSound;
            src.Play ();
        }
        else if (txt.Contains ("BURN (")
          || txt.Contains ("FURY (")
                 || txt.Contains ("ABLAZE!"))
        {
            output.Info.color = orange;
            src.clip = fireSound;
            src.Play ();
        }
        else if (txt.Contains ("RELOAD ("))
        {

            //output.Info.color = orange;
            src.clip = reloadSound;
            src.Play ();

        }
        //STAT VARIATIONS
        else if (txt.EndsWith ("(RM)"))
        {
            output.Info.color = Color.red;
            if (!txt.Contains ("-"))
            {
                src.clip = punchSound;

            }
            else
            {
                src.clip = guardSound;

            }
            src.Play ();

        } //STAT VARIATIONS
        else if (txt.EndsWith ("(GM)"))
        {
            output.Info.color = darkBlue;
            if (!txt.Contains ("-"))
            {
                src.clip = guardSound;

            }
            else
            {
                src.clip = whiffSound;

            }
            src.Play ();

        } //STAT VARIATIONS
        else if (txt.EndsWith ("(VM)"))
        {
            output.Info.color = lightGreen;
            if (!txt.Contains ("-"))
            {
                src.clip = electricitySound;

            }
            else
            {
                src.clip = adleSound;

            }
            src.Play ();

        } //STAT VARIATIONS
        else if (txt.EndsWith ("HP GUARD"))
        {
            if (!txt.Contains ("-"))
            {
                output.Info.color = mintGreen;
                src.clip = guardSound;

            }
            else
            {
                output.Info.color = orange;
                src.clip = adleSound;

            }
            src.Play ();

        }
        else if (txt.EndsWith (" HP"))
        {
            if (!txt.Contains ("-"))
            {
                output.Info.color = Color.green;
                src.clip = punchSound;

            }
            else
            {
                output.Info.color = Color.red;
                src.clip = healSound;

            }
            src.Play ();

        }
        else if (txt.Contains (" COUNTDOWN "))
        {

            output.Info.color = mintGreen;
            src.clip = dingSound;
            src.Play ();

        }
        else if (txt.Contains (" DEPLETE "))
        {

            output.Info.color = purple;
            src.clip = stepSound;
            src.Play ();

        }//STAT VARIATIONS
        else if (txt.Contains ("STR (")
                   || txt.Contains ("GRT (")
                   || txt.Contains ("MAG (")
                   || txt.Contains ("RES (")
                   || txt.Contains ("SPD (")
                   || txt.Contains ("DEX (")
                   || txt.Contains ("PRO (")
                   || txt.Contains ("MOV (")
                   || txt.Contains ("TWK (")
                   || txt.Contains ("LCK ("))
        {

            if (txt.Contains ("(-") || txt.Contains ("(0"))
            {
                output.Info.color = Color.red;
                src.clip = Resources.Load<AudioClip>(@"Sounds/adle");
            }
            else
            {
                output.Info.color = mintGreen;
                src.clip = Resources.Load<AudioClip>(@"Sounds/bless");
            }
            src.Play ();
        }
        //FIRE ELEMENTALS
        else if (txt.Contains ("FIRE+ ")
                  || txt.Contains ("FIRE- "))
        {

            output.Info.color = orange;
            src.clip = fireSound;
            src.Play ();

        }
        else if (txt.Contains ("ICE+ ")
                || txt.Contains ("ICE- "))
        {

            output.Info.color = ice;
            src.clip = iceSound;
            src.Play ();

        }
        else if (txt.Contains ("ELECTRICITY+ ")
                || txt.Contains ("ELECTRICITY- "))
        {

            output.Info.color = electricity;
            src.clip = electricitySound;
            src.Play ();

        }
        else if (txt.Contains ("AIR+ ")
                || txt.Contains ("AIR- "))
        {

            output.Info.color = wind;
            src.clip = windSound;
            src.Play ();

        }
        else if (txt.Contains ("EARTH+ ")
                || txt.Contains ("EARTH- "))
        {

            output.Info.color = earth;
            src.clip = earthSound;
            src.Play ();

        }
        else if (txt.Contains ("WATER+ ")
                || txt.Contains ("WATER- "))
        {

            output.Info.color = water;
            src.clip = waterSound;
            src.Play ();

        }
        else if (txt.Contains ("METAL+ ")
                || txt.Contains ("METAL- "))
        {

            output.Info.color = metal;
            src.clip = metalSound;
            src.Play ();

        }
        else if (txt.Contains ("DARK+ ")
                || txt.Contains ("DARK- "))
        {

            output.Info.color = Color.black;
            src.clip = darknessSound;
            //src.clip = Resources.Load<AudioClip> (@"Sounds/curse");
            src.Play ();

        }
        else if (txt.Contains ("LIGHT+ ")
                || txt.Contains ("LIGHT- "))
        {

            output.Info.color = Color.white;
            src.clip = lightSound;
            //src.clip = Resources.Load<AudioClip> (@"Sounds/curse");
            src.Play ();

        }
        else if (txt.Contains ("CRUSH+ ")
                || txt.Contains ("CRUSH- "))
        {

            output.Info.color = Color.red;
            src.clip = crushSound;
            //src.clip = Resources.Load<AudioClip> (@"Sounds/curse");
            src.Play ();

        }
        else if (txt.Contains (" REC "))
        {

            output.Info.color = fire;
            src.clip = gaspSound;
            //src.clip = Resources.Load<AudioClip> (@"Sounds/curse");
            src.Play ();

        }
        else if (txt.Contains (" RECOVERS!"))
        {
            output.Info.color = snowBlue;
            src.clip = cheerSound;
            //src.clip = Resources.Load<AudioClip> (@"Sounds/curse");
            src.Play ();

        }
        else if (txt.Contains ("COUNTER")
          || txt.Contains ("CRUSHED")
          || txt.Contains ("HARDENED"))
        {
            output.Info.color = Color.gray;
            src.clip = Resources.Load<AudioClip>(@"Sounds/metal");
            src.Play ();
        }
        else if (txt.Contains ("INDIFFERENT") || txt.Contains ("GRATEFUL") || txt.Contains ("ELATED"))
        {

        }
        else if (txt.Contains ("WIRE HIT"))
        {
            src.clip = Resources.Load<AudioClip>(@"Sounds/fall");
            src.Play ();
        }
        else if (txt.Contains ("KNOCKED OUT!"))
        {

            pl.Vocals.Speech.clip = Resources.Load<AudioClip>(@"Sounds/players/" + pl.Sex + "ko");
            pl.Vocals.Speech.Play ();
            if (!finalRound)
            {
                announce ("ko");
            }
        }
        else if (txt.Contains ("WHIFF") || txt.Contains (" DODGE!"))
        {
            output.Info.color = Color.gray;
            src.clip = whiffSound;
            src.Play ();
        }
        else if (txt.Contains ("-") && (txt.EndsWith ("HP GUARD") || txt.EndsWith ("GM")))
        {
            output.Info.color = ice;
            src.clip = guardSound;
            src.Play ();
        }
        else if (txt.Contains ("SHOCKED"))
        {
            output.Info.color = new Color (0f, 0f, 0f, 0f);
            src.clip = Resources.Load<AudioClip>(@"Sounds/shock");
            src.Play ();
        }
        else if (txt.Contains ("OVERWHELMED") || txt.Contains ("BLESSED"))
        {
            output.Info.color = Color.white;
            src.clip = Resources.Load<AudioClip>(@"Sounds/bless");
            src.Play ();
        }
        else if (txt.Contains ("CURSED") || txt.Contains ("SHROUDED"))
        {
            output.Info.color = lightPurple;
            src.clip = Resources.Load<AudioClip>(@"Sounds/curse");
            src.Play ();
        }
        else if (txt.Contains ("@_@"))
        {
            output.Info.color = purple;
        }
        else if (txt.Contains ("LAST STAND") || txt.Contains ("POWERED UP"))
        {
            output.Info.color = lightPurple;
            src.clip = Resources.Load<AudioClip>(@"Sounds/laststand");
            src.Play ();
        }
        else if (txt.EndsWith ("CRITICAL HIT!") || txt.Contains ("RECOVERY DAMAGE")
          || txt.Contains ("RESTING PENALTY") || txt.Contains ("TAUNTING PENALTY"))
        {
            //delay = 0.8f;
            src.clip = criticalSound;
            src.Play ();

        }
        else if (txt.Contains ("-") && txt.Contains ("HP"))
        {
            pl.Vocals.Speech.clip = Resources.Load<AudioClip>(@"Sounds/players/" + pl.Sex + "damage");
            pl.Vocals.Speech.Play ();
            src.clip = punchSound;
            src.Play ();
        }
        else if (txt.Contains ("+")
          && (txt.EndsWith ("HP")
              || txt.EndsWith ("RM")
              || txt.EndsWith ("GM")
              || txt.EndsWith ("VM")))
        {
            output.Info.color = mintGreen;
            src.clip = healSound;
            src.Play ();
        }
        else if (txt.Contains ("-")
          && (txt.EndsWith ("HP")
              || txt.EndsWith ("RM")
              || txt.EndsWith ("GM")
              || txt.EndsWith ("VM")))
        {
            output.Info.color = Color.red;
            src.clip = punchSound;
            src.Play ();
        }
        else if (txt.EndsWith ("+"))
        {
            output.Info.color = Color.white;
            src.clip = Resources.Load<AudioClip>(@"Sounds/bless");
            src.Play ();
        }
        else if (txt.EndsWith ("-"))
        {
            output.Info.color = lightPurple;
            src.clip = Resources.Load<AudioClip>(@"Sounds/curse");
            src.Play ();
        }
        else if (txt.Contains (" GROUNDED: ")
          || txt.Contains (" AIRBORNE: ")
          || txt.Contains (" RECOVERY: ")
          || txt.Contains (" STUN: ")
          || txt.Contains (" GSTUN: ")
          || txt.Contains (" RECOVERS.")
          || txt.Contains (" LANDS.")
          || txt.Contains (" STANDS."))
        {
            output.Timer = 0.8f;
            if (txt.Contains ("AIRBORNE"))
            {
                src.clip = Resources.Load<AudioClip>(@"Sounds/whoosh");
                src.Play ();
            }
            else if (txt.Contains ("RECOVERY"))
            {
                if (pl.Sex.Equals ("Male"))
                {
                    src.clip = Resources.Load<AudioClip>(@"Sounds/players/malebreathe");
                }
                else if (pl.Sex.Equals ("Female"))
                {
                    src.clip = Resources.Load<AudioClip>(@"Sounds/players/femalebreathe");
                }
            }
            else if (txt.EndsWith ("RECOVERS"))
            {
                if (pl.Sex.Equals ("Male"))
                {
                    src.clip = Resources.Load<AudioClip>(@"Sounds/players/malebreathe");
                }
                else if (pl.Sex.Equals ("Female"))
                {
                    src.clip = Resources.Load<AudioClip>(@"Sounds/players/femalebreathe");
                }
            }
            else if (txt.Contains (" LANDS.") || txt.Contains (" STANDS."))
            {
                src.clip = stepSound;
                src.Play ();
            }

        }
        else if (txt.EndsWith ("CROUCH"))
        {
            src.clip = stepSound;//Resources.Load <AudioClip> (@"Sounds/walk");
            src.Play ();
        }
        else if (txt.EndsWith ("FALL!"))
        {
            src.clip = crashSound;//Resources.Load <AudioClip> (@"Sounds/fall");
            src.Play ();

        }
        else if (txt.EndsWith ("HP CRITICAL!"))
        {
            src.clip = Resources.Load<AudioClip>(@"Sounds/heartbeat");
            src.Play ();

        }
        else if (txt.EndsWith ("CRASH!"))
        {
            src.Play ();
        }
        else
        {
            src.clip = parrySound;//
            src.Play ();
        }
        soundQueue.Add (src);
    }

    //AUGMENT STATS
    private string statAugments (Player exec, Skill s, Player target, double decay)
    {
        string output = "";
        double chance = 0;

        if (s.Type.Equals ("BUFF") || s.Type.Equals ("BOOST"))
        {
            createAnimationOnMap ("Buff", StatChannel, target.CentralPosition, 2f, false);
        }
        if (s.Type.Equals ("NERF") || s.Type.Equals ("CURSE"))
        {
            createAnimationOnMap ("Nerf", StatChannel, target.CentralPosition, 2f, false);
        }
        else if (s.Type.Equals ("STATE") || s.Type.Equals ("TRANSFORM"))
        {
            createAnimationOnMap ("Shock", StatChannel, target.CentralPosition, 2f, false);
        }

        //STRENGTH
        if (s.StatAlterations[0].Probability > 0)
        {
            chance = exec.R.NextDouble ();
            if (s.StatAlterations[0].Probability > 0)
            {

                chance -= exec.Dexterity / 100;
                chance -= ((double)exec.Luck) / 800;


                if (s.Malicious)
                {
                    chance += target.Dexterity / 100;
                    chance += ((double)target.Luck) / 800;
                    chance -= ((double)target.ResidualFatigue) / 100;
                }

                if (chance < 0)
                {
                    chance = 0;
                }
            }

            if (chance < s.StatAlterations[0].Probability)
            {

                addToNotificationQueue (s, target, string.Format ("{0} ({1}, {2})", new object[] { s.StatAlterations[0].Abbreviation.ToUpper (), s.StatAlterations[0].Potency, s.StatAlterations[0].NumTurns }), true);

                target.strength.addVariant (s.StatAlterations[0]);
                output += string.Format ("{0}'s strength is augmented by {1} for {2} turns!" + '\n',
                    target.FirstName, (int)(s.StatAlterations[0].Potency * decay), s.StatAlterations[0].NumTurns);
                output += string.Format ("Strength {0}" + '\n', target.Strength);

            }
        }

        //GRIT
        if (s.StatAlterations[1].Probability > 0)
        {
            chance = exec.R.NextDouble ();
            if (s.StatAlterations[1].Probability > 0)
            {

                chance -= exec.Dexterity / 100;
                chance -= ((double)exec.Luck) / 800;


                if (s.Malicious)
                {
                    chance += target.Dexterity / 100;
                    chance += ((double)target.Luck) / 800;
                    chance -= ((double)target.ResidualFatigue) / 100;
                }

                if (chance < 0)
                {
                    chance = 0;
                }
            }

            if (chance < s.StatAlterations[1].Probability)
            {

                addToNotificationQueue (s, target, string.Format ("{0} ({1}, {2})", new object[] { s.StatAlterations[1].Abbreviation.ToUpper (), s.StatAlterations[1].Potency, s.StatAlterations[1].NumTurns }), true);

                target.grit.addVariant (s.StatAlterations[1]);
                output += string.Format ("{0}'s grit is augmented by {1} for {2} turns!" + '\n',
                    target.FirstName, (int)(s.StatAlterations[1].Potency * decay), s.StatAlterations[1].NumTurns);
                output += string.Format ("Grit {0}" + '\n', target.Grit);
            }
        }

        //MAGICK
        if (s.StatAlterations[2].Probability > 0)
        {
            chance = exec.R.NextDouble ();
            if (s.StatAlterations[2].Probability > 0)
            {

                chance -= exec.Dexterity / 100;
                chance -= ((double)exec.Luck) / 800;


                if (s.Malicious)
                {
                    chance += target.Dexterity / 100;
                    chance += ((double)target.Luck) / 800;
                    chance -= ((double)target.ResidualFatigue) / 100;
                }

                if (chance < 0)
                {
                    chance = 0;
                }
            }

            if (chance < s.StatAlterations[2].Probability)
            {

                addToNotificationQueue (s, target, string.Format ("{0} ({1}, {2})", new object[] { s.StatAlterations[2].Abbreviation.ToUpper (), s.StatAlterations[2].Potency, s.StatAlterations[2].NumTurns }), true);

                target.magick.addVariant (s.StatAlterations[2]);
                output += string.Format ("{0}'s magick is augmented by {1} for {2} turns!" + '\n',
                    target.FirstName, (int)(s.StatAlterations[2].Potency * decay), s.StatAlterations[2].NumTurns);
                output += string.Format ("Magick {0}" + '\n', target.Magick);
            }
        }

        //RESISTANCE
        if (s.StatAlterations[3].Probability > 0)
        {
            chance = exec.R.NextDouble ();
            if (s.StatAlterations[3].Probability > 0)
            {

                chance -= exec.Dexterity / 100;
                chance -= ((double)exec.Luck) / 800;


                if (s.Malicious)
                {
                    chance += target.Dexterity / 100;
                    chance += ((double)target.Luck) / 800;
                    chance -= ((double)target.ResidualFatigue) / 100;
                    //chance += target.Dexterity / 100;
                    //chance += ((double)target.Luck) / 800;
                }

                if (chance < 0)
                {
                    chance = 0;
                }
            }

            if (chance < s.StatAlterations[3].Probability)
            {

                addToNotificationQueue (s, target, string.Format ("{0} ({1}, {2})", new object[] { s.StatAlterations[3].Abbreviation.ToUpper (), s.StatAlterations[3].Potency, s.StatAlterations[3].NumTurns }), true);

                target.resistance.addVariant (s.StatAlterations[3]);
                output += string.Format ("{0}'s resistance is augmented by {1} for {2} turns!" + '\n',
                    target.FirstName, (int)(s.StatAlterations[3].Potency * decay), s.StatAlterations[3].NumTurns);
                output += string.Format ("Resistance {0}" + '\n', target.Resistance);
            }
        }

        //DEXTERITY
        if (s.StatAlterations[4].Probability > 0)
        {
            chance = exec.R.NextDouble ();
            if (s.StatAlterations[4].Probability > 0)
            {

                chance -= exec.Dexterity / 100;
                chance -= ((double)exec.Luck) / 800;


                if (s.Malicious)
                {
                    chance += target.Dexterity / 100;
                    chance += ((double)target.Luck) / 800;
                    chance -= ((double)target.ResidualFatigue) / 100;
                }

                if (chance < 0)
                {
                    chance = 0;
                }
            }

            if (chance < s.StatAlterations[4].Probability)
            {

                addToNotificationQueue (s, target, string.Format ("{0} ({1}, {2})", new object[] { s.StatAlterations[4].Abbreviation.ToUpper (), s.StatAlterations[4].Potency, s.StatAlterations[4].NumTurns }), true);

                target.dexterity.addVariant (s.StatAlterations[4]);
                output += string.Format ("{0}'s dexterity is augmented by {1} for {2} turns!" + '\n',
                    target.FirstName, s.StatAlterations[4].DoublePotency * decay, s.StatAlterations[4].NumTurns);
                output += string.Format ("Dexterity {0}" + '\n', target.Dexterity);
            }
        }

        //SPEED
        if (s.StatAlterations[5].Probability > 0)
        {
            chance = exec.R.NextDouble ();
            if (s.StatAlterations[5].Probability > 0)
            {

                chance -= exec.Dexterity / 100;
                chance -= ((double)exec.Luck) / 800;


                if (s.Malicious)
                {
                    chance += target.Dexterity / 100;
                    chance += ((double)target.Luck) / 800;
                    chance -= ((double)target.ResidualFatigue) / 100;
                }

                if (chance < 0)
                {
                    chance = 0;
                }
            }

            if (chance < s.StatAlterations[5].Probability)
            {

                addToNotificationQueue (s, target, string.Format ("{0} ({1}, {2})", new object[] { s.StatAlterations[5].Abbreviation.ToUpper (), s.StatAlterations[5].Potency, s.StatAlterations[5].NumTurns }), true);

                target.speed.addVariant (s.StatAlterations[5]);
                output += string.Format ("{0}'s speed is augmented by {1} for {2} turns!" + '\n',
                    target.FirstName, s.StatAlterations[5].DoublePotency * decay, s.StatAlterations[5].NumTurns);
                output += string.Format ("Speed {0}" + '\n', target.Speed);
            }
        }

        //PRORATION
        if (s.StatAlterations[6].Probability > 0)
        {
            chance = exec.R.NextDouble ();
            if (s.StatAlterations[6].Probability > 0)
            {

                chance -= exec.Dexterity / 100;
                chance -= ((double)exec.Luck) / 800;


                if (s.Malicious)
                {
                    chance += target.Dexterity / 100;
                    chance += ((double)target.Luck) / 800;
                    chance -= ((double)target.ResidualFatigue) / 100;
                }

                if (chance < 0)
                {
                    chance = 0;
                }
            }

            if (chance < s.StatAlterations[6].Probability)
            {

                addToNotificationQueue (s, target, string.Format ("{0} ({1}, {2})", new object[] { s.StatAlterations[6].Abbreviation.ToUpper (), s.StatAlterations[6].Potency, s.StatAlterations[6].NumTurns }), true);

                target.proration.addVariant (s.StatAlterations[6]);
                output += string.Format ("{0}'s proration is augmented by {1} for {2} turns!" + '\n',
                    target.FirstName, s.StatAlterations[6].DoublePotency * decay, s.StatAlterations[6].NumTurns);
                output += string.Format ("Proration {0}%" + '\n', (int)(100 * target.Proration));
            }
        }

        //MOVEMENT
        if (s.StatAlterations[7].Probability > 0)
        {
            chance = exec.R.NextDouble ();
            if (s.StatAlterations[7].Probability > 0)
            {

                chance -= exec.Dexterity / 100;
                chance -= ((double)exec.Luck) / 800;


                if (s.Malicious)
                {
                    chance += target.Dexterity / 100;
                    chance += ((double)target.Luck) / 800;
                    chance -= ((double)target.ResidualFatigue) / 100;
                }

                if (chance < 0)
                {
                    chance = 0;
                }
            }

            if (chance < s.StatAlterations[7].Probability)
            {

                addToNotificationQueue (s, target, string.Format ("{0} ({1}, {2})", new object[] { s.StatAlterations[7].Abbreviation.ToUpper (), s.StatAlterations[7].Potency, s.StatAlterations[7].NumTurns }), true);

                target.movement.addVariant (s.StatAlterations[7]);
                output += string.Format ("{0}'s movement is augmented by {1} for {2} turns!" + '\n',
                    target.FirstName, (int)(s.StatAlterations[7].Potency * decay), s.StatAlterations[7].NumTurns);
                output += string.Format ("Movement {0}" + '\n', target.Movement);
            }
        }

        //TEAMWORK
        if (s.StatAlterations[8].Probability > 0)
        {
            chance = exec.R.NextDouble ();
            if (s.StatAlterations[8].Probability > 0)
            {

                chance -= exec.Dexterity / 100;
                chance -= ((double)exec.Luck) / 800;


                if (s.Malicious)
                {
                    chance += target.Dexterity / 100;
                    chance += ((double)target.Luck) / 800;
                    chance -= ((double)target.ResidualFatigue) / 100;
                }

                if (chance < 0)
                {
                    chance = 0;
                }
            }

            if (chance < s.StatAlterations[8].Probability)
            {

                addToNotificationQueue (s, target, string.Format ("{0} ({1}, {2})", new object[] { s.StatAlterations[8].Abbreviation.ToUpper (), s.StatAlterations[8].Potency, s.StatAlterations[8].NumTurns }), true);

                target.teamwork.addVariant (s.StatAlterations[8]);
                output += string.Format ("{0}'s teamwork is augmented by {1} for {2} turns!" + '\n',
                    target.FirstName, (int)(s.StatAlterations[8].Potency * decay), s.StatAlterations[8].NumTurns);
                output += string.Format ("Teamwork {0}" + '\n', target.Teamwork);
            }
        }

        //LUCK
        if (s.StatAlterations[9].Probability > 0)
        {
            chance = exec.R.NextDouble ();
            if (s.StatAlterations[9].Probability > 0)
            {

                chance -= exec.Dexterity / 100;
                chance -= ((double)exec.Luck) / 800;


                if (s.Malicious)
                {
                    chance += target.Dexterity / 100;
                    chance += ((double)target.Luck) / 800;
                    chance -= ((double)target.ResidualFatigue) / 100;
                }

                if (chance < 0)
                {
                    chance = 0;
                }
            }

            if (chance < s.StatAlterations[9].Probability)
            {

                addToNotificationQueue (s, target, string.Format ("{0} ({1}, {2})", new object[] { s.StatAlterations[9].Abbreviation.ToUpper (), s.StatAlterations[9].Potency, s.StatAlterations[9].NumTurns }), true);

                target.luck.addVariant (s.StatAlterations[9]);
                output += string.Format ("{0}'s luck is augmented by {1} for {2} turns!" + '\n',
                    target.FirstName, (int)(s.StatAlterations[9].Potency * decay), s.StatAlterations[9].NumTurns);
                output += string.Format ("Luck {0}" + '\n', target.Luck);
            }
        }
        return output;
    }

    private Boolean listContains (ArrayList s, string nm)
    {
        for (int i = 0; i < s.Count; i++)
        {
            if (((State)s[i]).Name.Equals (nm))
            {
                return true;
            }
        }
        return false;
    }

    //AUGMENT STATES
    private string stateAugments (Player exec, Skill s, Player target, double decay)
    {
        string output = "";
        double minimumChance = 1;

        if (s.Properties.Contains ("CROUCH") && !target.StateActive (target.Sleep))
        {
            string ech = target.Grounded.ClearStates;
            if (s.Malicious)
            {
                output += string.Format ("{0} falls to knees!" + '\n', target.FirstName);
            }
            else
            {
                output += string.Format ("{0} crouches." + '\n', target.FirstName);
            }
            if (!target.IsCrouching)
            {
                target.IsCrouching = true;
            }
        }

        if (s.Properties.Contains ("ENDTURN"))
        {
            target.CanAct = false;
            target.MovesRemaining = 0;
        }

        if (s.Properties.Contains ("LVLUP"))
        {
            int lvl = NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ("LVLUP") + 5, 3));

            for (int i = 0; i < lvl; i++)
            {
                output += levelUp (target, false);
            }
        }

        if (s.Properties.Contains (" GND "))
        {
            string ech = target.Airborne.ClearStates;
            ech = target.Grounded.ClearStates;
        }

        if (s.Properties.Contains ("VGUARD"))
        {
            output += exec.AutoGuardStanceSpecial;
            createAnimationOnMap ("Defend", StateChannel, target.CentralPosition, 3f, true);
        }

        State st = null;
        if (s.Properties.Contains ("BLOODPRICE•"))
        {
            st = new State ("BLOOD", "", 0, 0, NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('•') + 1, 3)), 0, false, "activates Blood Price!");
            target.TimedConditions.Add (st);
            createAnimationOnMap ("Blood", StateChannel, target.CentralPosition, st.Potency * 1f, false);
            target.BloodPrice = true;
        }


        if (s.Properties.Contains ("BERSERK§"))
        {
            st = new State ("BERSERK", "", 0, 0, NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('•') + 1, 3)), 0, false, "goes berserk!");
            target.TimedConditions.Add (st);
            createAnimationOnMap ("Berserk", StateChannel, target.CentralPosition, st.Potency * 1f, false);
            target.Berserk = true;
        }

        if (s.Properties.Contains ("UNDEAD§") && !target.Undead)
        {
            st = new State ("UNDEAD", "", 0, 0, NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('•') + 1, 3)), 0, false, "enters zombie mode!");
            target.TimedConditions.Add (st);
            createAnimationOnMap ("Berserk", StateChannel, target.CentralPosition, st.Potency * 1f, false);
            target.Undead = true;
        }

        if (s.Properties.Contains ("FLIGHT¡"))
        {
            st = new State ("FLIGHT", "", 0, 0, NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('¡') + 1, 3)), 0, false, "enters flight!");
            target.TimedConditions.Add (st);
            createAnimationOnMap ("Flight", StateChannel, target.CentralPosition, st.Potency * 1f, false);
            target.Flight = true;
        }

        if (s.Properties.Contains ("TMFRZ"))
        {
            st = new State ("TMFRZ", "", 0, 0, NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('º') + 1, 3)), 0, false, "stops time!");
            createAnimationOnMap ("Time", StateChannel, target.CentralPosition, st.Potency * 1f, false);
            if (!listContains (exec.TimedConditions, "TMFRZ"))
            {
                exec.TimedConditions.Add (st);
                if (target.Vocals.ContactSound.volume > 0.0f)
                {
                    target.Vocals.ContactSound.volume = 0.7f;
                }
                target.Vocals.ContactSound.clip = burstSound;
                target.Vocals.ContactSound.Play ();
                bgm.Pause ();
                ambience.Pause ();
            }
            exec.TimeStopped = true;
        }

        if (s.Properties.Contains ("LASTSTAND"))
        {
            st = new State ("LAST STAND", "ST", 0, 0, NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('º') + 1, 3)), 0, false, "enters a special state!");
            createAnimationOnMap ("HPCritical", LimitChannel, target.CentralPosition, st.Potency * 1f, false);
            battleMap.ActiveTime += NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('º') + 1, 3));
            target.TimedConditions.Add (st);
            target.LastStand = true;
        }

        if (s.Properties.Contains (" LCH"))
        {
            st = new State ("LEECH", "LCH", 0, 0, NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('˚') + 1, 3)), 0, false, "enters a special state!");
            createAnimationOnMap ("Contact", LimitChannel, target.CentralPosition, st.Potency * 1f, false);
            target.TimedConditions.Add (st);
            target.Leech = true;
        }

        if (s.Properties.Contains (" CTST"))
        {
            st = new State ("COUNTER", "CTR", 0, 0, NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('˚') + 1, 3)), 0, false, "enters a counter state!");
            createAnimationOnMap ("Contact", LimitChannel, target.CentralPosition, st.Potency * 1f, false);
            target.TimedConditions.Add (st);
            target.CounterState = true;
        }


        if (s.Properties.Contains ("S-STATE"))
        {
            //TMCH
            battleMap.ActiveTime += NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('º') + 1, 3));
            st = new State ("X-STATE", "ST", 0, 0, NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('º') + 1, 3)), 0, false, "enters a special state!");
            createAnimationOnMap ("Shock", StateChannel, target.CentralPosition, st.Potency * 1f, false);
            target.TimedConditions.Add (st);
            target.SpecialState = true;
        }


        if (s.Properties.Contains ("HITSTUN") && s.Properties.Contains ("§"))
        {
            int hitStunAdj = NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('§') - 3, 3));
            target.HitStunAdjustment = hitStunAdj;
            new DataReader ().calibrateLinks (target, true);

            st = new State ("HITSTUN-" + hitStunAdj, "ST", 0, 0, NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('§') + 1, 3)), 0, false, " Hit Stun properties have changed!");
            target.TimedConditions.Add (st);
        }

        if (s.Properties.Contains ("NOCONDITIONS•"))
        {
            st = new State ("NOCONDITIONS", "", 0, 0, NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('•') + 1, 3)), 0, false, "breaks ability limits!");
            createAnimationOnMap ("Contact", StateChannel, target.CentralPosition, st.Potency * 1f, false);
            battleMap.ActiveTime += NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('•') + 1, 3));
            target.TimedConditions.Add (st);
            target.NoConditions = true;
        }

        if (s.Properties.Contains ("HALFCOST•"))
        {
            st = new State ("HALFCOST", "", 0, 0, NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('•') + 1, 3)), 0, false, "costs are halved!");
            target.TimedConditions.Add (st);
            target.HalfCost = true;
            target.CounterState = false;
        }

        if (s.Properties.Contains ("NOCOST•"))
        {
            st = new State ("NOCOST", "", 0, 0, NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('•') + 1, 3)), 0, false, "costs are nullified!");
            target.TimedConditions.Add (st);
            target.NoCost = true;
            target.CounterState = false;
        }

        if (s.Properties.Contains ("DISABLERM"))
        {
            if (s.Properties.Contains ("DISABLERM:"))
            {

            }
            else
            {
                target.Rush.CanBeUsed = false;
            }
        }

        if (s.Properties.Contains ("DISABLEGM"))
        {
            if (s.Properties.Contains ("DISABLEGM:"))
            {

            }
            else
            {
                target.Guard.CanBeUsed = false;
            }
        }

        if (s.Properties.Contains ("DISABLEVM"))
        {
            if (s.Properties.Contains ("DISABLEVM:"))
            {

            }
            else
            {
                target.Vitality.CanBeUsed = false;
            }
        }

        if (st != null)
        {
            output += string.Format ("{0} {1}" + '\n', target.FirstName, st.Phrase);
        }

        if (s.Properties.Contains ("ENST "))
        {
            for (int i = 0; i < exec.TimedConditions.Count; i++)
            {
                st = (State)exec.TimedConditions[i];


                if (st.Name.StartsWith ("X-STATE") || st.Name.Contains ("HALFCOST") || st.Name.Contains ("NOCOST"))
                {
                    Skill sk;
                    output += string.Format ("Special State ends!" + '\n');
                    for (int j = 0; j < exec.AllSkills.Count; j++)
                    {
                        sk = (Skill)exec.AllSkills[j];
                        if (sk.Properties.Contains (" S-ST ") && exec.forget (sk))
                        {
                            output += string.Format ("{0} is forgotten!" + '\n', sk.Name);
                        }
                    }
                    exec.SpecialState = false;
                    exec.HalfCost = false;
                    exec.NoCost = false;
                    exec.TimedConditions.Remove (exec.TimedConditions[i]);
                    i--;
                }
            }
        }

        double chance = exec.R.NextDouble ();

        if (!s.Malicious || !target.StateActive (target.Invulnerable))
        {

            if (!target.StateActive (target.Sadness) && s.StateAlterations[0].Probability > 0)
            {
                chance += (target.States[0].Probability + target.StateResistances[0].BaseValue);
                if (((!target.IsDizzied && !target.WasDizzied) || !s.Malicious) && chance <= s.StateAlterations[0].Probability)
                {

                    //STUN SHIFT
                    if (((int)Math.Abs (s.StateAlterations[0].Potency * decay)) > 0)
                    {
                        int stunShift = (int)(s.StateAlterations[0].Potency * decay);
                        if (target.PlayStyle.Equals ("C"))
                        {
                            stunShift = (int)(stunShift * 0.8f);
                        }

                        output += shiftStun (target, stunShift + ((stunShift * target.Potency (target.Daze)) / 3), true, exec);
                        output += string.Format ("---" + '\n');
                    }
                }
            }

            //ENDING GROUNDED STATE
            if (s.Properties.Contains ("GROUNDOFF") && target.StateActive (target.Grounded))
            {
                target.Grounded.Potency = 0;
                target.Grounded.NumTurns = 0;
                target.Grounded.Probability = 0.0;
            }

            //GROUNDED STATE
            if (s.StateAlterations[1].Probability > 0
                && (!target.StateActive (target.Counter) || s.Grapple)
                && !target.StateActive (target.Grounded)
                && (!s.Properties.Contains ("AIRKD") || target.StateActive (target.Airborne))
                && !s.Properties.Contains ("WALLFALL"))
            {
                chance = exec.R.NextDouble () + (target.States[1].Probability + target.StateResistances[1].BaseValue);
                if (chance <= s.StateAlterations[1].Probability && !exec.counterJuggle (s, target))
                {


                    if (target.StateActive (target.Airborne))
                    {

                        if (exec.FallingHeight > 10)
                        {
                            output += string.Format ("{0} crashes into the ground! ", exec.FirstName);
                            output += "" + '\n' + shiftHealth (exec, (-10 + (exec.Grit / 20)) * exec.FallingHeight, true, null, s);
                            createAnimationOnMap ("Earth", EnvironmentChannel, target.CentralPosition, 2f, true);
                        }
                    }

                    target.SetHeight (0);
                    target.FallingHeight = 0;

                    if (s.StateAlterations[1].Potency == target.Potency (target.Grounded))
                    {
                        if (s.Malicious)
                        {

                            if (s.StateAlterations[1].Potency < 10)
                            {
                                output += string.Format ("{0} is knocked down!" + '\n', target.FirstName);
                                createAnimationOnMap ("Earth", EnvironmentChannel, target.CentralPosition, 2f, true);
                            }
                            else
                            {
                                output += string.Format ("{0} crashes into the ground!" + '\n', target.FirstName);
                                createAnimationOnMap ("Earth", EnvironmentChannel, target.CentralPosition, 2f, true);
                            }

                        }
                        else
                        {
                            output += string.Format ("{0} crawls down." + '\n', target.FirstName);
                        }
                    }

                    target.IsCrouching = false;
                    target.States[1].Potency += s.StateAlterations[1].Potency;
                    output += "Grounded " + target.Potency (target.States[1]) + '\n';
                }
            }

            //COUNTER STATE
            if (s.Properties.Contains ("CTRFREE") && (exec.CounterState || target.ResidualFatigue > 0 || target.Fatigue > 0))
            {
                createAnimationOnMap ("HitPhysical", HitChannel, target.CentralPosition, 2f, true);
                exec.HasJumped = false;
                output += exec.setAction (true);
                exec.HasActed = true;
            }

            //ENDING AIRBORNE STATE
            if ((s.Properties.Contains ("AIROFF") || s.Properties.Contains ("STANDONLY")) && target.StateActive (target.Airborne) && (!s.Properties.Contains ("CTRFREE") || target.ResidualFatigue > 0))
            {
                if (!target.IsDizzied)
                {
                    target.WasHit = false;
                    target.InRecovery = true;
                    target.AirOff = true;
                }
                else
                {
                    target.Grounded.Potency = 10;
                    target.Grounded.NumTurns = 10;
                    if (s.Malicious)
                    {
                        target.WasHit = true;
                    }
                    target.AirOff = false;
                }
            }
            else
            {
                target.AirOff = false;
            }

            //AIRBORNE STATE
            if (s.StateAlterations[2].Probability > 0
                && ((!s.Properties.Contains ("CTRAIR ") || target.ResidualFatigue > 0 || target.Fatigue > 0)
                    && (((s.StateAlterations[1].Potency == 0 && !s.Properties.Contains ("AIROFF "))
                        || (target.ResidualFatigue > 0 || target.Fatigue > 0)))) && (!target.StateActive (target.Counter) || s.Grapple)
                && (!s.Properties.Contains ("AIRJGL") || target.StateActive (target.Airborne))
                && (!s.Properties.Contains ("STANDJGL") || !target.StateActive (target.Grounded)))
            {
                chance = exec.R.NextDouble () + (target.States[2].Probability + target.StateResistances[2].BaseValue);
                if (chance <= s.StateAlterations[2].Probability)
                {

                    if (target.Potency (target.Airborne) == 0)
                    {
                        if (s.Malicious)
                        {
                            if (s.StateAlterations[2].Potency < 10)
                            {
                                output += string.Format ("{0} is knocked into the air!" + '\n', target.FirstName);
                            }
                            else
                            {
                                output += string.Format ("{0} goes flying into the air!" + '\n', target.FirstName);
                            }
                        }
                        else
                        {
                            output += string.Format ("{0} flies into the air!" + '\n', target.FirstName);
                        }
                    }
                    target.IsCrouching = false;
                    target.Grounded.Potency = 0;

                    target.Airborne.Potency += s.StateAlterations[2].Potency;
                    if (s.Properties.Contains (" FOLLOW ") && target.Potency (target.Airborne) > 0)
                    {
                        exec.SetHeight (target.Potency (target.Airborne));
                    }


                    if (target.Potency (target.Airborne) < 0)
                    {
                        target.SetHeight (0);
                    }

                    target.FallingHeight = target.Potency (target.Airborne)
                        //- currentMap ().heightOf (target.currentLocation ());
                        + (target.UnitHeight - battleMap.heightOf (target.currentLocation ()));
                    if (target.FallingHeight < 0)
                    {
                        target.FallingHeight = 0;
                    }
                    target.UnitHeight = battleMap.heightOf (target.currentLocation ());

                    output += "Airborne " + target.Potency (target.States[2]) + '\n';

                    if (s.Properties.Contains ("AIRFREE ") && (s.Properties.Contains ("CTRAIR ") && (target.ResidualFatigue > 0 || target.Fatigue > 0)))
                    {

                        exec.HasJumped = false;
                        output += exec.setAction (true);
                        exec.HasActed = true;
                    }
                    else if (s.Properties.Contains ("AIRFREE "))
                    {
                        output += exec.setAction (true);
                        exec.HasActed = true;
                    }
                }
            }

            if (!(s.StateAlterations[2].Probability > 0) && target.FallingHeight > 0)
            {
                target.FallingHeight = target.Potency (target.Airborne)
                    + (target.UnitHeight - battleMap.heightOf (target.currentLocation ()));
            }

            if (s.Malicious && s.StateAlterations[2].Potency == 0 && target.StateActive (target.Airborne) && !s.Properties.Contains ("RAPID "))
            {
                target.Airborne.Potency++;
                if (s.Properties.Contains ("FOLLOW") && target.Potency (target.Airborne) > 0)
                {
                    exec.SetHeight (target.Potency (target.Airborne));
                }

                target.FallingHeight = target.Potency (target.Airborne)
                    + (target.UnitHeight - battleMap.heightOf (target.currentLocation ()));
                if (target.FallingHeight < 0)
                {
                    target.FallingHeight = 0;
                }
                target.UnitHeight = battleMap.heightOf (target.currentLocation ());

                output += "Airborne " + target.Potency (target.States[2]) + '\n';

            }
        }

        if (s.Properties.Contains ("STAGGER") && !target.StateActive (target.Invulnerable) && !target.StateActive (target.Airborne))
        {

            if (!s.Properties.Contains ("CTRSTAGGER") || target.ResidualFatigue > 0)
            {

                target.Staggered = true;
                target.StaggerTime = Math.Abs (s.Force.Potency);
                target.IsCrouching = false;
                output += target.Grounded.ClearStates;

                if (s.Properties.Contains ("STAGGERB "))
                {
                    target.StaggerDirection = exec.currentLocation ().DirectionOf (target);
                    force (exec, 1, target, exec.currentLocation ().DirectionOf (target));
                }
                else if (s.Properties.Contains ("STAGGERF "))
                {
                    target.StaggerDirection = target.currentLocation ().DirectionOf (exec);

                    force (exec, 1, target, target.currentLocation ().DirectionOf (exec));

                }
                else if (s.Properties.Contains ("STAGGERL "))
                {
                    target.StaggerDirection = exec.DirectionLeft;
                    force (exec, 1, target, exec.currentLocation ().DirectionLeft (exec.currentLocation ().DirectionOf (target)));
                }
                else if (s.Properties.Contains ("STAGGERR "))
                {
                    target.StaggerDirection = exec.DirectionRight;

                    force (exec, 1, target, exec.currentLocation ().DirectionRight (exec.currentLocation ().DirectionOf (target)));
                }
                else
                {
                    target.StaggerDirection = "X";
                }

                //addToNotificationQueue (s, target, "STAGGER " + target.StaggerDirection + "! (" + target.StaggerTime + ")", false);

            }
        }


        if (!s.Malicious || !target.StateActive (target.Immune))
        {

            for (int i = 3; i < s.StateAlterations.Length - 1; i++)
            {

                chance = exec.R.NextDouble ();
                minimumChance = 1;
                if (s.StateAlterations[i].Probability > 0)
                {

                    minimumChance = s.StateAlterations[i].Probability;
                    minimumChance += (exec.Dexterity / 100) * s.Ratio;
                    if (s.Magic)
                    {
                        minimumChance += (((double)exec.Magick) / 400) * (1 - s.Ratio);
                    }
                    else
                    {
                        minimumChance += (((double)exec.Strength) / 400) * (1 - s.Ratio);
                    }
                    minimumChance += ((double)exec.Luck) / 800;

                    chance += target.States[i].Probability;
                    chance += target.StateResistances[i].BaseValue;

                    if (s.Malicious)
                    {
                        minimumChance -= (target.Dexterity / 100) * s.Ratio;
                        minimumChance -= (((double)target.Resistance) / 400) * (1 - s.Ratio);
                        minimumChance -= ((double)target.Luck) / 800;
                        minimumChance += ((double)target.ResidualFatigue) / 100;
                    }

                    if (chance < 0)
                    {
                        chance = 0;
                    }
                }
                if (chance <= minimumChance && s.StateAlterations[i].Probability > 0)
                {

                    if ((!s.StateAlterations[i].Name.Equals ("Poison") || target.States[i].NumTurns == 0)
                        || s.Properties.Contains ("VITALITY")
                        || s.Properties.Contains ("BURST"))
                    {
                        target.States[i].Add (s.StateAlterations[i]);
                    }
                    else
                    {
                        target.States[i].Add (new State (
                            "Poison", "PSN", 0, 0, s.StateAlterations[i].NumTurns, s.StateAlterations[i].Probability, true, s.StateAlterations[i].Phrase));
                    }

                    output += target.States[i].Name + " Lv. " + target.Potency (target.States[i]) + ", " + (target.States[i].NumTurns) + " turns" + '\n';

                    output += string.Format ("{0} {1}", target.FirstName, s.StateAlterations[i].Phrase);
                    setSkillStateAlterations (s, exec, target, s.StateAlterations[i]);

                    if (s.StateAlterations[i].Probability < 1)
                    {
                        output +=
                            string.Format (" ({0}% of {1}%)",
                                (int)(chance * 100), (int)(minimumChance * 100));
                    }

                    output += string.Format ("" + '\n' + '\n');
                }
                minimumChance = 1;
            }


            //FINAL STATE AUGMENT CAN BE VARIED
            //#1: BLIND
            if (s.Properties.Contains (" BLIND "))
            {
                chance = exec.R.NextDouble ();
                minimumChance = 1;
                if (s.StateAlterations[19].Probability > 0)
                {

                    minimumChance = s.StateAlterations[19].Probability;
                    minimumChance += (exec.Dexterity / 100) * s.Ratio;
                    if (s.Magic)
                    {
                        minimumChance += (((double)exec.Magick) / 400) * (1 - s.Ratio);
                    }
                    else
                    {
                        minimumChance += (((double)exec.Strength) / 400) * (1 - s.Ratio);
                    }
                    minimumChance += ((double)exec.Luck) / 800;

                    chance += target.States[20].Probability;
                    chance += target.StateResistances[20].BaseValue;

                    if (s.Malicious)
                    {
                        minimumChance -= (target.Dexterity / 100) * s.Ratio;
                        minimumChance -= (((double)target.Resistance) / 400) * (1 - s.Ratio);
                        minimumChance -= ((double)target.Luck) / 800;
                        minimumChance += ((double)target.ResidualFatigue) / 100;
                    }

                    if (chance < 0)
                    {
                        chance = 0;
                    }
                }
                if (chance <= minimumChance && s.StateAlterations[19].Probability > 0)
                {

                    target.States[20].Add (s.StateAlterations[19]);

                    output += target.States[20].Name + " Lv. " + target.Potency (target.States[20]) + ", " + (target.States[20].NumTurns) + " turns" + '\n';

                    output += string.Format ("{0} {1}", target.FirstName, s.StateAlterations[19].Phrase);
                    setSkillStateAlterations (s, exec, target,
                                              new State ("Blind",
                                                         s.StateAlterations[19].Abbreviation,
                                                         s.StateAlterations[19].Potency,
                                                         s.StateAlterations[19].DoublePotency,
                                                         s.StateAlterations[19].NumTurns,
                                                         s.StateAlterations[19].Probability, false, " is blinded!"));

                    if (s.StateAlterations[19].Probability < 1)
                    {
                        output +=
                            string.Format (" ({0}% of {1}%)",
                                (int)(chance * 100), (int)(minimumChance * 100));
                    }

                    output += string.Format ("" + '\n' + '\n');
                }
                minimumChance = 1;

            }

            if (s.Properties.Contains ("NOGD"))
            {
                target.NoGuard = true;
            }

            if (s.Properties.Contains ("NORST"))
            {
                target.CanRest = false;
            }

            if (s.Properties.Contains ("NOLS"))
            {
                target.forget (target.CriticalSkill);
            }

            //DMG TAKEN TO RM
            if (s.Properties.Contains ("DMGINTORM"))
            {
                output += shiftRush (target, Math.Abs (target.DamageTakenTotal), true, exec);
            }

            //DMG TAKEN TO GM
            if (s.Properties.Contains ("DMGINTOGM"))
            {
                output += shiftGuard (target, Math.Abs (target.DamageTakenTotal), true, exec);
            }

            //DMG TAKEN TO VM
            if (s.Properties.Contains ("DMGINTOVM"))
            {
                output += shiftVitality (target, Math.Abs (target.DamageTakenTotal), true, exec);
            }

            //DMG DEALT TO RM
            if (s.Properties.Contains ("DMGOUTTORM"))
            {
                output += shiftRush (target, Math.Abs (target.DamageTotal), true, exec);
            }

            //DMG DEALT TO GM
            if (s.Properties.Contains ("DMGOUTTOGM"))
            {
                output += shiftGuard (target, Math.Abs (target.DamageTotal), true, exec);
            }

            //DMG DEALT TO VM
            if (s.Properties.Contains ("DMGOUTTOVM"))
            {
                output += shiftVitality (target, Math.Abs (target.DamageTotal), true, exec);
            }


            //LEECH
            chance = exec.R.NextDouble ();
            Player absorber = null;

            if (exec.Owner == null)
            {
                absorber = exec;
            }
            else
            {
                absorber = exec.Owner;
            }

            if ((s.Properties.Contains (" LEECH ") && chance < s.StateAlterations[19].Probability) || exec.Leech)
            {
                output += string.Format ("{0} is leeched!" + '\n', target.FirstName);

                int[] changes = s.realOutput (target, decay);

                if (s.StateAlterations[19].Potency != 0)
                {
                    changes[0] *= s.StateAlterations[19].Potency;
                    changes[1] *= s.StateAlterations[19].Potency;
                    changes[2] *= s.StateAlterations[19].Potency;
                    changes[3] *= s.StateAlterations[19].Potency;
                }
                else
                {
                    changes[0] /= 2;
                    changes[1] /= 2;
                    changes[2] /= 2;
                    changes[3] /= 2;
                }



                if (s.Properties.Contains ("HP-") || exec.Leech)
                {
                    output += shiftHealth (target, changes[0], true, exec, s);

                    if (s.Properties.Contains ("-HP") || exec.Leech)
                    {
                        output += shiftHealth (absorber, Math.Abs (changes[0]), true, absorber, s);
                    }
                    if (s.Properties.Contains ("-RM"))
                    {
                        output += shiftRush (absorber, Math.Abs (changes[0]), true, exec);
                    }
                    if (s.Properties.Contains ("-GM"))
                    {
                        output += shiftGuard (absorber, Math.Abs (changes[0]), true, exec);
                    }
                    if (s.Properties.Contains ("-VM"))
                    {
                        output += shiftVitality (absorber, Math.Abs (changes[0]), true, exec);
                    }
                }
                output += " " + '\n';


                if (s.Properties.Contains ("RM-"))
                {
                    output += shiftRush (target, changes[1], true, exec);

                    if (s.Properties.Contains ("-HP"))
                    {
                        output += shiftHealth (absorber, Math.Abs (changes[1]), true, absorber, s);
                    }
                    if (s.Properties.Contains ("-RM"))
                    {
                        output += shiftRush (absorber, Math.Abs (changes[1]), true, exec);
                    }
                    if (s.Properties.Contains ("-GM"))
                    {
                        output += shiftGuard (absorber, Math.Abs (changes[1]), true, exec);
                    }
                    if (s.Properties.Contains ("-VM"))
                    {
                        output += shiftVitality (absorber, Math.Abs (changes[1]), true, exec);
                    }
                }
                output += " " + '\n';

                if (s.Properties.Contains ("GM-"))
                {
                    output += shiftGuard (target, changes[2], true, exec);

                    if (s.Properties.Contains ("-HP"))
                    {
                        output += shiftHealth (absorber, Math.Abs (changes[2]), true, absorber, s);
                    }
                    if (s.Properties.Contains ("-RM"))
                    {
                        output += shiftRush (absorber, Math.Abs (changes[2]), true, exec);
                    }
                    if (s.Properties.Contains ("-GM"))
                    {
                        output += shiftGuard (absorber, Math.Abs (changes[2]), true, exec);
                    }
                    if (s.Properties.Contains ("-VM"))
                    {
                        output += shiftVitality (absorber, Math.Abs (changes[2]), true, exec);
                    }
                }
                output += " " + '\n';

                if (s.Properties.Contains ("VM-"))
                {
                    output += shiftVitality (target, changes[3], true, exec);

                    if (s.Properties.Contains ("-HP"))
                    {
                        output += shiftHealth (absorber, Math.Abs (changes[3]), true, absorber, s);
                    }
                    if (s.Properties.Contains ("-RM"))
                    {
                        output += shiftRush (absorber, Math.Abs (changes[3]), true, exec);
                    }
                    if (s.Properties.Contains ("-GM"))
                    {
                        output += shiftGuard (absorber, Math.Abs (changes[3]), true, exec);
                    }
                    if (s.Properties.Contains ("-VM"))
                    {
                        output += shiftVitality (absorber, Math.Abs (changes[3]), true, exec);
                    }
                }
                output += " " + '\n';
            }

            //GRAVITY
            if (s.Properties.Contains ("GRAVITY"))
            {
                double gravRate = ((double)NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf ('%') + 1, 3)) / 100);
                output += string.Format ("Gravity! {0}%" + '\n', (int)(gravRate * 100));
                if (s.Properties.Contains ("HP%"))
                {
                    output += shiftHealth (target, (int)(target.Health.MeterLevel * (1 - gravRate)) * -1, true, exec, s);
                }
                if (s.Properties.Contains ("RM%"))
                {
                    output += shiftRush (target, (int)(target.Rush.MeterLevel * (1 - gravRate)) * -1, true, exec);
                }
                if (s.Properties.Contains ("GM%"))
                {
                    output += shiftGuard (target, (int)(target.Guard.MeterLevel * (1 - gravRate)) * -1, true, exec);
                }
                if (s.Properties.Contains ("VM%"))
                {
                    output += shiftVitality (target, (int)(target.Vitality.MeterLevel * (1 - gravRate)) * -1, true, exec);
                }
            }

            if (s.Properties.Contains ("DISAPPEAR"))
            {
                if (!s.Properties.Contains ("DEAD"))
                {
                    output += string.Format ("{0} is removed from battle!" + '\n', target.FirstName);
                }
                else
                {
                    if (s.Properties.Contains ("DEVOUR"))
                    {
                        output += string.Format ("{0} is devoured!" + '\n', target.FirstName);
                    }
                    else
                    {
                        output += string.Format ("{0} is destroyed!" + '\n', target.FirstName);
                    }
                    target.CanBeRevived = false;
                }
                output += removePlayer (target);
            }

            return output;
        }
        return "";
    }

    private void setSkillStateAlterations (Skill s, Player exec, Player target, State st)
    {
        if (st.Malicious)
        {
            s.Owner.StatusAfflictionsPerRound++;
            s.Owner.StatusAfflictionsTotal++;
        }
        else
        {
            s.Owner.StatusAidsPerRound++;
            s.Owner.StatusAidsTotal++;
        }

        if (!s.Properties.Contains (" NOSTAT "))
        {
            addToNotificationQueue (s, target, string.Format ("{0} ({1}, {2})", new object[] { st.Name.ToUpper (), st.Probability, st.NumTurns }), true);
        }

        if (s.CounterSkill != null)
        {
            target.learn (s.CounterSkill, false, st.NumTurns);
            createAnimationOnMap ("Taunt", StatusChannel, target.CentralPosition, 1f, true);
        }
        if (st.Name.Equals ("Parry"))
        {
            if (s.CounterSkill == null)
            {
                createAnimationOnMap ("Parry", StatusChannel, target.CentralPosition, 1f, true);
            }
        }
        if (st.Name.Equals ("Poison"))
        {
            createAnimationOnMap ("Poison", StatusChannel, target.CentralPosition, 1f, true);
        }
        if (name.Equals ("Regen"))
        {
            createAnimationOnMap ("Heal", StatusChannel, target.CentralPosition, 1f, true);
        }
        if (name.Equals ("Daze"))
        {
            createAnimationOnMap ("Stun", StatusChannel, target.CentralPosition, 1f, true);
        }
        if (name.Equals ("Confuse"))
        {
            createAnimationOnMap ("Dizzy", StatusChannel, target.CentralPosition, 1f, true);
        }
        if (name.Equals ("Sadness"))
        {
            createAnimationOnMap ("GStun", StatusChannel, target.CentralPosition, 1f, true);
        }
        if (name.Equals ("Fury"))
        {
            createAnimationOnMap ("Burn", StatusChannel, target.CentralPosition, 1f, true);
        }
        if (name.Equals ("Sleep"))
        {
            if (s.Elementals[1].Potency > 0)
            {
                createAnimationOnMap ("Icy", StatusChannel, target.CentralPosition, 1f, true);
            }
            else
            {
                createAnimationOnMap ("Sleep", StatusChannel, target.CentralPosition, 1f, true);
            }
        }
        if (name.Equals ("Adle"))
        {
            createAnimationOnMap ("GStun", StatusChannel, target.CentralPosition, 1f, true);
        }
        if (name.Equals ("Freeze"))
        {
            createAnimationOnMap ("Icy", StatusChannel, target.CentralPosition, 1f, true);
        }
        if (name.Equals ("Immune"))
        {
            createAnimationOnMap ("Parry", StatusChannel, target.CentralPosition, 1f, true);
        }
        if (name.Equals ("Invulnerable"))
        {
            createAnimationOnMap ("Parry", StatusChannel, target.CentralPosition, 1f, true);
        }
        if (name.Equals ("Burn"))
        {
            createAnimationOnMap ("Burn", StatusChannel, target.CentralPosition, 1f, true);
        }
        if (name.Equals ("Learn"))
        {
            createAnimationOnMap ("GStun", StatusChannel, target.CentralPosition, 1f, true);
        }
        if (name.Equals ("Blind"))
        {
            createAnimationOnMap ("Blind", StatusChannel, target.CentralPosition, 1f, true);
        }
    }

    //METER CHANGE/METER SHIFT
    private string meterChange (Player exec, Skill s, Player target, Boolean cancelledOut, double decay)
    {
        string output = "";

        if (s.Change[0] != 0 || s.Change[1] != 0 || s.Change[2] != 0 || s.Change[3] != 0)
        {

            if (s.Properties.Contains ("TMCH"))
            {
                battleMap.ActiveTime += NumberConverter.ConvertToInt (s.Properties.Substring (s.Properties.IndexOf (':') + 1, 3));
            }

            int[] changes;

            int selfMeterGain = (Math.Abs (s.Change[0])
                + Math.Abs (s.Change[1])
                + Math.Abs (s.Change[2])
                + Math.Abs (s.Change[3]));

            //METER GAIN FROM USING ATTACK
            if (!exec.VMGainBlocked && !s.Properties.Contains ("NOVM ") && !exec.StateActive (exec.Sadness))
            {

                if (!target.IsGuarding)
                {
                    output += shiftVitality (exec, selfMeterGain / 7, false, null);
                    if (exec.Owner != null && !exec.NoGainForMaster)
                    {
                        output += shiftVitality (exec.Owner, selfMeterGain / 7, false, null);
                    }
                }
                else
                {
                    output += shiftVitality (exec, selfMeterGain / 14, false, null);
                    if (exec.Owner != null && !exec.NoGainForMaster)
                    {
                        output += shiftVitality (exec.Owner, selfMeterGain / 14, false, null);
                    }

                }

            }

            //TARGET METER GAIN FROM GETTING HIT BY ATTACK
            if (!target.VMGainBlocked && !target.StateActive (target.Sadness) && s.Malicious)
            {

                if (!target.IsGuarding)
                {
                    output += shiftVitality (target, (Math.Abs (s.Change[0])
                        + Math.Abs (s.Change[1])
                        + Math.Abs (s.Change[2])
                        + Math.Abs (s.Change[3])) / 14, false, null);
                }
                else
                {
                    output += shiftVitality (target, (Math.Abs (s.Change[0])
                        + Math.Abs (s.Change[1])
                        + Math.Abs (s.Change[2])
                        + Math.Abs (s.Change[3])) / 28, false, null);
                }
            }

            if (!s.Properties.Contains ("FLAT "))
            {
                changes = s.realOutput (target, decay);
            }
            else
            {
                changes = s.Change;
            }

            if (target.Fatigue > 0 && s.Malicious && !s.Grapple)
            {
                createAnimationOnMap ("Critical", BonusChannel, target.CentralPosition, 2f, false);

                changes[0] += ((changes[0] * target.Fatigue) / 35) + ((changes[0] * s.Elementals[9].Potency) / 35);
                changes[1] += ((changes[1] * target.Fatigue) / 35) + ((changes[1] * s.Elementals[9].Potency) / 35);
                changes[2] += ((changes[2] * target.Fatigue) / 35) + ((changes[2] * s.Elementals[9].Potency) / 35);
                changes[3] += ((changes[3] * target.Fatigue) / 35) + ((changes[3] * s.Elementals[9].Potency) / 35);
            }

            if (!s.Beneficial && target.Fatigue > 0)
            {
                target.ResidualFatigue = target.Fatigue;
                target.Fatigue = 0;
            }

            if (target.IsResting && s.Malicious)
            {
                output += string.Format ("Resting Penalty! {0}" + '\n', target.RestRatio);

                target.Vocals.ContactSound.clip = criticalSound;
                target.Vocals.ContactSound.Play ();

                createAnimationOnMap ("Critical", BonusChannel, target.CentralPosition, 2f, false);

                changes[0] += (((int)(changes[0] * (target.RestRatio + 2))) / 35) + ((changes[0] * s.Elementals[9].Potency) / 35);
                changes[1] += (((int)(changes[1] * (target.RestRatio + 2))) / 35) + ((changes[1] * s.Elementals[9].Potency) / 35);
                changes[2] += (((int)(changes[2] * (target.RestRatio + 2))) / 35) + ((changes[2] * s.Elementals[9].Potency) / 35);
                changes[3] += (((int)(changes[3] * (target.RestRatio + 2))) / 35) + ((changes[3] * s.Elementals[9].Potency) / 35);
                target.IsResting = false;
                target.NumRests = 0;
            }

            if (target.IsTaunting && s.Malicious)
            {
                output += string.Format ("Taunting Penalty! {0}" + '\n', target.RestRatio);

                target.Vocals.ContactSound.clip = criticalSound;
                target.Vocals.ContactSound.Play ();

                createAnimationOnMap ("Critical", BonusChannel, target.CentralPosition, 2f, false);

                changes[0] += (((int)(changes[0] * (target.RestRatio + 2))) / 35) + ((changes[0] * s.Elementals[9].Potency) / 35);
                changes[1] += (((int)(changes[1] * (target.RestRatio + 2))) / 35) + ((changes[1] * s.Elementals[9].Potency) / 35);
                changes[2] += (((int)(changes[2] * (target.RestRatio + 2))) / 35) + ((changes[2] * s.Elementals[9].Potency) / 35);
                changes[3] += (((int)(changes[3] * (target.RestRatio + 2))) / 35) + ((changes[3] * s.Elementals[9].Potency) / 35);
                target.IsTaunting = false;
                target.TauntDecay++;
            }

            if (target.WeakFrame && s.Grapple)
            {
                output += string.Format ("Weak Frame!" + '\n');
                changes[0] += (int)(s.Change[0] * 0.2) + ((changes[0] * s.Elementals[9].Potency) / 35);
                changes[1] += (int)(s.Change[1] * 0.2) + ((changes[1] * s.Elementals[9].Potency) / 35);
                changes[2] += (int)(s.Change[2] * 0.2) + ((changes[2] * s.Elementals[9].Potency) / 35);
                changes[3] += (int)(s.Change[3] * 0.2) + ((changes[3] * s.Elementals[9].Potency) / 35);
            }

            //TARGET RM SHIFT
            if (s.Change[1] != 0 && !s.Properties.Contains ("RM-"))
            {
                output += shiftRush (target, (int)(changes[1] / target.GuardRatio), true, exec);
            }

            //TARGET GM SHIFT
            if (s.Change[2] != 0 && !s.Properties.Contains ("GM-"))
            {
                output += shiftGuard (target, (int)(changes[2] / target.GuardRatio), true, exec);
            }

            //TARGET VM SHIFT
            if (s.Change[3] != 0 && !s.Properties.Contains ("VM-"))
            {
                output += shiftVitality (target, (int)(changes[3] / target.GuardRatio), true, exec);
            }

            //TARGET HEALTH SHIFT
            if (s.Change[0] != 0 && (!s.Properties.Contains ("HP-") || s.Properties.Contains ("+DMG")))
            {

                //NON-GUARDING
                if ((!s.Malicious || !target.IsGuarding) && changes[0] != 0)
                {
                    output += shiftHealth (target, changes[0], true, exec, s, true);

                    //WAKE UP
                    if (target.StateActive (target.Sleep) && (s.Malicious || s.Properties.Contains ("WAKE")))
                    {

                        double chance = exec.R.NextDouble ();
                        if (chance > ((double)target.Potency (target.Sleep)) / 10)
                        {
                            output += string.Format ("{0} wakes up!" + '\n', target.FirstName);
                            createAnimationOnMap ("Recovery", StateChannel, target.CentralPosition, 2f, false);
                            target.Sleep.Clear ();
                        }
                    }
                }

                //GUARDING
                else if (s.Malicious && target.IsGuarding && changes[0] != 0)
                {
                    if (!s.Properties.Contains ("NORMAL "))
                    {
                        output += shiftHealth (target, (int)(changes[0] / target.GuardRatio), true, exec, s);
                    }
                    else
                    {
                        output += shiftGuard (target, changes[0] / ((int)(target.GuardRatio)), true, exec);
                        output += shiftHealth (target, (int)(changes[0] / target.GuardRatio), false, exec, s);
                    }
                }
                output += string.Format ("---" + '\n');
            }

            //LUCK AND CRITICAL HITS
            double luckChance = exec.R.NextDouble ();
            if (!s.Properties.Contains ("NOCRIT") && !target.KOd && !target.IsGuarding && (s.Malicious || s.Beneficial) && (luckChance < ((double)exec.Luck) / 500))
            {
                output += string.Format ("Critical! {0}%" + '\n', (int)(luckChance * 100));

                if (s.Malicious)
                {
                    target.Vocals.ContactSound.clip = criticalSound;
                    target.Vocals.ContactSound.Play ();

                    createAnimationOnMap ("Critical", BonusChannel, target.CentralPosition, 2f, false);
                }
                else
                {
                    createAnimationOnMap ("Heal", BonusChannel, target.CentralPosition, 2f, true);
                }


                if (changes[0] != 0)
                {
                    output += shiftHealth (target, exec.randomOutput (changes[0] / 20), false, exec, s);
                    output += string.Format ("---" + '\n');
                }
            }
        }
        return output;
    }

    public string pullTarget (Player exec, Player target, Skill s)
    {
        string output = "";
        output += string.Format ("{0} is pulled to {1}!" + '\n', target.FirstName, exec.FirstName);
        Location loc = target.openBorderOf (exec.currentLocation (), true, s);
        if (loc != null)
        {
            output += recordMovement (target, s, loc, false, false, true, false, true, true, target.DirectionOf (exec));
        }

        return output;
    }

    public string switchPastLocation (Player exec, Location targetLoc, Skill s)
    {
        string output = "";
        output += string.Format ("{0} moves past!" + '\n', exec.FirstName);
        Location loc = new Location (
            targetLoc.Row + (targetLoc.Row - exec.currentLocation ().Row),
            targetLoc.Column + (targetLoc.Column - exec.currentLocation ().Column));

        if (!battleMap.isEmpty (targetLoc) && battleMap.objectAt (targetLoc).sentient ())
        {
            Player target = (Player)battleMap.MapGrid[targetLoc.Row][targetLoc.Column];
            if (exec.bordersWith (target.SearchName) && !battleMap.isValid (loc) && !target.StateActive (target.Invulnerable))
            {
                return switchLocations (exec, target, s, true, false, false, !s.Properties.Contains ("DODGE"));
            }
        }

        while (!loc.Equals (targetLoc))
        {
            if (battleMap.isValid (loc) && battleMap.isEmpty (loc) && battleMap.canMakeMove (exec, loc, s))
            {
                //output += "TOSS: " + FirstName + " to " + loc + '\n';
                output += recordMovement (exec, s, loc, false, false,
                    exec.Flight, false, true, !s.Properties.Contains ("DODGE"), "");
                return output;
            }
            loc = loc.getNewLocationFromDirection (loc.DirectionOf (targetLoc));
        }

        if (targetLoc.bordersWith (exec.currentLocation ())
            && battleMap.objectAt (targetLoc) != null
            && battleMap.playerAt (targetLoc) != null
            && !battleMap.playerAt (targetLoc).StateActive (battleMap.playerAt (targetLoc).Invulnerable))
        {
            return switchLocations (exec, (Player)battleMap.objectAt (targetLoc), s, true, false, false, !s.Properties.Contains ("DODGE"));
        }

        return output;
    }

    public string flipTarget (Player exec, Player target, Skill s)
    {
        string output = "";
        output += string.Format ("{0} tosses {1}!" + '\n', exec.FirstName, target.FirstName);
        Location loc = new Location (
            exec.currentLocation ().Row + (exec.currentLocation ().Row - target.currentLocation ().Row),
            exec.currentLocation ().Column + (exec.currentLocation ().Column - target.currentLocation ().Column));

        if (exec.bordersWith (target.SearchName) && (!battleMap.isValid (loc)
            || (!battleMap.isEmpty (loc) && !battleMap.objectAt (loc).Equals (target))))
        {
            return switchLocations (exec, target, s, true, false, false, !s.Properties.Contains ("DODGE"));
        }

        while (!loc.Equals (exec.currentLocation ()))
        {
            if (battleMap.isValid (loc) && battleMap.isEmpty (loc) && battleMap.canBePushed (target, loc, s))
            {
                //output += "FLIP: " + target.FirstName + " to " + loc + '\n';
                output += recordMovement (target, s, loc, false, false,
                    target.Flight, false, true, true, "");
                return output;
            }
            loc = loc.getNewLocationFromDirection (loc.DirectionOf (exec));
        }
        return output;
    }

    private string execSetResistances (Skill s, Player target)
    {
        string output = "";
        for (int i = 0; i < s.StateResistances.Length; i++)
        {
            if (s.StateResistances[i].BaseValue > 0)
            {

                output += string.Format ("{0}'s {1} is shifted by {2}% for {3} turns!" + '\n',
                    target.FirstName, s.StateResistances[i].Name, (int)(s.StateResistances[i].BaseValue * 100), s.StateResistances[i].Holder);
                target.StateResistances[i].BaseValue = s.StateResistances[i].BaseValue;
                target.StateResistances[i].Holder = s.StateResistances[i].Holder;
            }
        }
        return output;
    }

    private string execEndStates (Player exec, Skill s, Player target)
    {
        /**
                 * 
                 * GROUNDED AIRBORNE COUNTER PARRY POISON REGEN DAZE CONFUSE SADNESS FURY SLEEP
                 * ADLE FREEZE IMMUNE INVULNERABLE BURN INVISIBLE LEARN
                 * 
                 */
        string output = "";
        if (s.Properties.Contains ("ENDSTUN"))
        {
            output += shiftStun (target, -1 * target.Stun.MeterLevel, true, exec);
        }
        if (s.Properties.Contains ("ENDAIRBORNE "))
        {
            target.SetHeight (0);
        }
        if (s.Properties.Contains ("ENDGROUNDED "))
        {
            target.Grounded.Potency = 0;
        }
        if (s.Properties.Contains ("ENDPOISON "))
        {
            output += target.Poison.ClearStates;
        }
        if (s.Properties.Contains ("ENDCOUNTER "))
        {
            output += target.Counter.ClearStates;
        }
        if (s.Properties.Contains ("ENDPARRY "))
        {
            output += target.Parry.ClearStates;
        }
        if (s.Properties.Contains ("ENDREGEN "))
        {
            output += target.Regen.ClearStates;
        }
        if (s.Properties.Contains ("ENDDAZE "))
        {
            output += target.Daze.ClearStates;
        }
        if (s.Properties.Contains ("ENDCONFUSE "))
        {
            output += target.Confuse.ClearStates;
        }
        if (s.Properties.Contains ("ENDSADNESS "))
        {
            output += target.Sadness.ClearStates;
        }
        if (s.Properties.Contains ("ENDFURY "))
        {
            output += target.Fury.ClearStates;
        }
        if (s.Properties.Contains ("ENDSLEEP "))
        {
            output += target.Sleep.ClearStates;
        }
        if (s.Properties.Contains ("ENDADLE "))
        {
            output += target.Adle.ClearStates;
        }
        if (s.Properties.Contains ("ENDFREEZE "))
        {
            output += target.Freeze.ClearStates;
        }
        if (s.Properties.Contains ("ENDIMMUNE "))
        {
            output += target.Immune.ClearStates;
        }
        if (s.Properties.Contains ("ENDINVULNERABLE "))
        {
            output += target.Invulnerable.ClearStates;
        }
        if (s.Properties.Contains ("ENDBURN "))
        {
            output += target.Burn.ClearStates;
        }
        if (s.Properties.Contains ("ENDINVISIBLE "))
        {
            output += target.Invisible.ClearStates;
        }
        if (s.Properties.Contains ("ENDLEARN "))
        {
            output += target.Learn.ClearStates;
        }
        return output;
    }

    public void setInputTimer (float amt)
    {
        finishTime = amt;
        if (amt > 0)
        {
            finishTimeMax = amt;
        }
        else
        {
            finishTimeMax = 1.0f;
        }

        if (activePlayer.MyTeam.AutoLink)
        {

        }

    }
}
